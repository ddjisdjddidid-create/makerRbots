import os
import json
import asyncio
import random
import base64
from datetime import datetime, timedelta
from threading import Thread
from io import BytesIO

from flask import Flask
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, Bot

# ÙØ­Øµ Ø§Ù„Ø¨ÙŠØ¦Ø© Ù„Ù…Ù†Ø¹ Ø§Ù„ØªØ´ØºÙŠÙ„ Ø§Ù„Ù…Ø²Ø¯ÙˆØ¬
IS_PRODUCTION = os.environ.get('RENDER') == 'true'
IS_REPLIT = os.environ.get('REPL_ID') is not None
from telegram.ext import (
    Application,
    CommandHandler,
    CallbackQueryHandler,
    MessageHandler,
    filters,
    ContextTypes,
    InlineQueryHandler
)
from telegram.constants import ChatMemberStatus
from groq import Groq
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.jobstores.base import JobLookupError
from PIL import Image

import database as db
from logger_setup import (
    main_logger as logger,
    log_main, log_child, log_error, log_user_action,
    log_bot_created, log_broadcast, log_startup, log_child_startup, log_child_error
)

BOT_TOKEN = os.environ.get("BOT_TOKEN")
GROQ_API_KEY = os.environ.get("GROQ_API_KEY")
DEVELOPER_ID = 8087077168
DEVELOPER_USERNAME = "Dev_Mido"
REQUIRED_CHANNEL = "@TepthonHelp"

flask_app = Flask(__name__)
main_scheduler = AsyncIOScheduler()

ADHKAR_LIST = [
    "Ø³Ø¨Ø­Ø§Ù† Ø§Ù„Ù„Ù‡ ÙˆØ¨Ø­Ù…Ø¯Ù‡ØŒ Ø³Ø¨Ø­Ø§Ù† Ø§Ù„Ù„Ù‡ Ø§Ù„Ø¹Ø¸ÙŠÙ…",
    "Ù„Ø§ Ø§Ù„Ù‡ Ø§Ù„Ø§ Ø§Ù„Ù„Ù‡ ÙˆØ­Ø¯Ù‡ Ù„Ø§ Ø´Ø±ÙŠÙƒ Ù„Ù‡ØŒ Ù„Ù‡ Ø§Ù„Ù…Ù„Ùƒ ÙˆÙ„Ù‡ Ø§Ù„Ø­Ù…Ø¯ ÙˆÙ‡Ùˆ Ø¹Ù„Ù‰ ÙƒÙ„ Ø´ÙŠØ¡ Ù‚Ø¯ÙŠØ±",
    "Ø³Ø¨Ø­Ø§Ù† Ø§Ù„Ù„Ù‡ØŒ ÙˆØ§Ù„Ø­Ù…Ø¯ Ù„Ù„Ù‡ØŒ ÙˆÙ„Ø§ Ø§Ù„Ù‡ Ø§Ù„Ø§ Ø§Ù„Ù„Ù‡ØŒ ÙˆØ§Ù„Ù„Ù‡ Ø§ÙƒØ¨Ø±",
    "Ù„Ø§ Ø­ÙˆÙ„ ÙˆÙ„Ø§ Ù‚ÙˆØ© Ø§Ù„Ø§ Ø¨Ø§Ù„Ù„Ù‡ Ø§Ù„Ø¹Ù„ÙŠ Ø§Ù„Ø¹Ø¸ÙŠÙ…",
    "Ø§Ø³ØªØºÙØ± Ø§Ù„Ù„Ù‡ Ø§Ù„Ø¹Ø¸ÙŠÙ… Ø§Ù„Ø°ÙŠ Ù„Ø§ Ø§Ù„Ù‡ Ø§Ù„Ø§ Ù‡Ùˆ Ø§Ù„Ø­ÙŠ Ø§Ù„Ù‚ÙŠÙˆÙ… ÙˆØ§ØªÙˆØ¨ Ø§Ù„ÙŠÙ‡",
    "Ø§Ù„Ù„Ù‡Ù… ØµÙ„ ÙˆØ³Ù„Ù… Ø¹Ù„Ù‰ Ù†Ø¨ÙŠÙ†Ø§ Ù…Ø­Ù…Ø¯",
    "Ø³Ø¨Ø­Ø§Ù† Ø§Ù„Ù„Ù‡ Ø¹Ø¯Ø¯ Ù…Ø§ Ø®Ù„Ù‚ØŒ Ø³Ø¨Ø­Ø§Ù† Ø§Ù„Ù„Ù‡ Ù…Ù„Ø¡ Ù…Ø§ Ø®Ù„Ù‚ØŒ Ø³Ø¨Ø­Ø§Ù† Ø§Ù„Ù„Ù‡ Ø¹Ø¯Ø¯ Ù…Ø§ ÙÙŠ Ø§Ù„Ø§Ø±Ø¶ ÙˆØ§Ù„Ø³Ù…Ø§Ø¡",
    "Ø§Ù„Ø­Ù…Ø¯ Ù„Ù„Ù‡ Ø­Ù…Ø¯Ø§ ÙƒØ«ÙŠØ±Ø§ Ø·ÙŠØ¨Ø§ Ù…Ø¨Ø§Ø±ÙƒØ§ ÙÙŠÙ‡",
    "Ø§Ù„Ù„Ù‡Ù… Ø§Ù†ÙŠ Ø§Ø³Ø§Ù„Ùƒ Ø§Ù„Ø¹ÙÙˆ ÙˆØ§Ù„Ø¹Ø§ÙÙŠØ© ÙÙŠ Ø§Ù„Ø¯Ù†ÙŠØ§ ÙˆØ§Ù„Ø§Ø®Ø±Ø©",
    "Ø±Ø¨ Ø§ØºÙØ± Ù„ÙŠ ÙˆØªØ¨ Ø¹Ù„ÙŠ Ø§Ù†Ùƒ Ø§Ù†Øª Ø§Ù„ØªÙˆØ§Ø¨ Ø§Ù„Ø±Ø­ÙŠÙ…",
    "Ø§Ù„Ù„Ù‡Ù… Ø§Ù†Ùƒ Ø¹ÙÙˆ ØªØ­Ø¨ Ø§Ù„Ø¹ÙÙˆ ÙØ§Ø¹Ù Ø¹Ù†ÙŠ",
    "ÙŠØ§ Ø­ÙŠ ÙŠØ§ Ù‚ÙŠÙˆÙ… Ø¨Ø±Ø­Ù…ØªÙƒ Ø§Ø³ØªØºÙŠØ«",
    "Ù„Ø§ Ø§Ù„Ù‡ Ø§Ù„Ø§ Ø§Ù†Øª Ø³Ø¨Ø­Ø§Ù†Ùƒ Ø§Ù†ÙŠ ÙƒÙ†Øª Ù…Ù† Ø§Ù„Ø¸Ø§Ù„Ù…ÙŠÙ†",
    "Ø­Ø³Ø¨ÙŠ Ø§Ù„Ù„Ù‡ Ù„Ø§ Ø§Ù„Ù‡ Ø§Ù„Ø§ Ù‡Ùˆ Ø¹Ù„ÙŠÙ‡ ØªÙˆÙƒÙ„Øª ÙˆÙ‡Ùˆ Ø±Ø¨ Ø§Ù„Ø¹Ø±Ø´ Ø§Ù„Ø¹Ø¸ÙŠÙ…",
    "Ø§Ù„Ù„Ù‡Ù… Ø§Ù†ÙŠ Ø§Ø¹ÙˆØ° Ø¨Ùƒ Ù…Ù† Ø§Ù„Ù‡Ù… ÙˆØ§Ù„Ø­Ø²Ù† ÙˆØ§Ù„Ø¹Ø¬Ø² ÙˆØ§Ù„ÙƒØ³Ù„",
    "Ø±Ø¨ Ø§Ø´Ø±Ø­ Ù„ÙŠ ØµØ¯Ø±ÙŠ ÙˆÙŠØ³Ø± Ù„ÙŠ Ø§Ù…Ø±ÙŠ",
    "Ø§Ù„Ù„Ù‡Ù… Ù„Ø§ Ø³Ù‡Ù„ Ø§Ù„Ø§ Ù…Ø§ Ø¬Ø¹Ù„ØªÙ‡ Ø³Ù‡Ù„Ø§ ÙˆØ§Ù†Øª ØªØ¬Ø¹Ù„ Ø§Ù„Ø­Ø²Ù† Ø§Ø°Ø§ Ø´Ø¦Øª Ø³Ù‡Ù„Ø§",
    "Ø±Ø¨ Ø²Ø¯Ù†ÙŠ Ø¹Ù„Ù…Ø§",
    "Ø§Ù„Ù„Ù‡Ù… Ø§Ù†ÙŠ Ø§Ø³Ø§Ù„Ùƒ Ø§Ù„Ù‡Ø¯Ù‰ ÙˆØ§Ù„ØªÙ‚Ù‰ ÙˆØ§Ù„Ø¹ÙØ§Ù ÙˆØ§Ù„ØºÙ†Ù‰",
    "Ø§Ù„Ù„Ù‡Ù… Ø§ØµÙ„Ø­ Ù„ÙŠ Ø¯ÙŠÙ†ÙŠ Ø§Ù„Ø°ÙŠ Ù‡Ùˆ Ø¹ØµÙ…Ø© Ø§Ù…Ø±ÙŠ",
    "Ø§Ù„Ù„Ù‡Ù… Ø§Ø±Ø­Ù…Ù†ÙŠ Ø¨ØªØ±Ùƒ Ø§Ù„Ù…Ø¹Ø§ØµÙŠ Ø§Ø¨Ø¯Ø§ Ù…Ø§ Ø§Ø¨Ù‚ÙŠØªÙ†ÙŠ",
    "Ø§Ù„Ù„Ù‡Ù… Ø§Ø±Ø²Ù‚Ù†ÙŠ Ø­Ø¨Ùƒ ÙˆØ­Ø¨ Ù…Ù† ÙŠØ­Ø¨Ùƒ ÙˆØ­Ø¨ Ø¹Ù…Ù„ ÙŠÙ‚Ø±Ø¨Ù†ÙŠ Ø§Ù„Ù‰ Ø­Ø¨Ùƒ",
    "Ø§Ù„Ù„Ù‡Ù… Ø§Ø¬Ø¹Ù„ Ø§Ù„Ù‚Ø±Ø§Ù† Ø±Ø¨ÙŠØ¹ Ù‚Ù„Ø¨ÙŠ ÙˆÙ†ÙˆØ± ØµØ¯Ø±ÙŠ ÙˆØ¬Ù„Ø§Ø¡ Ø­Ø²Ù†ÙŠ ÙˆØ°Ù‡Ø§Ø¨ Ù‡Ù…ÙŠ",
    "Ø§Ù„Ù„Ù‡Ù… Ø§Ù†ÙŠ Ø§Ø¹ÙˆØ° Ø¨Ùƒ Ù…Ù† Ø¹Ù„Ù… Ù„Ø§ ÙŠÙ†ÙØ¹ ÙˆÙ…Ù† Ù‚Ù„Ø¨ Ù„Ø§ ÙŠØ®Ø´Ø¹",
    "Ø±Ø¨ Ù‡Ø¨ Ù„ÙŠ Ù…Ù† Ù„Ø¯Ù†Ùƒ Ø±Ø­Ù…Ø© Ø§Ù†Ùƒ Ø§Ù†Øª Ø§Ù„ÙˆÙ‡Ø§Ø¨",
    "Ø§Ù„Ù„Ù‡Ù… Ø§ØªÙ†Ø§ ÙÙŠ Ø§Ù„Ø¯Ù†ÙŠØ§ Ø­Ø³Ù†Ø© ÙˆÙÙŠ Ø§Ù„Ø§Ø®Ø±Ø© Ø­Ø³Ù†Ø© ÙˆÙ‚Ù†Ø§ Ø¹Ø°Ø§Ø¨ Ø§Ù„Ù†Ø§Ø±",
    "Ø³Ø¨Ø­Ø§Ù† Ø§Ù„Ù„Ù‡ ÙˆØ¨Ø­Ù…Ø¯Ù‡ Ø¹Ø¯Ø¯ Ø®Ù„Ù‚Ù‡ ÙˆØ±Ø¶Ø§ Ù†ÙØ³Ù‡ ÙˆØ²Ù†Ø© Ø¹Ø±Ø´Ù‡ ÙˆÙ…Ø¯Ø§Ø¯ ÙƒÙ„Ù…Ø§ØªÙ‡",
    "Ø§Ù„Ù„Ù‡Ù… Ø§ØºÙØ± Ù„ÙŠ Ø°Ù†Ø¨ÙŠ ÙƒÙ„Ù‡ Ø¯Ù‚Ù‡ ÙˆØ¬Ù„Ù‡ ÙˆØ§ÙˆÙ„Ù‡ ÙˆØ§Ø®Ø±Ù‡ ÙˆØ¹Ù„Ø§Ù†ÙŠØªÙ‡ ÙˆØ³Ø±Ù‡",
    "Ø§Ù„Ù„Ù‡Ù… Ø§Ù†ÙŠ Ø§Ø³Ø§Ù„Ùƒ Ù…Ù† Ø§Ù„Ø®ÙŠØ± ÙƒÙ„Ù‡ Ø¹Ø§Ø¬Ù„Ù‡ ÙˆØ§Ø¬Ù„Ù‡ Ù…Ø§ Ø¹Ù„Ù…Øª Ù…Ù†Ù‡ ÙˆÙ…Ø§ Ù„Ù… Ø§Ø¹Ù„Ù…",
    "Ø§Ù„Ù„Ù‡Ù… Ø§Ù†ÙŠ Ø§Ø¹ÙˆØ° Ø¨Ùƒ Ù…Ù† Ø§Ù„Ø´Ø± ÙƒÙ„Ù‡ Ø¹Ø§Ø¬Ù„Ù‡ ÙˆØ§Ø¬Ù„Ù‡ Ù…Ø§ Ø¹Ù„Ù…Øª Ù…Ù†Ù‡ ÙˆÙ…Ø§ Ù„Ù… Ø§Ø¹Ù„Ù…",
    "Ø§Ù„Ù„Ù‡Ù… Ø§Ù†ÙŠ Ø§Ø³Ø§Ù„Ùƒ Ø§Ù„Ø¬Ù†Ø© ÙˆÙ…Ø§ Ù‚Ø±Ø¨ Ø§Ù„ÙŠÙ‡Ø§ Ù…Ù† Ù‚ÙˆÙ„ Ø§Ùˆ Ø¹Ù…Ù„",
    "Ø§Ù„Ù„Ù‡Ù… Ø§Ù†ÙŠ Ø§Ø¹ÙˆØ° Ø¨Ùƒ Ù…Ù† Ø§Ù„Ù†Ø§Ø± ÙˆÙ…Ø§ Ù‚Ø±Ø¨ Ø§Ù„ÙŠÙ‡Ø§ Ù…Ù† Ù‚ÙˆÙ„ Ø§Ùˆ Ø¹Ù…Ù„",
    "Ø§Ù„Ù„Ù‡Ù… Ø¨Ø§Ø¹Ù„Ù…Ùƒ Ø§Ù„ØºÙŠØ¨ ÙˆÙ‚Ø¯Ø±ØªÙƒ Ø¹Ù„Ù‰ Ø§Ù„Ø®Ù„Ù‚ Ø§Ø­ÙŠÙ†ÙŠ Ù…Ø§ Ø¹Ù„Ù…Øª Ø§Ù„Ø­ÙŠØ§Ø© Ø®ÙŠØ±Ø§ Ù„ÙŠ",
    "Ø§Ù„Ù„Ù‡Ù… Ø§Ù†ÙŠ Ø§Ø³Ø§Ù„Ùƒ Ø®Ø´ÙŠØªÙƒ ÙÙŠ Ø§Ù„ØºÙŠØ¨ ÙˆØ§Ù„Ø´Ù‡Ø§Ø¯Ø©",
    "Ø§Ù„Ù„Ù‡Ù… Ø§Ù†ÙŠ Ø§Ø³Ø§Ù„Ùƒ ÙƒÙ„Ù…Ø© Ø§Ù„Ø­Ù‚ ÙÙŠ Ø§Ù„Ø±Ø¶Ø§ ÙˆØ§Ù„ØºØ¶Ø¨",
    "Ø§Ù„Ù„Ù‡Ù… Ø§Ù†ÙŠ Ø§Ø³Ø§Ù„Ùƒ Ø§Ù„Ù‚ØµØ¯ ÙÙŠ Ø§Ù„ÙÙ‚Ø± ÙˆØ§Ù„ØºÙ†Ù‰",
    "Ø§Ù„Ù„Ù‡Ù… Ø§Ù†ÙŠ Ø§Ø³Ø§Ù„Ùƒ Ù†Ø¹ÙŠÙ…Ø§ Ù„Ø§ ÙŠÙ†ÙØ¯ ÙˆÙ‚Ø±Ø© Ø¹ÙŠÙ† Ù„Ø§ ØªÙ†Ù‚Ø·Ø¹",
    "Ø§Ù„Ù„Ù‡Ù… Ø§Ù†ÙŠ Ø§Ø³Ø§Ù„Ùƒ Ø§Ù„Ø±Ø¶Ø§ Ø¨Ø¹Ø¯ Ø§Ù„Ù‚Ø¶Ø§Ø¡ ÙˆØ¨Ø±Ø¯ Ø§Ù„Ø¹ÙŠØ´ Ø¨Ø¹Ø¯ Ø§Ù„Ù…ÙˆØª",
    "Ø§Ù„Ù„Ù‡Ù… Ø²ÙŠÙ†Ø§ Ø¨Ø²ÙŠÙ†Ø© Ø§Ù„Ø§ÙŠÙ…Ø§Ù† ÙˆØ§Ø¬Ø¹Ù„Ù†Ø§ Ù‡Ø¯Ø§Ø© Ù…Ù‡ØªØ¯ÙŠÙ†",
    "Ø±Ø¨ Ø§ÙˆØ²Ø¹Ù†ÙŠ Ø§Ù† Ø§Ø´ÙƒØ± Ù†Ø¹Ù…ØªÙƒ Ø§Ù„ØªÙŠ Ø§Ù†Ø¹Ù…Øª Ø¹Ù„ÙŠ ÙˆØ¹Ù„Ù‰ ÙˆØ§Ù„Ø¯ÙŠ",
    "Ø§Ù‚Ø±Ø£ Ø§Ù„Ù‚Ø±Ø§Ù† ÙˆØ§Ø±ØªÙ‚ ÙˆØ±ØªÙ„ ÙƒÙ…Ø§ ÙƒÙ†Øª ØªØ±ØªÙ„ ÙÙŠ Ø§Ù„Ø¯Ù†ÙŠØ§",
    "Ø§Ù† Ø§Ù„Ù„Ù‡ ÙˆÙ…Ù„Ø§Ø¦ÙƒØªÙ‡ ÙŠØµÙ„ÙˆÙ† Ø¹Ù„Ù‰ Ø§Ù„Ù†Ø¨ÙŠ ÙŠØ§ Ø§ÙŠÙ‡Ø§ Ø§Ù„Ø°ÙŠÙ† Ø§Ù…Ù†ÙˆØ§ ØµÙ„ÙˆØ§ Ø¹Ù„ÙŠÙ‡ ÙˆØ³Ù„Ù…ÙˆØ§ ØªØ³Ù„ÙŠÙ…Ø§",
    "ÙˆØ§Ø°ÙƒØ± Ø±Ø¨Ùƒ ÙÙŠ Ù†ÙØ³Ùƒ ØªØ¶Ø±Ø¹Ø§ ÙˆØ®ÙŠÙØ© ÙˆØ¯ÙˆÙ† Ø§Ù„Ø¬Ù‡Ø± Ù…Ù† Ø§Ù„Ù‚ÙˆÙ„ Ø¨Ø§Ù„ØºØ¯Ùˆ ÙˆØ§Ù„Ø§ØµØ§Ù„ ÙˆÙ„Ø§ ØªÙƒÙ† Ù…Ù† Ø§Ù„ØºØ§ÙÙ„ÙŠÙ†",
    "Ø§Ù„Ø°ÙŠÙ† Ø§Ù…Ù†ÙˆØ§ ÙˆØªØ·Ù…Ø¦Ù† Ù‚Ù„ÙˆØ¨Ù‡Ù… Ø¨Ø°ÙƒØ± Ø§Ù„Ù„Ù‡ Ø§Ù„Ø§ Ø¨Ø°ÙƒØ± Ø§Ù„Ù„Ù‡ ØªØ·Ù…Ø¦Ù† Ø§Ù„Ù‚Ù„ÙˆØ¨",
    "ÙØ§Ø°ÙƒØ±ÙˆÙ†ÙŠ Ø§Ø°ÙƒØ±ÙƒÙ… ÙˆØ§Ø´ÙƒØ±ÙˆØ§ Ù„ÙŠ ÙˆÙ„Ø§ ØªÙƒÙØ±ÙˆÙ†",
    "ÙŠØ§ Ø§ÙŠÙ‡Ø§ Ø§Ù„Ø°ÙŠÙ† Ø§Ù…Ù†ÙˆØ§ Ø§Ø°ÙƒØ±ÙˆØ§ Ø§Ù„Ù„Ù‡ Ø°ÙƒØ±Ø§ ÙƒØ«ÙŠØ±Ø§ ÙˆØ³Ø¨Ø­ÙˆÙ‡ Ø¨ÙƒØ±Ø© ÙˆØ§ØµÙŠÙ„Ø§",
    "ÙˆØ§Ø°ÙƒØ± Ø±Ø¨Ùƒ ÙƒØ«ÙŠØ±Ø§ ÙˆØ³Ø¨Ø­ Ø¨Ø§Ù„Ø¹Ø´ÙŠ ÙˆØ§Ù„Ø§Ø¨ÙƒØ§Ø±",
    "Ø§Ù† ÙÙŠ Ø®Ù„Ù‚ Ø§Ù„Ø³Ù…Ø§ÙˆØ§Øª ÙˆØ§Ù„Ø§Ø±Ø¶ ÙˆØ§Ø®ØªÙ„Ø§Ù Ø§Ù„Ù„ÙŠÙ„ ÙˆØ§Ù„Ù†Ù‡Ø§Ø± Ù„Ø§ÙŠØ§Øª Ù„Ø§ÙˆÙ„ÙŠ Ø§Ù„Ø§Ù„Ø¨Ø§Ø¨",
    "Ø§Ù„Ø°ÙŠÙ† ÙŠØ°ÙƒØ±ÙˆÙ† Ø§Ù„Ù„Ù‡ Ù‚ÙŠØ§Ù…Ø§ ÙˆÙ‚Ø¹ÙˆØ¯Ø§ ÙˆØ¹Ù„Ù‰ Ø¬Ù†ÙˆØ¨Ù‡Ù… ÙˆÙŠØªÙÙƒØ±ÙˆÙ† ÙÙŠ Ø®Ù„Ù‚ Ø§Ù„Ø³Ù…Ø§ÙˆØ§Øª ÙˆØ§Ù„Ø§Ø±Ø¶",
    "Ø±Ø¨Ù†Ø§ Ù…Ø§ Ø®Ù„Ù‚Øª Ù‡Ø°Ø§ Ø¨Ø§Ø·Ù„Ø§ Ø³Ø¨Ø­Ø§Ù†Ùƒ ÙÙ‚Ù†Ø§ Ø¹Ø°Ø§Ø¨ Ø§Ù„Ù†Ø§Ø±",
    "ÙˆØ§Ù„Ø°Ø§ÙƒØ±ÙŠÙ† Ø§Ù„Ù„Ù‡ ÙƒØ«ÙŠØ±Ø§ ÙˆØ§Ù„Ø°Ø§ÙƒØ±Ø§Øª Ø§Ø¹Ø¯ Ø§Ù„Ù„Ù‡ Ù„Ù‡Ù… Ù…ØºÙØ±Ø© ÙˆØ§Ø¬Ø±Ø§ Ø¹Ø¸ÙŠÙ…Ø§",
    "ÙˆØ§ØµØ¨Ø± Ù†ÙØ³Ùƒ Ù…Ø¹ Ø§Ù„Ø°ÙŠÙ† ÙŠØ¯Ø¹ÙˆÙ† Ø±Ø¨Ù‡Ù… Ø¨Ø§Ù„ØºØ¯Ø§Ø© ÙˆØ§Ù„Ø¹Ø´ÙŠ ÙŠØ±ÙŠØ¯ÙˆÙ† ÙˆØ¬Ù‡Ù‡",
    "ÙˆÙ„Ø§ ØªØ·Ø±Ø¯ Ø§Ù„Ø°ÙŠÙ† ÙŠØ¯Ø¹ÙˆÙ† Ø±Ø¨Ù‡Ù… Ø¨Ø§Ù„ØºØ¯Ø§Ø© ÙˆØ§Ù„Ø¹Ø´ÙŠ ÙŠØ±ÙŠØ¯ÙˆÙ† ÙˆØ¬Ù‡Ù‡",
    "Ø§Ù„Ù„Ù‡Ù… Ø±Ø¨ Ø§Ù„Ø³Ù…Ø§ÙˆØ§Øª ÙˆØ±Ø¨ Ø§Ù„Ø§Ø±Ø¶ ÙˆØ±Ø¨ Ø§Ù„Ø¹Ø±Ø´ Ø§Ù„Ø¹Ø¸ÙŠÙ… Ø±Ø¨Ù†Ø§ ÙˆØ±Ø¨ ÙƒÙ„ Ø´ÙŠØ¡",
    "ÙØ§Ù„Ù‚ Ø§Ù„Ø­Ø¨ ÙˆØ§Ù„Ù†ÙˆÙ‰ Ù…Ù†Ø²Ù„ Ø§Ù„ØªÙˆØ±Ø§Ø© ÙˆØ§Ù„Ø§Ù†Ø¬ÙŠÙ„ ÙˆØ§Ù„ÙØ±Ù‚Ø§Ù† Ø§Ø¹ÙˆØ° Ø¨Ùƒ Ù…Ù† Ø´Ø± ÙƒÙ„ Ø´ÙŠØ¡ Ø§Ù†Øª Ø§Ø®Ø° Ø¨Ù†Ø§ØµÙŠØªÙ‡",
    "Ø§Ù„Ù„Ù‡Ù… Ø§Ù†Øª Ø§Ù„Ø§ÙˆÙ„ ÙÙ„ÙŠØ³ Ù‚Ø¨Ù„Ùƒ Ø´ÙŠØ¡ ÙˆØ§Ù†Øª Ø§Ù„Ø§Ø®Ø± ÙÙ„ÙŠØ³ Ø¨Ø¹Ø¯Ùƒ Ø´ÙŠØ¡",
    "ÙˆØ§Ù†Øª Ø§Ù„Ø¸Ø§Ù‡Ø± ÙÙ„ÙŠØ³ ÙÙˆÙ‚Ùƒ Ø´ÙŠØ¡ ÙˆØ§Ù†Øª Ø§Ù„Ø¨Ø§Ø·Ù† ÙÙ„ÙŠØ³ Ø¯ÙˆÙ†Ùƒ Ø´ÙŠØ¡",
    "Ø§Ù‚Ø¶ Ø¹Ù†Ø§ Ø§Ù„Ø¯ÙŠÙ† ÙˆØ§ØºÙ†Ù†Ø§ Ù…Ù† Ø§Ù„ÙÙ‚Ø±",
    "Ø§Ù„Ù„Ù‡Ù… Ù‚Ù†ÙŠ Ø¹Ø°Ø§Ø¨Ùƒ ÙŠÙˆÙ… ØªØ¨Ø¹Ø« Ø¹Ø¨Ø§Ø¯Ùƒ",
    "Ø¨Ø§Ø³Ù…Ùƒ Ø§Ù„Ù„Ù‡Ù… Ø§Ù…ÙˆØª ÙˆØ§Ø­ÙŠØ§",
    "Ø§Ù„Ø­Ù…Ø¯ Ù„Ù„Ù‡ Ø§Ù„Ø°ÙŠ Ø§Ø­ÙŠØ§Ù†Ø§ Ø¨Ø¹Ø¯ Ù…Ø§ Ø§Ù…Ø§ØªÙ†Ø§ ÙˆØ§Ù„ÙŠÙ‡ Ø§Ù„Ù†Ø´ÙˆØ±",
    "Ø§Ù„Ø­Ù…Ø¯ Ù„Ù„Ù‡ Ø§Ù„Ø°ÙŠ Ø§Ø·Ø¹Ù…Ù†Ø§ ÙˆØ³Ù‚Ø§Ù†Ø§ ÙˆÙƒÙØ§Ù†Ø§ ÙˆØ§ÙˆØ§Ù†Ø§",
    "ÙÙƒÙ… Ù…Ù…Ù† Ù„Ø§ ÙƒØ§ÙÙŠ Ù„Ù‡ ÙˆÙ„Ø§ Ù…Ø£ÙˆÙŠ",
    "Ø§Ù„Ù„Ù‡Ù… Ø¹Ø§Ù„Ù… Ø§Ù„ØºÙŠØ¨ ÙˆØ§Ù„Ø´Ù‡Ø§Ø¯Ø© ÙØ§Ø·Ø± Ø§Ù„Ø³Ù…Ø§ÙˆØ§Øª ÙˆØ§Ù„Ø§Ø±Ø¶",
    "Ø±Ø¨ ÙƒÙ„ Ø´ÙŠØ¡ ÙˆÙ…Ù„ÙŠÙƒÙ‡ Ø§Ø´Ù‡Ø¯ Ø§Ù† Ù„Ø§ Ø§Ù„Ù‡ Ø§Ù„Ø§ Ø§Ù†Øª",
    "Ø§Ø¹ÙˆØ° Ø¨Ùƒ Ù…Ù† Ø´Ø± Ù†ÙØ³ÙŠ ÙˆÙ…Ù† Ø´Ø± Ø§Ù„Ø´ÙŠØ·Ø§Ù† ÙˆØ´Ø±ÙƒÙ‡",
    "Ø¨Ø³Ù… Ø§Ù„Ù„Ù‡ Ø§Ù„Ø°ÙŠ Ù„Ø§ ÙŠØ¶Ø± Ù…Ø¹ Ø§Ø³Ù…Ù‡ Ø´ÙŠØ¡ ÙÙŠ Ø§Ù„Ø§Ø±Ø¶ ÙˆÙ„Ø§ ÙÙŠ Ø§Ù„Ø³Ù…Ø§Ø¡ ÙˆÙ‡Ùˆ Ø§Ù„Ø³Ù…ÙŠØ¹ Ø§Ù„Ø¹Ù„ÙŠÙ…",
    "Ø§Ù„Ù„Ù‡Ù… Ø§Ù†Ø§ Ù†Ø³Ø§Ù„Ùƒ Ø§Ù„Ø¹Ø§ÙÙŠØ© ÙÙŠ Ø§Ù„Ø¯Ù†ÙŠØ§ ÙˆØ§Ù„Ø§Ø®Ø±Ø©",
    "Ø§Ù„Ù„Ù‡Ù… Ø§Ù†Ø§ Ù†Ø³Ø§Ù„Ùƒ Ø§Ù„Ø¹ÙÙˆ ÙˆØ§Ù„Ø¹Ø§ÙÙŠØ© ÙÙŠ Ø¯ÙŠÙ†Ù†Ø§ ÙˆØ¯Ù†ÙŠØ§Ù†Ø§ ÙˆØ§Ù‡Ù„Ù†Ø§ ÙˆÙ…Ø§Ù„Ù†Ø§",
    "Ø§Ù„Ù„Ù‡Ù… Ø§Ø³ØªØ± Ø¹ÙˆØ±Ø§ØªÙ†Ø§ ÙˆØ§Ù…Ù† Ø±ÙˆØ¹Ø§ØªÙ†Ø§",
    "Ø§Ù„Ù„Ù‡Ù… Ø§Ø­ÙØ¸Ù†Ø§ Ù…Ù† Ø¨ÙŠÙ† Ø§ÙŠØ¯ÙŠÙ†Ø§ ÙˆÙ…Ù† Ø®Ù„ÙÙ†Ø§ ÙˆØ¹Ù† Ø§ÙŠÙ…Ø§Ù†Ù†Ø§ ÙˆØ¹Ù† Ø´Ù…Ø§Ø¦Ù„Ù†Ø§ ÙˆÙ…Ù† ÙÙˆÙ‚Ù†Ø§",
    "ÙˆÙ†Ø¹ÙˆØ° Ø¨Ø¹Ø¸Ù…ØªÙƒ Ø§Ù† Ù†ØºØªØ§Ù„ Ù…Ù† ØªØ­ØªÙ†Ø§",
    "Ø§Ù„Ù„Ù‡Ù… Ø§Ù†Øª Ø±Ø¨ÙŠ Ù„Ø§ Ø§Ù„Ù‡ Ø§Ù„Ø§ Ø§Ù†Øª Ø®Ù„Ù‚ØªÙ†ÙŠ ÙˆØ§Ù†Ø§ Ø¹Ø¨Ø¯Ùƒ",
    "ÙˆØ§Ù†Ø§ Ø¹Ù„Ù‰ Ø¹Ù‡Ø¯Ùƒ ÙˆÙˆØ¹Ø¯Ùƒ Ù…Ø§ Ø§Ø³ØªØ·Ø¹Øª Ø§Ø¹ÙˆØ° Ø¨Ùƒ Ù…Ù† Ø´Ø± Ù…Ø§ ØµÙ†Ø¹Øª",
    "Ø§Ø¨ÙˆØ¡ Ù„Ùƒ Ø¨Ù†Ø¹Ù…ØªÙƒ Ø¹Ù„ÙŠ ÙˆØ§Ø¨ÙˆØ¡ Ø¨Ø°Ù†Ø¨ÙŠ ÙØ§ØºÙØ± Ù„ÙŠ ÙØ§Ù†Ù‡ Ù„Ø§ ÙŠØºÙØ± Ø§Ù„Ø°Ù†ÙˆØ¨ Ø§Ù„Ø§ Ø§Ù†Øª",
    "Ø±Ø¶ÙŠØª Ø¨Ø§Ù„Ù„Ù‡ Ø±Ø¨Ø§ ÙˆØ¨Ø§Ù„Ø§Ø³Ù„Ø§Ù… Ø¯ÙŠÙ†Ø§ ÙˆØ¨Ù…Ø­Ù…Ø¯ ØµÙ„Ù‰ Ø§Ù„Ù„Ù‡ Ø¹Ù„ÙŠÙ‡ ÙˆØ³Ù„Ù… Ù†Ø¨ÙŠØ§",
    "Ø§Ù„Ù„Ù‡Ù… Ø§Ù†ÙŠ Ø§ØµØ¨Ø­Øª Ø§Ø´Ù‡Ø¯Ùƒ ÙˆØ§Ø´Ù‡Ø¯ Ø­Ù…Ù„Ø© Ø¹Ø±Ø´Ùƒ ÙˆÙ…Ù„Ø§Ø¦ÙƒØªÙƒ ÙˆØ¬Ù…ÙŠØ¹ Ø®Ù„Ù‚Ùƒ",
    "Ø§Ù†Ùƒ Ø§Ù†Øª Ø§Ù„Ù„Ù‡ Ù„Ø§ Ø§Ù„Ù‡ Ø§Ù„Ø§ Ø§Ù†Øª ÙˆØ­Ø¯Ùƒ Ù„Ø§ Ø´Ø±ÙŠÙƒ Ù„Ùƒ ÙˆØ§Ù† Ù…Ø­Ù…Ø¯Ø§ Ø¹Ø¨Ø¯Ùƒ ÙˆØ±Ø³ÙˆÙ„Ùƒ",
    "ÙŠØ§ Ø±Ø¨ Ù„Ùƒ Ø§Ù„Ø­Ù…Ø¯ ÙƒÙ…Ø§ ÙŠÙ†Ø¨ØºÙŠ Ù„Ø¬Ù„Ø§Ù„ ÙˆØ¬Ù‡Ùƒ ÙˆÙ„Ø¹Ø¸ÙŠÙ… Ø³Ù„Ø·Ø§Ù†Ùƒ",
    "Ø§Ù„Ù„Ù‡Ù… Ù…Ø§ Ø§ØµØ¨Ø­ Ø¨ÙŠ Ù…Ù† Ù†Ø¹Ù…Ø© Ø§Ùˆ Ø¨Ø§Ø­Ø¯ Ù…Ù† Ø®Ù„Ù‚Ùƒ ÙÙ…Ù†Ùƒ ÙˆØ­Ø¯Ùƒ Ù„Ø§ Ø´Ø±ÙŠÙƒ Ù„Ùƒ",
    "ÙÙ„Ùƒ Ø§Ù„Ø­Ù…Ø¯ ÙˆÙ„Ùƒ Ø§Ù„Ø´ÙƒØ±"
]

QUIZ_QUESTIONS = [
    {"category": "Ø±ÙŠØ§Ø¶Ø©", "question": "Ù…Ù† Ù‡Ùˆ Ù‡Ø¯Ø§Ù ÙƒØ£Ø³ Ø§Ù„Ø¹Ø§Ù„Ù… 2022ØŸ", "options": ["Ù…ÙŠØ³ÙŠ", "Ù…Ø¨Ø§Ø¨ÙŠ", "Ø±ÙˆÙ†Ø§Ù„Ø¯Ùˆ", "Ù†ÙŠÙ…Ø§Ø±"], "answer": 1},
    {"category": "Ø±ÙŠØ§Ø¶Ø©", "question": "ÙƒÙ… Ø¹Ø¯Ø¯ Ù„Ø§Ø¹Ø¨ÙŠ ÙØ±ÙŠÙ‚ ÙƒØ±Ø© Ø§Ù„Ù‚Ø¯Ù…ØŸ", "options": ["9", "10", "11", "12"], "answer": 2},
    {"category": "Ø±ÙŠØ§Ø¶Ø©", "question": "ÙÙŠ Ø£ÙŠ Ø¯ÙˆÙ„Ø© Ø£Ù‚ÙŠÙ…Øª ÙƒØ£Ø³ Ø§Ù„Ø¹Ø§Ù„Ù… 2022ØŸ", "options": ["Ø§Ù„Ø³Ø¹ÙˆØ¯ÙŠØ©", "Ø§Ù„Ø¥Ù…Ø§Ø±Ø§Øª", "Ù‚Ø·Ø±", "Ø§Ù„Ø¨Ø­Ø±ÙŠÙ†"], "answer": 2},
    {"category": "Ø±ÙŠØ§Ø¶Ø©", "question": "ÙƒÙ… Ù…Ø±Ø© ÙØ§Ø² Ù…Ù†ØªØ®Ø¨ Ø§Ù„Ø¨Ø±Ø§Ø²ÙŠÙ„ Ø¨ÙƒØ£Ø³ Ø§Ù„Ø¹Ø§Ù„Ù…ØŸ", "options": ["3", "4", "5", "6"], "answer": 2},
    {"category": "Ø±ÙŠØ§Ø¶Ø©", "question": "Ù…Ù† Ù‡Ùˆ Ø£ÙØ¶Ù„ Ù„Ø§Ø¹Ø¨ ÙÙŠ Ø§Ù„Ø¹Ø§Ù„Ù… 2023ØŸ", "options": ["Ø±ÙˆÙ†Ø§Ù„Ø¯Ùˆ", "Ù…Ø¨Ø§Ø¨ÙŠ", "Ù‡Ø§Ù„Ø§Ù†Ø¯", "Ù…ÙŠØ³ÙŠ"], "answer": 3},
    {"category": "Ø±ÙŠØ§Ø¶Ø©", "question": "Ù…Ø§ Ù‡ÙŠ Ø§Ù„Ø±ÙŠØ§Ø¶Ø© Ø§Ù„ØªÙŠ ÙŠÙ„Ø¹Ø¨Ù‡Ø§ Ù„ÙŠØ¨Ø±ÙˆÙ† Ø¬ÙŠÙ…Ø³ØŸ", "options": ["ÙƒØ±Ø© Ø§Ù„Ù‚Ø¯Ù…", "Ø§Ù„ØªÙ†Ø³", "ÙƒØ±Ø© Ø§Ù„Ø³Ù„Ø©", "Ø§Ù„Ø¬ÙˆÙ„Ù"], "answer": 2},
    {"category": "Ø±ÙŠØ§Ø¶Ø©", "question": "ÙƒÙ… Ø´ÙˆØ· ÙÙŠ Ù…Ø¨Ø§Ø±Ø§Ø© ÙƒØ±Ø© Ø§Ù„Ø³Ù„Ø©ØŸ", "options": ["2", "3", "4", "5"], "answer": 2},
    {"category": "Ø±ÙŠØ§Ø¶Ø©", "question": "Ù…Ø§ Ù„ÙˆÙ† Ø§Ù„Ø¨Ø·Ø§Ù‚Ø© Ø§Ù„ØªÙŠ ØªØ¹Ù†ÙŠ Ø§Ù„Ø·Ø±Ø¯ ÙÙŠ ÙƒØ±Ø© Ø§Ù„Ù‚Ø¯Ù…ØŸ", "options": ["ØµÙØ±Ø§Ø¡", "Ø®Ø¶Ø±Ø§Ø¡", "Ø­Ù…Ø±Ø§Ø¡", "Ø²Ø±Ù‚Ø§Ø¡"], "answer": 2},
    {"category": "Ø±ÙŠØ§Ø¶Ø©", "question": "ÙƒÙ… ØªØ³ØªÙ…Ø± Ù…Ø¨Ø§Ø±Ø§Ø© ÙƒØ±Ø© Ø§Ù„Ù‚Ø¯Ù…ØŸ", "options": ["60 Ø¯Ù‚ÙŠÙ‚Ø©", "70 Ø¯Ù‚ÙŠÙ‚Ø©", "80 Ø¯Ù‚ÙŠÙ‚Ø©", "90 Ø¯Ù‚ÙŠÙ‚Ø©"], "answer": 3},
    {"category": "Ø±ÙŠØ§Ø¶Ø©", "question": "Ù…Ù† Ù‡Ùˆ Ø£ÙƒØ«Ø± Ù„Ø§Ø¹Ø¨ Ø³Ø¬Ù„ Ø£Ù‡Ø¯Ø§Ù ÙÙŠ ØªØ§Ø±ÙŠØ® ÙƒØ±Ø© Ø§Ù„Ù‚Ø¯Ù…ØŸ", "options": ["Ù…ÙŠØ³ÙŠ", "Ø±ÙˆÙ†Ø§Ù„Ø¯Ùˆ", "Ø¨ÙŠÙ„ÙŠÙ‡", "Ù…Ø§Ø±Ø§Ø¯ÙˆÙ†Ø§"], "answer": 1},
    
    {"category": "ØªØ§Ø±ÙŠØ®", "question": "Ù…ØªÙ‰ ÙØªØ­Øª Ø§Ù„Ù‚Ø³Ø·Ù†Ø·ÙŠÙ†ÙŠØ©ØŸ", "options": ["1453Ù…", "1492Ù…", "1517Ù…", "1258Ù…"], "answer": 0},
    {"category": "ØªØ§Ø±ÙŠØ®", "question": "Ù…Ù† Ù‡Ùˆ Ù…Ø¤Ø³Ø³ Ø§Ù„Ø¯ÙˆÙ„Ø© Ø§Ù„Ø£Ù…ÙˆÙŠØ©ØŸ", "options": ["Ø¹Ù…Ø± Ø¨Ù† Ø§Ù„Ø®Ø·Ø§Ø¨", "Ù…Ø¹Ø§ÙˆÙŠØ© Ø¨Ù† Ø£Ø¨ÙŠ Ø³ÙÙŠØ§Ù†", "Ø£Ø¨Ùˆ Ø¨ÙƒØ± Ø§Ù„ØµØ¯ÙŠÙ‚", "Ø¹Ù„ÙŠ Ø¨Ù† Ø£Ø¨ÙŠ Ø·Ø§Ù„Ø¨"], "answer": 1},
    {"category": "ØªØ§Ø±ÙŠØ®", "question": "Ù…ØªÙ‰ ÙˆÙ‚Ø¹Øª ØºØ²ÙˆØ© Ø¨Ø¯Ø±ØŸ", "options": ["Ø§Ù„Ø³Ù†Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰ Ù„Ù„Ù‡Ø¬Ø±Ø©", "Ø§Ù„Ø³Ù†Ø© Ø§Ù„Ø«Ø§Ù†ÙŠØ© Ù„Ù„Ù‡Ø¬Ø±Ø©", "Ø§Ù„Ø³Ù†Ø© Ø§Ù„Ø«Ø§Ù„Ø«Ø© Ù„Ù„Ù‡Ø¬Ø±Ø©", "Ø§Ù„Ø³Ù†Ø© Ø§Ù„Ø±Ø§Ø¨Ø¹Ø© Ù„Ù„Ù‡Ø¬Ø±Ø©"], "answer": 1},
    {"category": "ØªØ§Ø±ÙŠØ®", "question": "Ù…Ù† ÙØªØ­ Ø§Ù„Ø£Ù†Ø¯Ù„Ø³ØŸ", "options": ["ØµÙ„Ø§Ø­ Ø§Ù„Ø¯ÙŠÙ†", "Ø·Ø§Ø±Ù‚ Ø¨Ù† Ø²ÙŠØ§Ø¯", "Ø®Ø§Ù„Ø¯ Ø¨Ù† Ø§Ù„ÙˆÙ„ÙŠØ¯", "Ø¹Ù‚Ø¨Ø© Ø¨Ù† Ù†Ø§ÙØ¹"], "answer": 1},
    {"category": "ØªØ§Ø±ÙŠØ®", "question": "Ù…ØªÙ‰ Ø³Ù‚Ø·Øª Ø§Ù„Ø®Ù„Ø§ÙØ© Ø§Ù„Ø¹Ø«Ù…Ø§Ù†ÙŠØ©ØŸ", "options": ["1918Ù…", "1922Ù…", "1924Ù…", "1930Ù…"], "answer": 2},
    {"category": "ØªØ§Ø±ÙŠØ®", "question": "Ù…Ù† Ø¨Ù†Ù‰ Ø§Ù„Ø£Ù‡Ø±Ø§Ù…Ø§ØªØŸ", "options": ["Ø§Ù„ÙØ±Ø§Ø¹Ù†Ø©", "Ø§Ù„Ø±ÙˆÙ…Ø§Ù†", "Ø§Ù„ÙØ±Ø³", "Ø§Ù„ÙŠÙˆÙ†Ø§Ù†"], "answer": 0},
    {"category": "ØªØ§Ø±ÙŠØ®", "question": "Ù…ØªÙ‰ Ø§ÙƒØªØ´Ù ÙƒØ±ÙŠØ³ØªÙˆÙØ± ÙƒÙˆÙ„ÙˆÙ…Ø¨ÙˆØ³ Ø£Ù…Ø±ÙŠÙƒØ§ØŸ", "options": ["1453Ù…", "1492Ù…", "1500Ù…", "1520Ù…"], "answer": 1},
    {"category": "ØªØ§Ø±ÙŠØ®", "question": "Ù…Ù† Ù‡Ùˆ Ø£ÙˆÙ„ Ø®Ù„ÙŠÙØ© Ù„Ù„Ù…Ø³Ù„Ù…ÙŠÙ†ØŸ", "options": ["Ø¹Ù…Ø± Ø¨Ù† Ø§Ù„Ø®Ø·Ø§Ø¨", "Ø¹Ø«Ù…Ø§Ù† Ø¨Ù† Ø¹ÙØ§Ù†", "Ø£Ø¨Ùˆ Ø¨ÙƒØ± Ø§Ù„ØµØ¯ÙŠÙ‚", "Ø¹Ù„ÙŠ Ø¨Ù† Ø£Ø¨ÙŠ Ø·Ø§Ù„Ø¨"], "answer": 2},
    {"category": "ØªØ§Ø±ÙŠØ®", "question": "Ù…ØªÙ‰ Ø¨Ø¯Ø£Øª Ø§Ù„Ø­Ø±Ø¨ Ø§Ù„Ø¹Ø§Ù„Ù…ÙŠØ© Ø§Ù„Ø«Ø§Ù†ÙŠØ©ØŸ", "options": ["1935Ù…", "1937Ù…", "1939Ù…", "1941Ù…"], "answer": 2},
    {"category": "ØªØ§Ø±ÙŠØ®", "question": "Ù…Ù† Ù‡Ùˆ Ù‚Ø§Ø¦Ø¯ Ù…Ø¹Ø±ÙƒØ© Ø­Ø·ÙŠÙ†ØŸ", "options": ["Ø®Ø§Ù„Ø¯ Ø¨Ù† Ø§Ù„ÙˆÙ„ÙŠØ¯", "ØµÙ„Ø§Ø­ Ø§Ù„Ø¯ÙŠÙ† Ø§Ù„Ø£ÙŠÙˆØ¨ÙŠ", "Ø¹Ù…Ø±Ùˆ Ø¨Ù† Ø§Ù„Ø¹Ø§Øµ", "Ø³Ø¹Ø¯ Ø¨Ù† Ø£Ø¨ÙŠ ÙˆÙ‚Ø§Øµ"], "answer": 1},
    
    {"category": "Ø¬ØºØ±Ø§ÙÙŠØ§", "question": "Ù…Ø§ Ù‡ÙŠ Ø¹Ø§ØµÙ…Ø© ÙØ±Ù†Ø³Ø§ØŸ", "options": ["Ù„Ù†Ø¯Ù†", "Ø¨Ø±Ù„ÙŠÙ†", "Ø¨Ø§Ø±ÙŠØ³", "Ø±ÙˆÙ…Ø§"], "answer": 2},
    {"category": "Ø¬ØºØ±Ø§ÙÙŠØ§", "question": "Ù…Ø§ Ù‡Ùˆ Ø£Ø·ÙˆÙ„ Ù†Ù‡Ø± ÙÙŠ Ø§Ù„Ø¹Ø§Ù„Ù…ØŸ", "options": ["Ø§Ù„Ù†ÙŠÙ„", "Ø§Ù„Ø£Ù…Ø§Ø²ÙˆÙ†", "Ø§Ù„Ù…Ø³ÙŠØ³ÙŠØ¨ÙŠ", "Ø§Ù„Ø¯Ø§Ù†ÙˆØ¨"], "answer": 0},
    {"category": "Ø¬ØºØ±Ø§ÙÙŠØ§", "question": "Ù…Ø§ Ù‡ÙŠ Ø£ÙƒØ¨Ø± Ø¯ÙˆÙ„Ø© ÙÙŠ Ø§Ù„Ø¹Ø§Ù„Ù… Ù…Ø³Ø§Ø­Ø©ØŸ", "options": ["Ø§Ù„ØµÙŠÙ†", "Ø£Ù…Ø±ÙŠÙƒØ§", "ÙƒÙ†Ø¯Ø§", "Ø±ÙˆØ³ÙŠØ§"], "answer": 3},
    {"category": "Ø¬ØºØ±Ø§ÙÙŠØ§", "question": "ÙÙŠ Ø£ÙŠ Ù‚Ø§Ø±Ø© ØªÙ‚Ø¹ Ù…ØµØ±ØŸ", "options": ["Ø¢Ø³ÙŠØ§", "Ø£ÙØ±ÙŠÙ‚ÙŠØ§", "Ø£ÙˆØ±ÙˆØ¨Ø§", "Ø£Ù…Ø±ÙŠÙƒØ§"], "answer": 1},
    {"category": "Ø¬ØºØ±Ø§ÙÙŠØ§", "question": "Ù…Ø§ Ù‡ÙŠ Ø¹Ø§ØµÙ…Ø© Ø§Ù„ÙŠØ§Ø¨Ø§Ù†ØŸ", "options": ["Ø¨ÙƒÙŠÙ†", "Ø³ÙŠÙˆÙ„", "Ø·ÙˆÙƒÙŠÙˆ", "Ø¨Ø§Ù†ÙƒÙˆÙƒ"], "answer": 2},
    {"category": "Ø¬ØºØ±Ø§ÙÙŠØ§", "question": "ÙƒÙ… Ø¹Ø¯Ø¯ Ù‚Ø§Ø±Ø§Øª Ø§Ù„Ø¹Ø§Ù„Ù…ØŸ", "options": ["5", "6", "7", "8"], "answer": 2},
    {"category": "Ø¬ØºØ±Ø§ÙÙŠØ§", "question": "Ù…Ø§ Ù‡Ùˆ Ø£ÙƒØ¨Ø± Ù…Ø­ÙŠØ· ÙÙŠ Ø§Ù„Ø¹Ø§Ù„Ù…ØŸ", "options": ["Ø§Ù„Ø£Ø·Ù„Ø³ÙŠ", "Ø§Ù„Ù‡Ù†Ø¯ÙŠ", "Ø§Ù„Ù‡Ø§Ø¯Ø¦", "Ø§Ù„Ù…ØªØ¬Ù…Ø¯"], "answer": 2},
    {"category": "Ø¬ØºØ±Ø§ÙÙŠØ§", "question": "Ù…Ø§ Ù‡ÙŠ Ø¹Ø§ØµÙ…Ø© Ø§Ù„Ø³Ø¹ÙˆØ¯ÙŠØ©ØŸ", "options": ["Ø¬Ø¯Ø©", "Ù…ÙƒØ©", "Ø§Ù„Ø±ÙŠØ§Ø¶", "Ø§Ù„Ø¯Ù…Ø§Ù…"], "answer": 2},
    {"category": "Ø¬ØºØ±Ø§ÙÙŠØ§", "question": "Ø£ÙŠÙ† ÙŠÙ‚Ø¹ Ø¨Ø±Ø¬ Ø¥ÙŠÙÙ„ØŸ", "options": ["Ù„Ù†Ø¯Ù†", "Ù†ÙŠÙˆÙŠÙˆØ±Ùƒ", "Ø¨Ø§Ø±ÙŠØ³", "Ø±ÙˆÙ…Ø§"], "answer": 2},
    {"category": "Ø¬ØºØ±Ø§ÙÙŠØ§", "question": "Ù…Ø§ Ù‡ÙŠ Ø£ØµØºØ± Ø¯ÙˆÙ„Ø© ÙÙŠ Ø§Ù„Ø¹Ø§Ù„Ù…ØŸ", "options": ["Ù…ÙˆÙ†Ø§ÙƒÙˆ", "Ø§Ù„ÙØ§ØªÙŠÙƒØ§Ù†", "Ø³Ø§Ù† Ù…Ø§Ø±ÙŠÙ†Ùˆ", "Ù…Ø§Ù„Ø·Ø§"], "answer": 1},
    
    {"category": "Ø¹Ù„ÙˆÙ…", "question": "Ù…Ø§ Ù‡Ùˆ Ø§Ù„Ø¹Ù†ØµØ± Ø§Ù„Ø£ÙƒØ«Ø± ÙˆÙØ±Ø© ÙÙŠ Ø§Ù„ØºÙ„Ø§Ù Ø§Ù„Ø¬ÙˆÙŠØŸ", "options": ["Ø§Ù„Ø£ÙƒØ³Ø¬ÙŠÙ†", "Ø§Ù„Ù†ÙŠØªØ±ÙˆØ¬ÙŠÙ†", "Ø§Ù„Ù‡ÙŠØ¯Ø±ÙˆØ¬ÙŠÙ†", "Ø§Ù„ÙƒØ±Ø¨ÙˆÙ†"], "answer": 1},
    {"category": "Ø¹Ù„ÙˆÙ…", "question": "ÙƒÙ… Ø¹Ø¯Ø¯ ÙƒÙˆØ§ÙƒØ¨ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© Ø§Ù„Ø´Ù…Ø³ÙŠØ©ØŸ", "options": ["7", "8", "9", "10"], "answer": 1},
    {"category": "Ø¹Ù„ÙˆÙ…", "question": "Ù…Ø§ Ù‡Ùˆ Ø£Ù‚Ø±Ø¨ ÙƒÙˆÙƒØ¨ Ù„Ù„Ø´Ù…Ø³ØŸ", "options": ["Ø§Ù„Ø²Ù‡Ø±Ø©", "Ø§Ù„Ø£Ø±Ø¶", "Ø¹Ø·Ø§Ø±Ø¯", "Ø§Ù„Ù…Ø±ÙŠØ®"], "answer": 2},
    {"category": "Ø¹Ù„ÙˆÙ…", "question": "Ù…Ø§ Ù‡ÙŠ ÙˆØ­Ø¯Ø© Ù‚ÙŠØ§Ø³ Ø§Ù„Ù‚ÙˆØ©ØŸ", "options": ["Ù…ØªØ±", "ÙƒÙŠÙ„ÙˆØºØ±Ø§Ù…", "Ù†ÙŠÙˆØªÙ†", "Ø¬ÙˆÙ„"], "answer": 2},
    {"category": "Ø¹Ù„ÙˆÙ…", "question": "Ù…Ø§ Ù‡Ùˆ Ø§Ù„ØºØ§Ø² Ø§Ù„Ø°ÙŠ ØªØªÙ†ÙØ³Ù‡ Ø§Ù„Ù†Ø¨Ø§ØªØ§ØªØŸ", "options": ["Ø§Ù„Ø£ÙƒØ³Ø¬ÙŠÙ†", "Ø§Ù„Ù†ÙŠØªØ±ÙˆØ¬ÙŠÙ†", "Ø«Ø§Ù†ÙŠ Ø£ÙƒØ³ÙŠØ¯ Ø§Ù„ÙƒØ±Ø¨ÙˆÙ†", "Ø§Ù„Ù‡ÙŠØ¯Ø±ÙˆØ¬ÙŠÙ†"], "answer": 2},
    {"category": "Ø¹Ù„ÙˆÙ…", "question": "ÙƒÙ… Ø¹Ø¸Ù…Ø© ÙÙŠ Ø¬Ø³Ù… Ø§Ù„Ø¥Ù†Ø³Ø§Ù† Ø§Ù„Ø¨Ø§Ù„ØºØŸ", "options": ["186", "206", "226", "246"], "answer": 1},
    {"category": "Ø¹Ù„ÙˆÙ…", "question": "Ù…Ø§ Ù‡Ùˆ Ø£ÙƒØ¨Ø± Ø¹Ø¶Ùˆ ÙÙŠ Ø¬Ø³Ù… Ø§Ù„Ø¥Ù†Ø³Ø§Ù†ØŸ", "options": ["Ø§Ù„Ù‚Ù„Ø¨", "Ø§Ù„ÙƒØ¨Ø¯", "Ø§Ù„Ø¬Ù„Ø¯", "Ø§Ù„Ù…Ø¹Ø¯Ø©"], "answer": 2},
    {"category": "Ø¹Ù„ÙˆÙ…", "question": "Ù…Ø§ Ù‡ÙŠ Ø³Ø±Ø¹Ø© Ø§Ù„Ø¶ÙˆØ¡ ØªÙ‚Ø±ÙŠØ¨Ø§Ù‹ØŸ", "options": ["100 Ø£Ù„Ù ÙƒÙ…/Ø«", "200 Ø£Ù„Ù ÙƒÙ…/Ø«", "300 Ø£Ù„Ù ÙƒÙ…/Ø«", "400 Ø£Ù„Ù ÙƒÙ…/Ø«"], "answer": 2},
    {"category": "Ø¹Ù„ÙˆÙ…", "question": "Ù…Ù† Ø§ÙƒØªØ´Ù Ø§Ù„Ø¬Ø§Ø°Ø¨ÙŠØ©ØŸ", "options": ["Ø£ÙŠÙ†Ø´ØªØ§ÙŠÙ†", "Ù†ÙŠÙˆØªÙ†", "ØºØ§Ù„ÙŠÙ„ÙŠÙˆ", "ÙƒÙˆØ¨Ø±Ù†ÙŠÙƒÙˆØ³"], "answer": 1},
    {"category": "Ø¹Ù„ÙˆÙ…", "question": "Ù…Ø§ Ù‡Ùˆ Ø§Ù„Ø­ÙŠÙˆØ§Ù† Ø§Ù„Ø£ÙƒØ¨Ø± Ø¹Ù„Ù‰ ÙˆØ¬Ù‡ Ø§Ù„Ø£Ø±Ø¶ØŸ", "options": ["Ø§Ù„ÙÙŠÙ„", "Ø§Ù„Ø²Ø±Ø§ÙØ©", "Ø§Ù„Ø­ÙˆØª Ø§Ù„Ø£Ø²Ø±Ù‚", "Ø§Ù„Ø¯ÙŠÙ†Ø§ØµÙˆØ±"], "answer": 2},
    
    {"category": "Ø¥Ø³Ù„Ø§Ù…ÙŠØ©", "question": "ÙƒÙ… Ø¹Ø¯Ø¯ Ø³ÙˆØ± Ø§Ù„Ù‚Ø±Ø¢Ù† Ø§Ù„ÙƒØ±ÙŠÙ…ØŸ", "options": ["112", "113", "114", "115"], "answer": 2},
    {"category": "Ø¥Ø³Ù„Ø§Ù…ÙŠØ©", "question": "Ù…Ø§ Ù‡ÙŠ Ø£Ø·ÙˆÙ„ Ø³ÙˆØ±Ø© ÙÙŠ Ø§Ù„Ù‚Ø±Ø¢Ù†ØŸ", "options": ["Ø¢Ù„ Ø¹Ù…Ø±Ø§Ù†", "Ø§Ù„Ù†Ø³Ø§Ø¡", "Ø§Ù„Ø¨Ù‚Ø±Ø©", "Ø§Ù„Ù…Ø§Ø¦Ø¯Ø©"], "answer": 2},
    {"category": "Ø¥Ø³Ù„Ø§Ù…ÙŠØ©", "question": "ÙƒÙ… Ø¹Ø¯Ø¯ Ø£Ø±ÙƒØ§Ù† Ø§Ù„Ø¥Ø³Ù„Ø§Ù…ØŸ", "options": ["4", "5", "6", "7"], "answer": 1},
    {"category": "Ø¥Ø³Ù„Ø§Ù…ÙŠØ©", "question": "Ù…Ø§ Ù‡Ùˆ Ø£ÙˆÙ„ Ø±ÙƒÙ† Ù…Ù† Ø£Ø±ÙƒØ§Ù† Ø§Ù„Ø¥Ø³Ù„Ø§Ù…ØŸ", "options": ["Ø§Ù„ØµÙ„Ø§Ø©", "Ø§Ù„Ø²ÙƒØ§Ø©", "Ø§Ù„Ø´Ù‡Ø§Ø¯ØªØ§Ù†", "Ø§Ù„ØµÙŠØ§Ù…"], "answer": 2},
    {"category": "Ø¥Ø³Ù„Ø§Ù…ÙŠØ©", "question": "ÙÙŠ Ø£ÙŠ Ø´Ù‡Ø± Ù†Ø²Ù„ Ø§Ù„Ù‚Ø±Ø¢Ù†ØŸ", "options": ["Ø´Ø¹Ø¨Ø§Ù†", "Ø±Ù…Ø¶Ø§Ù†", "Ø´ÙˆØ§Ù„", "Ù…Ø­Ø±Ù…"], "answer": 1},
    {"category": "Ø¥Ø³Ù„Ø§Ù…ÙŠØ©", "question": "ÙƒÙ… Ø¹Ø¯Ø¯ Ø§Ù„ØµÙ„ÙˆØ§Øª Ø§Ù„Ù…ÙØ±ÙˆØ¶Ø© ÙÙŠ Ø§Ù„ÙŠÙˆÙ…ØŸ", "options": ["3", "4", "5", "6"], "answer": 2},
    {"category": "Ø¥Ø³Ù„Ø§Ù…ÙŠØ©", "question": "Ù…Ù† Ù‡Ùˆ Ø®Ø§ØªÙ… Ø§Ù„Ø£Ù†Ø¨ÙŠØ§Ø¡ ÙˆØ§Ù„Ù…Ø±Ø³Ù„ÙŠÙ†ØŸ", "options": ["Ù…ÙˆØ³Ù‰", "Ø¹ÙŠØ³Ù‰", "Ø¥Ø¨Ø±Ø§Ù‡ÙŠÙ…", "Ù…Ø­Ù…Ø¯"], "answer": 3},
    {"category": "Ø¥Ø³Ù„Ø§Ù…ÙŠØ©", "question": "Ù…Ø§ Ù‡ÙŠ Ø£Ù‚ØµØ± Ø³ÙˆØ±Ø© ÙÙŠ Ø§Ù„Ù‚Ø±Ø¢Ù†ØŸ", "options": ["Ø§Ù„ÙØ§ØªØ­Ø©", "Ø§Ù„Ø¥Ø®Ù„Ø§Øµ", "Ø§Ù„ÙƒÙˆØ«Ø±", "Ø§Ù„Ù†Ø§Ø³"], "answer": 2},
    {"category": "Ø¥Ø³Ù„Ø§Ù…ÙŠØ©", "question": "Ø£ÙŠÙ† ÙˆÙ„Ø¯ Ø§Ù„Ù†Ø¨ÙŠ Ù…Ø­Ù…Ø¯ ØµÙ„Ù‰ Ø§Ù„Ù„Ù‡ Ø¹Ù„ÙŠÙ‡ ÙˆØ³Ù„Ù…ØŸ", "options": ["Ø§Ù„Ù…Ø¯ÙŠÙ†Ø©", "Ù…ÙƒØ©", "Ø§Ù„Ø·Ø§Ø¦Ù", "Ø¬Ø¯Ø©"], "answer": 1},
    {"category": "Ø¥Ø³Ù„Ø§Ù…ÙŠØ©", "question": "Ù…Ø§ Ù‡Ùˆ Ø§Ù„Ø±ÙƒÙ† Ø§Ù„Ø®Ø§Ù…Ø³ Ù…Ù† Ø£Ø±ÙƒØ§Ù† Ø§Ù„Ø¥Ø³Ù„Ø§Ù…ØŸ", "options": ["Ø§Ù„Ø²ÙƒØ§Ø©", "Ø§Ù„ØµÙŠØ§Ù…", "Ø§Ù„Ø­Ø¬", "Ø§Ù„ØµÙ„Ø§Ø©"], "answer": 2},
    
    {"category": "ØªØ±ÙÙŠÙ‡", "question": "Ù…Ø§ Ù‡Ùˆ Ø§Ø³Ù… ØµØ¯ÙŠÙ‚ Ø³Ø¨ÙˆÙ†Ø¬ Ø¨ÙˆØ¨ Ø§Ù„ÙˆØ±Ø¯ÙŠØŸ", "options": ["Ø³ÙƒÙˆÙŠØ¯ÙˆØ§Ø±Ø¯", "Ø³Ø§Ù†Ø¯ÙŠ", "Ø¨Ø§ØªØ±ÙŠÙƒ", "Ø§Ù„Ø³ÙŠØ¯ Ø³Ù„Ø·Ø¹"], "answer": 2},
    {"category": "ØªØ±ÙÙŠÙ‡", "question": "Ù…Ø§ Ù„ÙˆÙ† Ø´Ø®ØµÙŠØ© Ø¨ÙŠÙƒØ§ØªØ´ÙˆØŸ", "options": ["Ø£Ø­Ù…Ø±", "Ø£Ø²Ø±Ù‚", "Ø£ØµÙØ±", "Ø£Ø®Ø¶Ø±"], "answer": 2},
    {"category": "ØªØ±ÙÙŠÙ‡", "question": "Ù…Ù† Ù‡Ùˆ ØµØ§Ù†Ø¹ Ø´Ø®ØµÙŠØ© Ù…ÙŠÙƒÙŠ Ù…Ø§ÙˆØ³ØŸ", "options": ["Ø³ØªÙŠÙ Ø¬ÙˆØ¨Ø²", "ÙˆØ§Ù„Øª Ø¯ÙŠØ²Ù†ÙŠ", "Ø¨ÙŠÙ„ ØºÙŠØªØ³", "Ù…Ø§Ø±Ùƒ Ø²ÙˆÙƒØ±Ø¨ÙŠØ±Ø¬"], "answer": 1},
    {"category": "ØªØ±ÙÙŠÙ‡", "question": "Ù…Ø§ Ø§Ø³Ù… Ø§Ù„Ù‚Ø· ÙÙŠ ØªÙˆÙ… ÙˆØ¬ÙŠØ±ÙŠØŸ", "options": ["Ø¬ÙŠØ±ÙŠ", "ØªÙˆÙ…", "Ø³Ø¨Ø§ÙŠÙƒ", "ØªØ§ÙŠÙƒ"], "answer": 1},
    {"category": "ØªØ±ÙÙŠÙ‡", "question": "ÙƒÙ… Ø¹Ø¯Ø¯ Ø§Ù„ØªÙ†Ø§Ù†ÙŠÙ† ÙÙŠ ÙÙŠÙ„Ù… ÙƒÙŠÙ ØªØ±ÙˆØ¶ ØªÙ†ÙŠÙ†ÙƒØŸ", "options": ["1", "2", "ÙƒØ«ÙŠØ±", "Ù„Ø§ ÙŠÙˆØ¬Ø¯"], "answer": 2},
    {"category": "ØªØ±ÙÙŠÙ‡", "question": "Ù…Ø§ Ù‡Ùˆ Ø§Ø³Ù… Ø¨Ø·Ù„ ÙÙŠÙ„Ù… Ø§Ù„Ø±Ø¬Ù„ Ø§Ù„Ø¹Ù†ÙƒØ¨ÙˆØªØŸ", "options": ["Ø¨Ø±ÙˆØ³ ÙˆØ§ÙŠÙ†", "ÙƒÙ„Ø§Ø±Ùƒ ÙƒÙŠÙ†Øª", "Ø¨ÙŠØªØ± Ø¨Ø§Ø±ÙƒØ±", "ØªÙˆÙ†ÙŠ Ø³ØªØ§Ø±Ùƒ"], "answer": 2},
    {"category": "ØªØ±ÙÙŠÙ‡", "question": "Ù…Ù† ÙŠØ¤Ø¯ÙŠ ØµÙˆØª Ø´Ø±ÙŠÙƒ ÙÙŠ Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©ØŸ", "options": ["Ø£Ø­Ù…Ø¯ Ø­Ù„Ù…ÙŠ", "Ù…Ø­Ù…Ø¯ Ù‡Ù†ÙŠØ¯ÙŠ", "Ø£Ø­Ù…Ø¯ Ø§Ù„Ø³Ù‚Ø§", "ÙƒØ±ÙŠÙ… Ø¹Ø¨Ø¯Ø§Ù„Ø¹Ø²ÙŠØ²"], "answer": 0},
    {"category": "ØªØ±ÙÙŠÙ‡", "question": "Ù…Ø§ Ù‡ÙŠ Ù„Ø¹Ø¨Ø© Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø§Ù„Ø£ÙƒØ«Ø± Ù…Ø¨ÙŠØ¹Ø§Ù‹ ÙÙŠ Ø§Ù„ØªØ§Ø±ÙŠØ®ØŸ", "options": ["ÙÙˆØ±ØªÙ†Ø§ÙŠØª", "Ù…Ø§ÙŠÙ†ÙƒØ±Ø§ÙØª", "Ø¨ÙˆØ¨Ø¬ÙŠ", "ÙÙŠÙØ§"], "answer": 1},
    {"category": "ØªØ±ÙÙŠÙ‡", "question": "Ù…Ø§ Ø§Ø³Ù… Ø§Ù„Ø£Ù…ÙŠØ±Ø© ÙÙŠ ÙÙŠÙ„Ù… ÙØ±ÙˆØ²Ù†ØŸ", "options": ["Ø³Ù†Ø¯Ø±ÙŠÙ„Ø§", "Ø¥Ù„Ø³Ø§ ÙˆØ¢Ù†Ø§", "Ø±Ø¨Ø§Ù†Ø²Ù„", "Ø£Ø±ÙŠÙ„"], "answer": 1},
    {"category": "ØªØ±ÙÙŠÙ‡", "question": "Ù…Ø§ Ù„ÙˆÙ† Ø´Ø¹Ø± Ø§Ù„Ø£Ù…ÙŠØ±Ø© Ø£Ø±ÙŠÙ„ ÙÙŠ Ø§Ù„Ø­ÙˆØ±ÙŠØ© Ø§Ù„ØµØºÙŠØ±Ø©ØŸ", "options": ["Ø£Ø´Ù‚Ø±", "Ø£Ø³ÙˆØ¯", "Ø£Ø­Ù…Ø±", "Ø¨Ù†ÙŠ"], "answer": 2},
    
    {"category": "Ø¹Ø§Ù…Ø©", "question": "ÙƒÙ… ÙŠÙˆÙ…Ø§Ù‹ ÙÙŠ Ø§Ù„Ø³Ù†Ø© Ø§Ù„ÙƒØ¨ÙŠØ³Ø©ØŸ", "options": ["364", "365", "366", "367"], "answer": 2},
    {"category": "Ø¹Ø§Ù…Ø©", "question": "Ù…Ø§ Ù‡ÙŠ Ø§Ù„Ù„ØºØ© Ø§Ù„Ø£ÙƒØ«Ø± ØªØ­Ø¯Ø«Ø§Ù‹ ÙÙŠ Ø§Ù„Ø¹Ø§Ù„Ù…ØŸ", "options": ["Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©", "Ø§Ù„ØµÙŠÙ†ÙŠØ©", "Ø§Ù„Ø¥Ø³Ø¨Ø§Ù†ÙŠØ©", "Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"], "answer": 1},
    {"category": "Ø¹Ø§Ù…Ø©", "question": "ÙƒÙ… Ø³Ø§Ø¹Ø© ÙÙŠ Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ØŸ", "options": ["148", "158", "168", "178"], "answer": 2},
    {"category": "Ø¹Ø§Ù…Ø©", "question": "Ù…Ø§ Ù‡Ùˆ Ø£Ø³Ø±Ø¹ Ø­ÙŠÙˆØ§Ù† Ø¨Ø±ÙŠØŸ", "options": ["Ø§Ù„Ø£Ø³Ø¯", "Ø§Ù„ÙÙ‡Ø¯", "Ø§Ù„Ù†Ù…Ø±", "Ø§Ù„Ø°Ø¦Ø¨"], "answer": 1},
    {"category": "Ø¹Ø§Ù…Ø©", "question": "ÙƒÙ… Ø¹Ø¯Ø¯ Ø£Ù„ÙˆØ§Ù† Ù‚ÙˆØ³ Ù‚Ø²Ø­ØŸ", "options": ["5", "6", "7", "8"], "answer": 2},
    {"category": "Ø¹Ø§Ù…Ø©", "question": "Ù…Ø§ Ù‡Ùˆ Ø§Ù„Ø­ÙŠÙˆØ§Ù† Ø§Ù„Ø°ÙŠ ÙŠÙÙ„Ù‚Ø¨ Ø¨Ù…Ù„Ùƒ Ø§Ù„ØºØ§Ø¨Ø©ØŸ", "options": ["Ø§Ù„Ù†Ù…Ø±", "Ø§Ù„ÙÙŠÙ„", "Ø§Ù„Ø£Ø³Ø¯", "Ø§Ù„Ø¯Ø¨"], "answer": 2},
    {"category": "Ø¹Ø§Ù…Ø©", "question": "ÙƒÙ… Ø¹Ø¯Ø¯ Ø£ØµØ§Ø¨Ø¹ Ø§Ù„ÙŠØ¯ Ø§Ù„ÙˆØ§Ø­Ø¯Ø©ØŸ", "options": ["4", "5", "6", "7"], "answer": 1},
    {"category": "Ø¹Ø§Ù…Ø©", "question": "Ù…Ø§ Ù‡Ùˆ Ø§Ù„ÙƒÙˆÙƒØ¨ Ø§Ù„Ø£Ø­Ù…Ø±ØŸ", "options": ["Ø§Ù„Ø²Ù‡Ø±Ø©", "Ø§Ù„Ù…Ø±ÙŠØ®", "Ø§Ù„Ù…Ø´ØªØ±ÙŠ", "Ø²Ø­Ù„"], "answer": 1},
    {"category": "Ø¹Ø§Ù…Ø©", "question": "Ù…Ø§ Ù‡ÙŠ Ø§Ù„Ø¹Ù…Ù„Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…Ø© ÙÙŠ Ø£Ù…Ø±ÙŠÙƒØ§ØŸ", "options": ["Ø§Ù„ÙŠÙˆØ±Ùˆ", "Ø§Ù„Ø¬Ù†ÙŠÙ‡", "Ø§Ù„Ø¯ÙˆÙ„Ø§Ø±", "Ø§Ù„ÙŠÙ†"], "answer": 2},
    {"category": "Ø¹Ø§Ù…Ø©", "question": "ÙƒÙ… Ø´Ù‡Ø±Ø§Ù‹ ÙÙŠ Ø§Ù„Ø³Ù†Ø©ØŸ", "options": ["10", "11", "12", "13"], "answer": 2},
    
    {"category": "ØªÙ‚Ù†ÙŠØ©", "question": "Ù…Ù† Ù‡Ùˆ Ù…Ø¤Ø³Ø³ Ø´Ø±ÙƒØ© Ù…Ø§ÙŠÙƒØ±ÙˆØ³ÙˆÙØªØŸ", "options": ["Ø³ØªÙŠÙ Ø¬ÙˆØ¨Ø²", "Ø¨ÙŠÙ„ ØºÙŠØªØ³", "Ù…Ø§Ø±Ùƒ Ø²ÙˆÙƒØ±Ø¨ÙŠØ±Ø¬", "Ø¥ÙŠÙ„ÙˆÙ† Ù…Ø§Ø³Ùƒ"], "answer": 1},
    {"category": "ØªÙ‚Ù†ÙŠØ©", "question": "Ù…Ø§ Ù‡Ùˆ Ø£Ø´Ù‡Ø± Ù…Ø­Ø±Ùƒ Ø¨Ø­Ø« ÙÙŠ Ø§Ù„Ø¹Ø§Ù„Ù…ØŸ", "options": ["ÙŠØ§Ù‡Ùˆ", "Ø¨ÙŠÙ†Øº", "Ø¬ÙˆØ¬Ù„", "Ø¯Ø§Ùƒ Ø¯Ø§Ùƒ Ø¬Ùˆ"], "answer": 2},
    {"category": "ØªÙ‚Ù†ÙŠØ©", "question": "Ù…Ù† Ù‡Ùˆ Ù…Ø¤Ø³Ø³ ÙÙŠØ³Ø¨ÙˆÙƒØŸ", "options": ["Ø¨ÙŠÙ„ ØºÙŠØªØ³", "Ø³ØªÙŠÙ Ø¬ÙˆØ¨Ø²", "Ù…Ø§Ø±Ùƒ Ø²ÙˆÙƒØ±Ø¨ÙŠØ±Ø¬", "Ø¬Ø§Ùƒ Ø¯ÙˆØ±Ø³ÙŠ"], "answer": 2},
    {"category": "ØªÙ‚Ù†ÙŠØ©", "question": "Ù…Ø§ Ù‡Ùˆ Ù†Ø¸Ø§Ù… Ø§Ù„ØªØ´ØºÙŠÙ„ Ø§Ù„Ø°ÙŠ ØªØµÙ†Ø¹Ù‡ Ø£Ø¨Ù„ Ù„Ù„Ø¢ÙŠÙÙˆÙ†ØŸ", "options": ["Ø£Ù†Ø¯Ø±ÙˆÙŠØ¯", "ÙˆÙŠÙ†Ø¯ÙˆØ²", "iOS", "Ù„ÙŠÙ†ÙƒØ³"], "answer": 2},
    {"category": "ØªÙ‚Ù†ÙŠØ©", "question": "Ù…Ø§ Ù‡ÙŠ Ù„ØºØ© Ø§Ù„Ø¨Ø±Ù…Ø¬Ø© Ø§Ù„Ø£ÙƒØ«Ø± Ø´Ø¹Ø¨ÙŠØ©ØŸ", "options": ["Ø¬Ø§ÙØ§", "Ø¨Ø§ÙŠØ«ÙˆÙ†", "Ø³ÙŠ++", "Ø¬Ø§ÙØ§Ø³ÙƒØ±Ø¨Øª"], "answer": 1},
    {"category": "ØªÙ‚Ù†ÙŠØ©", "question": "Ù…Ù† Ù‡Ùˆ Ù…Ø¤Ø³Ø³ ØªØ³Ù„Ø§ ÙˆØ³Ø¨ÙŠØ³ Ø¥ÙƒØ³ØŸ", "options": ["Ø¬ÙŠÙ Ø¨ÙŠØ²ÙˆØ³", "Ø¥ÙŠÙ„ÙˆÙ† Ù…Ø§Ø³Ùƒ", "Ø¨ÙŠÙ„ ØºÙŠØªØ³", "Ù„Ø§Ø±ÙŠ Ø¨ÙŠØ¬"], "answer": 1},
    {"category": "ØªÙ‚Ù†ÙŠØ©", "question": "Ù…Ø§ Ù‡Ùˆ Ø£ÙƒØ¨Ø± Ù…ÙˆÙ‚Ø¹ ØªÙˆØ§ØµÙ„ Ø§Ø¬ØªÙ…Ø§Ø¹ÙŠ Ù…Ù† Ø­ÙŠØ« Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†ØŸ", "options": ["ØªÙˆÙŠØªØ±", "Ø¥Ù†Ø³ØªØºØ±Ø§Ù…", "ÙÙŠØ³Ø¨ÙˆÙƒ", "ØªÙŠÙƒ ØªÙˆÙƒ"], "answer": 2},
    {"category": "ØªÙ‚Ù†ÙŠØ©", "question": "Ù…Ø§ Ù‡ÙŠ Ø´Ø±ÙƒØ© ØµØ§Ù†Ø¹Ø© Ù‡ÙˆØ§ØªÙ Ø¢ÙŠÙÙˆÙ†ØŸ", "options": ["Ø³Ø§Ù…Ø³ÙˆÙ†Ø¬", "Ù‡ÙˆØ§ÙˆÙŠ", "Ø£Ø¨Ù„", "Ø´Ø§ÙˆÙ…ÙŠ"], "answer": 2},
    {"category": "ØªÙ‚Ù†ÙŠØ©", "question": "Ù…Ø§ Ù‡Ùˆ Ø§Ø®ØªØµØ§Ø± URLØŸ", "options": ["Universal Resource Locator", "Uniform Resource Locator", "United Resource Link", "Universal Resource Link"], "answer": 1},
    {"category": "ØªÙ‚Ù†ÙŠØ©", "question": "Ù…Ù† Ù‡Ùˆ Ù…Ø¤Ø³Ø³ Ø£Ù…Ø§Ø²ÙˆÙ†ØŸ", "options": ["Ø¥ÙŠÙ„ÙˆÙ† Ù…Ø§Ø³Ùƒ", "Ø¬ÙŠÙ Ø¨ÙŠØ²ÙˆØ³", "Ø¨ÙŠÙ„ ØºÙŠØªØ³", "Ù…Ø§Ø±Ùƒ Ø²ÙˆÙƒØ±Ø¨ÙŠØ±Ø¬"], "answer": 1},
    
    {"category": "Ø·Ø¨ÙŠØ¹Ø©", "question": "Ù…Ø§ Ù‡Ùˆ Ø£ÙƒØ¨Ø± Ø­ÙŠÙˆØ§Ù† Ø«Ø¯ÙŠÙŠØŸ", "options": ["Ø§Ù„ÙÙŠÙ„", "Ø§Ù„Ø­ÙˆØª Ø§Ù„Ø£Ø²Ø±Ù‚", "Ø§Ù„Ø²Ø±Ø§ÙØ©", "ÙØ±Ø³ Ø§Ù„Ù†Ù‡Ø±"], "answer": 1},
    {"category": "Ø·Ø¨ÙŠØ¹Ø©", "question": "ÙƒÙ… Ø±Ø¬Ù„Ø§Ù‹ Ù„Ù„Ø¹Ù†ÙƒØ¨ÙˆØªØŸ", "options": ["6", "8", "10", "12"], "answer": 1},
    {"category": "Ø·Ø¨ÙŠØ¹Ø©", "question": "Ù…Ø§ Ù‡Ùˆ Ø§Ù„Ø­ÙŠÙˆØ§Ù† Ø§Ù„ÙˆØ­ÙŠØ¯ Ø§Ù„Ø°ÙŠ Ù„Ø§ ÙŠØ³ØªØ·ÙŠØ¹ Ø§Ù„Ù‚ÙØ²ØŸ", "options": ["Ø§Ù„ÙÙŠÙ„", "ÙØ±Ø³ Ø§Ù„Ù†Ù‡Ø±", "ÙˆØ­ÙŠØ¯ Ø§Ù„Ù‚Ø±Ù†", "Ø§Ù„Ø¬Ù…Ù„"], "answer": 0},
    {"category": "Ø·Ø¨ÙŠØ¹Ø©", "question": "ÙƒÙ… Ù‚Ù„Ø¨Ø§Ù‹ Ù„Ù„Ø£Ø®Ø·Ø¨ÙˆØ·ØŸ", "options": ["1", "2", "3", "4"], "answer": 2},
    {"category": "Ø·Ø¨ÙŠØ¹Ø©", "question": "Ù…Ø§ Ù‡Ùˆ Ø£Ø·ÙˆÙ„ Ø­ÙŠÙˆØ§Ù† ÙÙŠ Ø§Ù„Ø¹Ø§Ù„Ù…ØŸ", "options": ["Ø§Ù„ÙÙŠÙ„", "Ø§Ù„Ø²Ø±Ø§ÙØ©", "Ø§Ù„Ø­ÙˆØª Ø§Ù„Ø£Ø²Ø±Ù‚", "Ø§Ù„Ø£ÙØ¹Ù‰"], "answer": 1},
    {"category": "Ø·Ø¨ÙŠØ¹Ø©", "question": "Ø£ÙŠÙ† ÙŠØ¹ÙŠØ´ Ø§Ù„Ø¯Ø¨ Ø§Ù„Ù‚Ø·Ø¨ÙŠØŸ", "options": ["Ø§Ù„Ù‚Ø·Ø¨ Ø§Ù„Ø¬Ù†ÙˆØ¨ÙŠ", "Ø§Ù„Ù‚Ø·Ø¨ Ø§Ù„Ø´Ù…Ø§Ù„ÙŠ", "Ø£ÙØ±ÙŠÙ‚ÙŠØ§", "Ø¢Ø³ÙŠØ§"], "answer": 1},
    {"category": "Ø·Ø¨ÙŠØ¹Ø©", "question": "Ù…Ø§ Ù‡Ùˆ Ø§Ù„Ø·Ø§Ø¦Ø± Ø§Ù„Ø°ÙŠ Ù„Ø§ ÙŠØ·ÙŠØ±ØŸ", "options": ["Ø§Ù„Ù†Ø³Ø±", "Ø§Ù„Ø¨Ø·Ø±ÙŠÙ‚", "Ø§Ù„ØµÙ‚Ø±", "Ø§Ù„Ø¨ÙˆÙ…Ø©"], "answer": 1},
    {"category": "Ø·Ø¨ÙŠØ¹Ø©", "question": "ÙƒÙ… Ø¹ÙŠÙ†Ø§Ù‹ Ù„Ù„Ù†Ø­Ù„Ø©ØŸ", "options": ["2", "3", "4", "5"], "answer": 3},
    {"category": "Ø·Ø¨ÙŠØ¹Ø©", "question": "Ù…Ø§ Ù‡Ùˆ Ø£Ø³Ø±Ø¹ Ø·Ø§Ø¦Ø± ÙÙŠ Ø§Ù„Ø¹Ø§Ù„Ù…ØŸ", "options": ["Ø§Ù„Ù†Ø³Ø±", "Ø§Ù„ØµÙ‚Ø± Ø§Ù„Ø´Ø§Ù‡ÙŠÙ†", "Ø§Ù„Ø¨ÙˆÙ…Ø©", "Ø§Ù„ØºØ±Ø§Ø¨"], "answer": 1},
    {"category": "Ø·Ø¨ÙŠØ¹Ø©", "question": "Ù…Ø§ Ù‡Ùˆ Ø§Ù„Ø­ÙŠÙˆØ§Ù† Ø§Ù„Ø£ÙƒØ«Ø± Ø°ÙƒØ§Ø¡Ù‹ Ø¨Ø¹Ø¯ Ø§Ù„Ø¥Ù†Ø³Ø§Ù†ØŸ", "options": ["Ø§Ù„ÙƒÙ„Ø¨", "Ø§Ù„Ù‚Ø±Ø¯", "Ø§Ù„Ø¯Ù„ÙÙŠÙ†", "Ø§Ù„ÙÙŠÙ„"], "answer": 2}
]

DATA_DIR = "data"
BOTS_FILE = os.path.join(DATA_DIR, "bots.json")
SCHEDULES_FILE = os.path.join(DATA_DIR, "schedules.json")
USER_CHATS_FILE = os.path.join(DATA_DIR, "user_chats.json")
MEMBER_FILE = "member.json"
REMEMBER_FILE = "remember.json"
BANNED_USERS_FILE = os.path.join(DATA_DIR, "banned_users.json")

def ensure_data_dir():
    if not os.path.exists(DATA_DIR):
        os.makedirs(DATA_DIR)

def load_json_file(filename):
    try:
        with open(filename, 'r', encoding='utf-8') as f:
            return json.load(f)
    except (FileNotFoundError, json.JSONDecodeError):
        return {}

def save_json_file(filename, data):
    ensure_data_dir()
    with open(filename, 'w', encoding='utf-8') as f:
        json.dump(data, f, ensure_ascii=False, indent=2)

def get_bots_data():
    return load_json_file(BOTS_FILE)

def save_bots_data(data):
    save_json_file(BOTS_FILE, data)

def get_schedules_data():
    return load_json_file(SCHEDULES_FILE)

def save_schedules_data(data):
    save_json_file(SCHEDULES_FILE, data)

def get_member_data():
    return load_json_file(MEMBER_FILE)

def save_member_data(data):
    save_json_file(MEMBER_FILE, data)

def get_remember_data():
    return load_json_file(REMEMBER_FILE)

def save_remember_data(data):
    save_json_file(REMEMBER_FILE, data)

def get_user_chats_data():
    return load_json_file(USER_CHATS_FILE)

def save_user_chats_data(data):
    save_json_file(USER_CHATS_FILE, data)

def get_banned_users_data():
    return load_json_file(BANNED_USERS_FILE)

def save_banned_users_data(data):
    save_json_file(BANNED_USERS_FILE, data)

def add_user_chat(bot_token: str, user_id: int, chat_id: int, chat_title: str, chat_type: str):
    data = get_user_chats_data()
    key = f"{bot_token}_{user_id}"
    if key not in data:
        data[key] = {"channels": [], "groups": []}
    
    chat_info = {"chat_id": chat_id, "title": chat_title}
    list_key = "channels" if chat_type == "channel" else "groups"
    
    existing_ids = [c["chat_id"] for c in data[key][list_key]]
    if chat_id not in existing_ids:
        data[key][list_key].append(chat_info)
        save_user_chats_data(data)

def get_user_chats(bot_token: str, user_id: int, chat_type: str):
    data = get_user_chats_data()
    key = f"{bot_token}_{user_id}"
    if key not in data:
        return []
    list_key = "channels" if chat_type == "channel" else "groups"
    return data[key].get(list_key, [])

running_bot_apps = {}
user_states = {}

async def check_subscription(user_id: int, bot: Bot) -> bool:
    try:
        member = await bot.get_chat_member(chat_id=REQUIRED_CHANNEL, user_id=user_id)
        return member.status in [ChatMemberStatus.MEMBER, ChatMemberStatus.ADMINISTRATOR, ChatMemberStatus.OWNER]
    except Exception as e:
        logger.error(f"Error checking subscription: {e}")
        return False

def get_subscription_keyboard():
    keyboard = [
        [InlineKeyboardButton("Ø§Ø´ØªØ±Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø©", url=f"https://t.me/{REQUIRED_CHANNEL[1:]}")],
        [InlineKeyboardButton("ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ", callback_data="check_sub")]
    ]
    return InlineKeyboardMarkup(keyboard)

SUPPORT_GROUP = "@TepthonHelp"
UPDATES_CHANNEL = "@Tepthon"

def get_main_menu_keyboard():
    keyboard = [
        [InlineKeyboardButton("Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§ÙƒØ«Ø± Ø¹Ù† Ø§Ù„Ø¨ÙˆØª ğŸ’¡", callback_data="bot_info")],
        [
            InlineKeyboardButton("Ø¨ÙˆØªØ§ØªÙŠ Ø§Ù„Ù…ØµÙ†ÙˆØ¹Ù‡ ğŸ¤–", callback_data="my_bots"),
            InlineKeyboardButton("ØµÙ†Ø¹ Ø¨ÙˆØª Ø¬Ø¯ÙŠØ¯", callback_data="create_bot")
        ],
        [InlineKeyboardButton("Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø§Ù„Ù…Ø¯ÙÙˆØ¹ Ù„Ù„Ø¨ÙˆØªØ§Øª", callback_data="premium_sub")],
        [InlineKeyboardButton("Ù‚Ù†Ø§Ù‡ ØªØ­Ø¯ÙŠØ«Ø§Øª Ø§Ù„ØµØ§Ù†Ø¹", url=f"https://t.me/{UPDATES_CHANNEL[1:]}")]
    ]
    return InlineKeyboardMarkup(keyboard)

def get_bot_types_keyboard():
    keyboard = [
        [
            InlineKeyboardButton("Ø§Ø°ÙƒØ§Ø±", callback_data="create_adhkar"),
            InlineKeyboardButton("Ø°ÙƒØ§Ø¡ Ø§ØµØ·Ù†Ø§Ø¹ÙŠ", callback_data="create_ai")
        ],
        [
            InlineKeyboardButton("Ù…Ù†Ø¹ ØªØµÙÙŠÙ‡", callback_data="create_guard"),
            InlineKeyboardButton("ÙƒÙˆÙŠØ²", callback_data="create_quiz")
        ],
        [
            InlineKeyboardButton("Ù‚Ø¨ÙˆÙ„ Ø§Ù†Ø¶Ù…Ø§Ù…", callback_data="create_join"),
            InlineKeyboardButton("Ø³ØªÙŠÙƒØ±Ø§Øª", callback_data="create_sticker")
        ],
        [
            InlineKeyboardButton("Ø±Ø¬ÙˆØ¹", callback_data="back_main")
        ]
    ]
    return InlineKeyboardMarkup(keyboard)

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    if user is None:
        return
    user_id = user.id
    first_name = user.first_name or "ØµØ¯ÙŠÙ‚ÙŠ"
    
    is_subscribed = await check_subscription(user_id, context.bot)
    
    if not is_subscribed:
        text = f"""â€» Ø§Ù‡Ù„Ø§ ÙˆØ³Ù‡Ù„Ø§ ÙŠØ§ {first_name}

ÙŠØ¬Ø¨ Ø¹Ù„ÙŠÙƒ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø© Ø§ÙˆÙ„Ø§ Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¨ÙˆØª"""
        await update.message.reply_text(text, reply_markup=get_subscription_keyboard())
        return
    
    member_data = get_member_data()
    if str(user_id) not in member_data:
        member_data[str(user_id)] = {
            "first_name": first_name,
            "username": user.username,
            "joined": datetime.now().isoformat(),
            "bots_created": 0
        }
        save_member_data(member_data)
    
    text = f"""â€» Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ ÙÙŠ ØµØ§Ù†Ø¹ Ø¨ÙˆØªØ§Øª ØªÙŠØ¨Ø«ÙˆÙ†

â Ù…Ø±Ø­Ø¨Ø§ Ø¨Ùƒ ÙŠØ§ {first_name}

â Ø§Ù„Ù…Ù…ÙŠØ²Ø§Øª:
â€¢ Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ ÙÙŠ Ø§Ù„Ù…Ù†Ø·Ù‚Ø© Ø§Ù„ØªÙŠ Ù„Ø§ ØªØ¹Ø±Ù Ø§Ù„Ù…Ø³ØªØ­ÙŠÙ„
â€¢ Ø¨ÙˆØªØ§Øª Ø°ÙƒÙŠÙ‡ ÙˆØ³Ø±ÙŠØ¹Ù‡ ÙˆØ§Ù…Ù†Ù‡ 
â€¢ Ù‚Ù… Ø¨Ø§Ù†Ø´Ø§Ø¡ Ø¨ÙˆØªÙƒ Ø§Ù„Ø®Ø§Øµ Ø§Ù„Ø§Ù† âœ…

â€» ÙŠÙ…ØªÙŠØ² Ø§Ù„Ø¨ÙˆØª Ø¨Ø§Ù„Ø³Ø±Ø¹Ù‡ ÙˆØ§Ù„Ø§Ø¯Ø§Ø¡ Ø§Ù„Ù…Ù„Ø­ÙˆØ¸ Ù‚Ù… Ø¨Ø§Ù„Ø¶ØºØ· Ø¹Ù„Ù‰ /start"""
    await update.message.reply_text(text, reply_markup=get_main_menu_keyboard())

async def handle_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    if query is None:
        return
    
    if await handle_developer_callback(update, context):
        return
    
    await query.answer()
    
    user = query.from_user
    if user is None:
        return
    user_id = user.id
    first_name = user.first_name or "ØµØ¯ÙŠÙ‚ÙŠ"
    data = query.data
    
    if data == "check_sub":
        is_subscribed = await check_subscription(user_id, context.bot)
        if is_subscribed:
            text = f"""â€» Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ ÙÙŠ ØµØ§Ù†Ø¹ Ø¨ÙˆØªØ§Øª ØªÙŠØ¨Ø«ÙˆÙ†

â Ù…Ø±Ø­Ø¨Ø§ Ø¨Ùƒ ÙŠØ§ {first_name}

â Ø§Ù„Ù…Ù…ÙŠØ²Ø§Øª:
â€¢ Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ ÙÙŠ Ø§Ù„Ù…Ù†Ø·Ù‚Ø© Ø§Ù„ØªÙŠ Ù„Ø§ ØªØ¹Ø±Ù Ø§Ù„Ù…Ø³ØªØ­ÙŠÙ„
â€¢ Ø¨ÙˆØªØ§Øª Ø°ÙƒÙŠÙ‡ ÙˆØ³Ø±ÙŠØ¹Ù‡ ÙˆØ§Ù…Ù†Ù‡ 
â€¢ Ù‚Ù… Ø¨Ø§Ù†Ø´Ø§Ø¡ Ø¨ÙˆØªÙƒ Ø§Ù„Ø®Ø§Øµ Ø§Ù„Ø§Ù† âœ…

â€» ÙŠÙ…ØªÙŠØ² Ø§Ù„Ø¨ÙˆØª Ø¨Ø§Ù„Ø³Ø±Ø¹Ù‡ ÙˆØ§Ù„Ø§Ø¯Ø§Ø¡ Ø§Ù„Ù…Ù„Ø­ÙˆØ¸ Ù‚Ù… Ø¨Ø§Ù„Ø¶ØºØ· Ø¹Ù„Ù‰ /start"""
            await query.edit_message_text(text, reply_markup=get_main_menu_keyboard())
        else:
            await query.answer("Ù„Ù… ØªØ´ØªØ±Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø© Ø¨Ø¹Ø¯", show_alert=True)
        return
    
    if data == "bot_info":
        text = """â€» Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¹Ù† Ø§Ù„Ø¨ÙˆØª

â ØµØ§Ù†Ø¹ Ø¨ÙˆØªØ§Øª ØªÙŠØ¨Ø«ÙˆÙ† Ù‡Ùˆ Ù…Ù†ØµØ© Ù…ØªÙƒØ§Ù…Ù„Ø© Ù„Ø¥Ù†Ø´Ø§Ø¡ Ø¨ÙˆØªØ§Øª ØªÙ„ÙŠØ¬Ø±Ø§Ù… Ø¨Ø¯ÙˆÙ† Ø£ÙŠ Ø®Ø¨Ø±Ø© Ø¨Ø±Ù…Ø¬ÙŠØ©

â Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„Ø¨ÙˆØªØ§Øª Ø§Ù„Ù…ØªØ§Ø­Ø©:
â€¢ Ø¨ÙˆØª Ø°ÙƒØ§Ø¡ Ø§ØµØ·Ù†Ø§Ø¹ÙŠ - Ù…Ø­Ø§Ø¯Ø«Ø© Ø°ÙƒÙŠØ© Ù…Ø¹ Ø¯Ø¹Ù… ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØµÙˆØ±
â€¢ Ø¨ÙˆØª Ø£Ø°ÙƒØ§Ø± - Ù†Ø´Ø± Ø§Ù„Ø£Ø°ÙƒØ§Ø± ÙÙŠ Ø§Ù„Ù‚Ù†ÙˆØ§Øª ÙˆØ§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª
â€¢ Ø¨ÙˆØª Ù…Ù†Ø¹ ØªØµÙÙŠØ© - Ø­Ù…Ø§ÙŠØ© Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª Ù…Ù† Ø§Ù„Ù…Ø®Ø±Ø¨ÙŠÙ†
â€¢ Ø¨ÙˆØª ÙƒÙˆÙŠØ² - Ø£Ø³Ø¦Ù„Ø© Ø«Ù‚Ø§ÙÙŠØ© Ù…Ø¹ Ù†Ø¸Ø§Ù… Ù†Ù‚Ø§Ø·
â€¢ Ø¨ÙˆØª Ù‚Ø¨ÙˆÙ„ Ø§Ù†Ø¶Ù…Ø§Ù… - Ù‚Ø¨ÙˆÙ„ Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù… ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹

â Ø§Ù„Ù…Ù…ÙŠØ²Ø§Øª:
â€¢ Ø³Ø±Ø¹Ø© ÙØ§Ø¦Ù‚Ø© ÙÙŠ Ø§Ù„Ø£Ø¯Ø§Ø¡
â€¢ Ø§Ø³ØªØ¶Ø§ÙØ© Ø¢Ù…Ù†Ø© ÙˆÙ…Ø¬Ø§Ù†ÙŠØ©
â€¢ Ù„ÙˆØ­Ø© ØªØ­ÙƒÙ… ÙƒØ§Ù…Ù„Ø© Ù„ÙƒÙ„ Ø¨ÙˆØª
â€¢ Ø¯Ø¹Ù… ÙÙ†ÙŠ Ù…ØªÙˆØ§ØµÙ„"""
        keyboard = [[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹", callback_data="back_main")]]
        await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
        return
    
    if data == "premium_sub":
        text = """â€» Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø§Ù„Ù…Ø¯ÙÙˆØ¹ Ù„Ù„Ø¨ÙˆØªØ§Øª

â Ø§Ù„Ù…Ù…ÙŠØ²Ø§Øª Ø§Ù„Ø­ØµØ±ÙŠØ©:
â€¢ Ø¨ÙˆØªØ§Øª Ø¨Ø¯ÙˆÙ† Ø­Ø¯ÙˆØ¯ Ù„Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…
â€¢ Ø£ÙˆÙ„ÙˆÙŠØ© ÙÙŠ Ø§Ù„Ø¯Ø¹Ù… Ø§Ù„ÙÙ†ÙŠ
â€¢ Ù…ÙŠØ²Ø§Øª Ù…ØªÙ‚Ø¯Ù…Ø© Ø­ØµØ±ÙŠØ©
â€¢ Ø³Ø±Ø¹Ø© Ø£Ø¹Ù„Ù‰ ÙÙŠ Ø§Ù„Ø£Ø¯Ø§Ø¡

â Ù„Ù„Ø§Ø´ØªØ±Ø§Ùƒ ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ù…Ø·ÙˆØ±:
@Dev_Mido"""
        keyboard = [[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹", callback_data="back_main")]]
        await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
        return
    
    if data == "create_bot":
        text = """â€» Ø§Ø®ØªØ± Ù†ÙˆØ¹ Ø§Ù„Ø¨ÙˆØª

â Ø§Ø°ÙƒØ§Ø± - Ø¨ÙˆØª Ù„Ù†Ø´Ø± Ø§Ù„Ø§Ø°ÙƒØ§Ø± ÙÙŠ Ø§Ù„Ù‚Ù†ÙˆØ§Øª ÙˆØ§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª
â Ø°ÙƒØ§Ø¡ Ø§ØµØ·Ù†Ø§Ø¹ÙŠ - Ø¨ÙˆØª Ù…Ø­Ø§Ø¯Ø«Ø© Ø°ÙƒÙŠ
â Ù…Ù†Ø¹ ØªØµÙÙŠÙ‡ - Ø¨ÙˆØª Ø­Ù…Ø§ÙŠØ© Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª
â ÙƒÙˆÙŠØ² - Ø¨ÙˆØª Ø§Ø³Ø¦Ù„Ø© Ø«Ù‚Ø§ÙÙŠØ© Ù…Ø¹ Ù†Ø¸Ø§Ù… Ù†Ù‚Ø§Ø·
â Ù‚Ø¨ÙˆÙ„ Ø§Ù†Ø¶Ù…Ø§Ù… - Ù‚Ø¨ÙˆÙ„ Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù… ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹"""
        await query.edit_message_text(text, reply_markup=get_bot_types_keyboard())
        return
    
    if data == "my_bots":
        bots_data = get_bots_data()
        user_bots = {token: bot for token, bot in bots_data.items() if bot.get('owner_id') == user_id}
        
        if not user_bots:
            text = """â€» Ø¨ÙˆØªØ§ØªÙƒ

Ù„Ù… ØªÙ‚Ù… Ø¨Ø¥Ù†Ø´Ø§Ø¡ Ø£ÙŠ Ø¨ÙˆØªØ§Øª Ø¨Ø¹Ø¯
Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ "Ø§Ù†Ø´Ø§Ø¡ Ø¨ÙˆØª" Ù„Ù„Ø¨Ø¯Ø¡"""
            keyboard = [[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹", callback_data="back_main")]]
            await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
            return
        
        text = f"""â€» Ø¨ÙˆØªØ§ØªÙƒ

Ø¹Ø¯Ø¯ Ø§Ù„Ø¨ÙˆØªØ§Øª: {len(user_bots)}

Ø§Ø®ØªØ± Ø¨ÙˆØª Ù„Ù„ØªØ­ÙƒÙ… ÙÙŠÙ‡:"""
        
        keyboard = []
        for token, bot_data in user_bots.items():
            status = "ğŸŸ¢" if bot_data.get('active', True) else "ğŸ”´"
            bot_name = bot_data.get('bot_username', 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')
            bot_type_map = {'ai': 'Ø°ÙƒØ§Ø¡', 'adhkar': 'Ø§Ø°ÙƒØ§Ø±', 'guard': 'Ø­Ù…Ø§ÙŠØ©'}
            bot_type = bot_type_map.get(bot_data['type'], 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')
            users_count = bot_data.get('users_count', 0)
            keyboard.append([
                InlineKeyboardButton(
                    f"{status} @{bot_name} - {bot_type} - {users_count} Ù…Ø³ØªØ®Ø¯Ù…",
                    callback_data=f"mybot_{token[:25]}"
                )
            ])
        
        keyboard.append([InlineKeyboardButton("Ø±Ø¬ÙˆØ¹", callback_data="back_main")])
        await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
        return
    
    if data.startswith("mybot_"):
        token_prefix = data.replace("mybot_", "")
        bots_data = get_bots_data()
        target_token = None
        target_bot = None
        for token, bot_data in bots_data.items():
            if token.startswith(token_prefix) and bot_data.get('owner_id') == user_id:
                target_token = token
                target_bot = bot_data
                break
        
        if not target_bot:
            await query.answer("Ø§Ù„Ø¨ÙˆØª ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯", show_alert=True)
            return
        
        status = "Ø´ØºØ§Ù„ ğŸŸ¢" if target_bot.get('active', True) else "Ù…ØªÙˆÙ‚Ù ğŸ”´"
        bot_name = target_bot.get('bot_username', 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')
        bot_type_map = {'ai': 'Ø°ÙƒØ§Ø¡ Ø§ØµØ·Ù†Ø§Ø¹ÙŠ', 'adhkar': 'Ø§Ø°ÙƒØ§Ø±', 'guard': 'Ù…Ù†Ø¹ ØªØµÙÙŠØ©', 'quiz': 'ÙƒÙˆÙŠØ²'}
        bot_type = bot_type_map.get(target_bot['type'], 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')
        users_count = target_bot.get('users_count', 0)
        created = target_bot.get('created', 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')[:10]
        
        text = f"""â€» ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø¨ÙˆØª

â Ø§Ù„Ø§Ø³Ù…: @{bot_name}
â Ø§Ù„Ù†ÙˆØ¹: {bot_type}
â Ø§Ù„Ø­Ø§Ù„Ø©: {status}
â Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†: {users_count}
â ØªØ§Ø±ÙŠØ® Ø§Ù„Ø¥Ù†Ø´Ø§Ø¡: {created}"""
        
        toggle_text = "Ø§ÙŠÙ‚Ø§Ù â¸ï¸" if target_bot.get('active', True) else "ØªØ´ØºÙŠÙ„ â–¶ï¸"
        keyboard = [
            [
                InlineKeyboardButton(toggle_text, callback_data=f"user_toggle_{token_prefix}"),
                InlineKeyboardButton("Ø­Ø°Ù ğŸ—‘ï¸", callback_data=f"user_delete_{token_prefix}")
            ],
            [InlineKeyboardButton("Ø±Ø¬ÙˆØ¹", callback_data="my_bots")]
        ]
        await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
        return
    
    if data.startswith("user_toggle_"):
        token_prefix = data.replace("user_toggle_", "")
        bots_data = get_bots_data()
        for token, bot_data in bots_data.items():
            if token.startswith(token_prefix) and bot_data.get('owner_id') == user_id:
                bot_data['active'] = not bot_data.get('active', True)
                save_bots_data(bots_data)
                
                if bot_data['active']:
                    if bot_data['type'] == 'ai':
                        asyncio.create_task(start_ai_bot(token, user_id))
                    elif bot_data['type'] == 'adhkar':
                        asyncio.create_task(start_adhkar_bot(token, user_id))
                    elif bot_data['type'] == 'guard':
                        asyncio.create_task(start_guard_bot(token, user_id))
                    elif bot_data['type'] == 'quiz':
                        asyncio.create_task(start_quiz_bot(token, user_id))
                    await query.answer("ØªÙ… ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª âœ…", show_alert=True)
                else:
                    if token in running_bot_apps:
                        try:
                            await running_bot_apps[token].stop()
                            del running_bot_apps[token]
                        except:
                            pass
                    await query.answer("ØªÙ… Ø§ÙŠÙ‚Ø§Ù Ø§Ù„Ø¨ÙˆØª â¸ï¸", show_alert=True)
                
                callback_data = f"mybot_{token_prefix}"
                query.data = callback_data
                await handle_callback(update, context)
                return
        await query.answer("Ø§Ù„Ø¨ÙˆØª ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯", show_alert=True)
        return
    
    if data.startswith("user_delete_"):
        token_prefix = data.replace("user_delete_", "")
        text = """â€» ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø­Ø°Ù

Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø­Ø°Ù Ù‡Ø°Ø§ Ø§Ù„Ø¨ÙˆØªØŸ
Ø³ÙŠØªÙ… Ø­Ø°Ù Ø§Ù„Ø¨ÙˆØª Ù†Ù‡Ø§Ø¦ÙŠØ§Ù‹ ÙˆÙ„Ù† ØªØ³ØªØ·ÙŠØ¹ Ø§Ø³ØªØ¹Ø§Ø¯ØªÙ‡"""
        keyboard = [
            [
                InlineKeyboardButton("Ù†Ø¹Ù…ØŒ Ø§Ø­Ø°Ù", callback_data=f"confirm_delete_{token_prefix}"),
                InlineKeyboardButton("Ù„Ø§ØŒ Ø±Ø¬ÙˆØ¹", callback_data=f"mybot_{token_prefix}")
            ]
        ]
        await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
        return
    
    if data.startswith("confirm_delete_"):
        token_prefix = data.replace("confirm_delete_", "")
        bots_data = get_bots_data()
        for token, bot_data in list(bots_data.items()):
            if token.startswith(token_prefix) and bot_data.get('owner_id') == user_id:
                if token in running_bot_apps:
                    try:
                        await running_bot_apps[token].stop()
                        del running_bot_apps[token]
                    except:
                        pass
                del bots_data[token]
                save_bots_data(bots_data)
                
                member_data = get_member_data()
                if str(user_id) in member_data:
                    member_data[str(user_id)]['bots_created'] = max(0, member_data[str(user_id)].get('bots_created', 1) - 1)
                    save_member_data(member_data)
                
                await query.answer("ØªÙ… Ø­Ø°Ù Ø§Ù„Ø¨ÙˆØª Ù†Ù‡Ø§Ø¦ÙŠØ§Ù‹ ğŸ—‘ï¸", show_alert=True)
                query.data = "my_bots"
                await handle_callback(update, context)
                return
        await query.answer("Ø§Ù„Ø¨ÙˆØª ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯", show_alert=True)
        return
    
    if data == "create_ai":
        text = """â€» Ø§Ù†Ø´Ø§Ø¡ Ø¨ÙˆØª Ø°ÙƒØ§Ø¡ Ø§ØµØ·Ù†Ø§Ø¹ÙŠ

Ø§Ø±Ø³Ù„ ØªÙˆÙƒÙ† Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ
Ø§Ø­ØµÙ„ Ø¹Ù„ÙŠÙ‡ Ù…Ù† @BotFather"""
        user_states[user_id] = {'creating': 'ai'}
        keyboard = [[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹", callback_data="back_main")]]
        await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
        return
    
    if data == "create_adhkar":
        text = """â€» Ø§Ù†Ø´Ø§Ø¡ Ø¨ÙˆØª Ø§Ø°ÙƒØ§Ø±

Ø§Ø±Ø³Ù„ ØªÙˆÙƒÙ† Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ
Ø§Ø­ØµÙ„ Ø¹Ù„ÙŠÙ‡ Ù…Ù† @BotFather"""
        user_states[user_id] = {'creating': 'adhkar'}
        keyboard = [[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹", callback_data="back_main")]]
        await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
        return
    
    if data == "create_guard":
        text = """â€» Ø§Ù†Ø´Ø§Ø¡ Ø¨ÙˆØª Ù…Ù†Ø¹ ØªØµÙÙŠØ©

Ø§Ø±Ø³Ù„ ØªÙˆÙƒÙ† Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ
Ø§Ø­ØµÙ„ Ø¹Ù„ÙŠÙ‡ Ù…Ù† @BotFather"""
        user_states[user_id] = {'creating': 'guard'}
        keyboard = [[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹", callback_data="back_main")]]
        await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
        return
    
    if data == "create_quiz":
        text = """â€» Ø§Ù†Ø´Ø§Ø¡ Ø¨ÙˆØª ÙƒÙˆÙŠØ²

Ø¨ÙˆØª Ø§Ø³Ø¦Ù„Ø© Ø«Ù‚Ø§ÙÙŠØ© ÙˆÙ…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¹Ø§Ù…Ø©
Ù…Ø¹ Ù†Ø¸Ø§Ù… Ù†Ù‚Ø§Ø· ÙˆÙ„ÙˆØ­Ø© Ù…ØªØµØ¯Ø±ÙŠÙ†

Ø§Ø±Ø³Ù„ ØªÙˆÙƒÙ† Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ
Ø§Ø­ØµÙ„ Ø¹Ù„ÙŠÙ‡ Ù…Ù† @BotFather"""
        user_states[user_id] = {'creating': 'quiz'}
        keyboard = [[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹", callback_data="back_main")]]
        await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
        return
    
    if data == "create_join":
        text = """â€» Ø§Ù†Ø´Ø§Ø¡ Ø¨ÙˆØª Ù‚Ø¨ÙˆÙ„ Ø§Ù†Ø¶Ù…Ø§Ù…

Ø¨ÙˆØª Ù„Ù‚Ø¨ÙˆÙ„ Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù… ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹
Ù„Ù„Ù‚Ù†ÙˆØ§Øª ÙˆØ§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª Ø¨Ø³Ø±Ø¹Ø© Ø®ÙŠØ§Ù„ÙŠØ©

Ø§Ø±Ø³Ù„ ØªÙˆÙƒÙ† Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ
Ø§Ø­ØµÙ„ Ø¹Ù„ÙŠÙ‡ Ù…Ù† @BotFather"""
        user_states[user_id] = {'creating': 'join'}
        keyboard = [[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹", callback_data="back_main")]]
        await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
        return
    
    if data == "create_sticker":
        text = """â€» Ø§Ù†Ø´Ø§Ø¡ Ø¨ÙˆØª Ø³ØªÙŠÙƒØ±Ø§Øª

Ø¨ÙˆØª Ù„ØªØ­ÙˆÙŠÙ„ Ø§Ù„ØµÙˆØ± Ø§Ù„Ù‰ Ø³ØªÙŠÙƒØ±Ø§Øª
Ø§Ø±Ø³Ù„ ØµÙˆØ±Ø© ÙˆØ³ÙŠØªÙ… ØªØ­ÙˆÙŠÙ„Ù‡Ø§ Ù„Ø³ØªÙŠÙƒØ± Ø¨Ø­Ø¬Ù… 512x512

Ø§Ø±Ø³Ù„ ØªÙˆÙƒÙ† Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ
Ø§Ø­ØµÙ„ Ø¹Ù„ÙŠÙ‡ Ù…Ù† @BotFather"""
        user_states[user_id] = {'creating': 'sticker'}
        keyboard = [[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹", callback_data="back_main")]]
        await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
        return
    
    if data == "back_main":
        user_states.pop(user_id, None)
        text = f"""â€» Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ ÙÙŠ ØµØ§Ù†Ø¹ Ø¨ÙˆØªØ§Øª ØªÙŠØ¨Ø«ÙˆÙ†

â Ù…Ø±Ø­Ø¨Ø§ Ø¨Ùƒ ÙŠØ§ {first_name}

â Ø§Ù„Ù…Ù…ÙŠØ²Ø§Øª:
â€¢ Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ ÙÙŠ Ø§Ù„Ù…Ù†Ø·Ù‚Ø© Ø§Ù„ØªÙŠ Ù„Ø§ ØªØ¹Ø±Ù Ø§Ù„Ù…Ø³ØªØ­ÙŠÙ„
â€¢ Ø¨ÙˆØªØ§Øª Ø°ÙƒÙŠÙ‡ ÙˆØ³Ø±ÙŠØ¹Ù‡ ÙˆØ§Ù…Ù†Ù‡ 
â€¢ Ù‚Ù… Ø¨Ø§Ù†Ø´Ø§Ø¡ Ø¨ÙˆØªÙƒ Ø§Ù„Ø®Ø§Øµ Ø§Ù„Ø§Ù† âœ…

â€» ÙŠÙ…ØªÙŠØ² Ø§Ù„Ø¨ÙˆØª Ø¨Ø§Ù„Ø³Ø±Ø¹Ù‡ ÙˆØ§Ù„Ø§Ø¯Ø§Ø¡ Ø§Ù„Ù…Ù„Ø­ÙˆØ¸ Ù‚Ù… Ø¨Ø§Ù„Ø¶ØºØ· Ø¹Ù„Ù‰ /start"""
        await query.edit_message_text(text, reply_markup=get_main_menu_keyboard())
        return

async def handle_token(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    message = update.message
    if user is None or message is None:
        return
    user_id = user.id
    first_name = user.first_name or "ØµØ¯ÙŠÙ‚ÙŠ"
    token = message.text.strip() if message.text else ""
    
    if await handle_developer_message(update, context):
        return
    
    logger.info(f"handle_token called by user {user_id}, token starts with: {token[:20] if len(token) > 20 else token}")
    
    banned_makers = get_banned_maker_users()
    if user_id in banned_makers:
        await message.reply_text("â›” Ø§Ù†Øª Ù…Ø­Ø¸ÙˆØ± Ù…Ù† ØµÙ†Ø¹ Ø§Ù„Ø¨ÙˆØªØ§Øª")
        return
    
    is_subscribed = await check_subscription(user_id, context.bot)
    if not is_subscribed:
        logger.info(f"User {user_id} not subscribed")
        await message.reply_text(
            "ÙŠØ¬Ø¨ Ø¹Ù„ÙŠÙƒ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø© Ø§ÙˆÙ„Ø§",
            reply_markup=get_subscription_keyboard()
        )
        return
    
    user_state = user_states.get(user_id, {})
    creating_type = user_state.get('creating')
    logger.info(f"User {user_id} state: {user_state}, creating_type: {creating_type}")
    if not creating_type:
        return
    
    if not token or ':' not in token:
        await message.reply_text("Ø§Ù„ØªÙˆÙƒÙ† ØºÙŠØ± ØµØ§Ù„Ø­ØŒ Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø§Ø®Ø±Ù‰")
        return
    
    await message.reply_text("â€» Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØªÙˆÙƒÙ†...")
    
    try:
        test_bot = Bot(token=token)
        bot_info = await test_bot.get_me()
        
        if not bot_info or not bot_info.username:
            await message.reply_text("â€» Ø§Ù„ØªÙˆÙƒÙ† ØºÙŠØ± ØµØ§Ù„Ø­ Ø§Ùˆ Ø§Ù„Ø¨ÙˆØª Ù…Ø¹Ø·Ù„\nØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„ØªÙˆÙƒÙ† ÙˆØ­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø§Ø®Ø±Ù‰")
            return
        
        bot_username = bot_info.username
        
        existing_bot = db.get_bot_by_username(bot_username)
        if existing_bot:
            await message.reply_text(f"â€» Ù‡Ø°Ø§ Ø§Ù„Ø¨ÙˆØª (@{bot_username}) Ù…ØµÙ†ÙˆØ¹ Ù…Ù† Ù‚Ø¨Ù„!\nÙ„Ø§ ÙŠÙ…ÙƒÙ† Ø¥Ù†Ø´Ø§Ø¡ Ù†ÙØ³ Ø§Ù„Ø¨ÙˆØª Ù…Ø±ØªÙŠÙ†")
            return
        
        existing_token = db.get_bot_by_token(token)
        if existing_token:
            await message.reply_text("â€» Ù‡Ø°Ø§ Ø§Ù„ØªÙˆÙƒÙ† Ù…Ø³ØªØ®Ø¯Ù… Ù…Ù† Ù‚Ø¨Ù„!")
            return
        
        db.add_member(user_id, first_name, user.username)
        db.increment_bots_created(user_id)
        
        db.add_bot(token, bot_username, creating_type, user_id, REQUIRED_CHANNEL)
        log_bot_created(creating_type, bot_username, user_id)
        
        bot_type_names = {'ai': 'Ø°ÙƒØ§Ø¡ Ø§ØµØ·Ù†Ø§Ø¹ÙŠ', 'adhkar': 'Ø§Ø°ÙƒØ§Ø±', 'guard': 'Ø­Ù…Ø§ÙŠØ© Ù…Ù† Ø§Ù„ØªØµÙÙŠØ©', 'quiz': 'ÙƒÙˆÙŠØ²', 'join': 'Ù‚Ø¨ÙˆÙ„ Ø§Ù†Ø¶Ù…Ø§Ù…', 'sticker': 'Ø³ØªÙŠÙƒØ±Ø§Øª'}
        
        if creating_type == 'ai':
            asyncio.create_task(start_ai_bot(token, user_id))
            text = f"""â€» ØªÙ… Ø§Ù†Ø´Ø§Ø¡ Ø¨ÙˆØª Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ø¨Ù†Ø¬Ø§Ø­

Ø§Ù„Ø¨ÙˆØª: @{bot_username}
Ø§Ù„Ù†ÙˆØ¹: Ø°ÙƒØ§Ø¡ Ø§ØµØ·Ù†Ø§Ø¹ÙŠ
Ø§Ù„Ù…Ø§Ù„Ùƒ: {first_name}

Ø§Ù„Ø¨ÙˆØª ÙŠØ¹Ù…Ù„ Ø§Ù„Ø§Ù†"""
        elif creating_type == 'adhkar':
            asyncio.create_task(start_adhkar_bot(token, user_id))
            text = f"""â€» ØªÙ… Ø§Ù†Ø´Ø§Ø¡ Ø¨ÙˆØª Ø§Ù„Ø§Ø°ÙƒØ§Ø± Ø¨Ù†Ø¬Ø§Ø­

Ø§Ù„Ø¨ÙˆØª: @{bot_username}
Ø§Ù„Ù†ÙˆØ¹: Ø§Ø°ÙƒØ§Ø±
Ø§Ù„Ù…Ø§Ù„Ùƒ: {first_name}

Ø§Ù„Ø¨ÙˆØª ÙŠØ¹Ù…Ù„ Ø§Ù„Ø§Ù†"""
        elif creating_type == 'guard':
            asyncio.create_task(start_guard_bot(token, user_id))
            text = f"""â€» ØªÙ… Ø§Ù†Ø´Ø§Ø¡ Ø¨ÙˆØª Ù…Ù†Ø¹ Ø§Ù„ØªØµÙÙŠØ© Ø¨Ù†Ø¬Ø§Ø­

Ø§Ù„Ø¨ÙˆØª: @{bot_username}
Ø§Ù„Ù†ÙˆØ¹: Ø­Ù…Ø§ÙŠØ© Ù…Ù† Ø§Ù„ØªØµÙÙŠØ©
Ø§Ù„Ù…Ø§Ù„Ùƒ: {first_name}

Ø§Ù„Ø¨ÙˆØª ÙŠØ¹Ù…Ù„ Ø§Ù„Ø§Ù†"""
        elif creating_type == 'quiz':
            asyncio.create_task(start_quiz_bot(token, user_id))
            text = f"""â€» ØªÙ… Ø§Ù†Ø´Ø§Ø¡ Ø¨ÙˆØª Ø§Ù„ÙƒÙˆÙŠØ² Ø¨Ù†Ø¬Ø§Ø­

Ø§Ù„Ø¨ÙˆØª: @{bot_username}
Ø§Ù„Ù†ÙˆØ¹: ÙƒÙˆÙŠØ²
Ø§Ù„Ù…Ø§Ù„Ùƒ: {first_name}

Ø§Ù„Ø¨ÙˆØª ÙŠØ¹Ù…Ù„ Ø§Ù„Ø§Ù†"""
        elif creating_type == 'join':
            asyncio.create_task(start_join_request_bot(token, user_id))
            text = f"""â€» ØªÙ… Ø§Ù†Ø´Ø§Ø¡ Ø¨ÙˆØª Ù‚Ø¨ÙˆÙ„ Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù… Ø¨Ù†Ø¬Ø§Ø­

Ø§Ù„Ø¨ÙˆØª: @{bot_username}
Ø§Ù„Ù†ÙˆØ¹: Ù‚Ø¨ÙˆÙ„ Ø§Ù†Ø¶Ù…Ø§Ù…
Ø§Ù„Ù…Ø§Ù„Ùƒ: {first_name}

Ø§Ù„Ø¨ÙˆØª ÙŠØ¹Ù…Ù„ Ø§Ù„Ø§Ù†
Ø§Ø¶Ù Ø§Ù„Ø¨ÙˆØª ÙƒØ£Ø¯Ù…Ù† ÙÙŠ Ù‚Ù†Ø§ØªÙƒ Ø§Ùˆ Ù…Ø¬Ù…ÙˆØ¹ØªÙƒ"""
        elif creating_type == 'sticker':
            asyncio.create_task(start_sticker_bot(token, user_id))
            text = f"""â€» ØªÙ… Ø§Ù†Ø´Ø§Ø¡ Ø¨ÙˆØª Ø§Ù„Ø³ØªÙŠÙƒØ±Ø§Øª Ø¨Ù†Ø¬Ø§Ø­

Ø§Ù„Ø¨ÙˆØª: @{bot_username}
Ø§Ù„Ù†ÙˆØ¹: Ø³ØªÙŠÙƒØ±Ø§Øª
Ø§Ù„Ù…Ø§Ù„Ùƒ: {first_name}

Ø§Ù„Ø¨ÙˆØª ÙŠØ¹Ù…Ù„ Ø§Ù„Ø§Ù†
Ø§Ø±Ø³Ù„ Ø§ÙŠ ØµÙˆØ±Ø© Ù„ØªØ­ÙˆÙŠÙ„Ù‡Ø§ Ø§Ù„Ù‰ Ø³ØªÙŠÙƒØ±"""
        else:
            text = "Ù†ÙˆØ¹ Ø§Ù„Ø¨ÙˆØª ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ"
        
        notification_text = f"""ğŸ†• Ø¨ÙˆØª Ø¬Ø¯ÙŠØ¯!

â Ø§Ù„Ø¨ÙˆØª: @{bot_username}
â Ø§Ù„Ù†ÙˆØ¹: {bot_type_names.get(creating_type, 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')}
â Ø§Ù„Ù…Ø§Ù„Ùƒ: {first_name}
â Ø§Ù„Ø§ÙŠØ¯ÙŠ: {user_id}
â Ø§Ù„ÙŠÙˆØ²Ø±: @{user.username or 'Ù„Ø§ ÙŠÙˆØ¬Ø¯'}"""
        await send_developer_notification(context, notification_text)
        
        keyboard = [[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø©", callback_data="back_main")]]
        await message.reply_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
        user_states.pop(user_id, None)
        
    except Exception as e:
        logger.error(f"Error creating bot: {e}")
        log_error("Bot Creation", e, f"User: {user_id}, Type: {creating_type}")
        await message.reply_text("Ø­Ø¯Ø« Ø®Ø·Ø£ Ø§Ø«Ù†Ø§Ø¡ Ø§Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¨ÙˆØª\nØªØ£ÙƒØ¯ Ù…Ù† ØµØ­Ø© Ø§Ù„ØªÙˆÙƒÙ†")

def get_banned_maker_users():
    return db.get_all_banned_makers()

def save_banned_maker_users(data):
    pass

def is_developer_user(user_id: int, username: str = None) -> bool:
    """Check if user is a developer (main or added)"""
    if user_id == DEVELOPER_ID or username == DEVELOPER_USERNAME:
        return True
    return db.is_developer(user_id)

async def send_developer_notification(context, text):
    try:
        await context.bot.send_message(chat_id=DEVELOPER_ID, text=text)
        developers = db.get_all_developers()
        for dev in developers:
            try:
                await context.bot.send_message(chat_id=dev['user_id'], text=text)
            except:
                pass
    except:
        pass

async def developer_panel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    message = update.message
    if user is None or message is None:
        return
    
    if not is_developer_user(user.id, user.username):
        return
    
    stats = db.get_statistics()
    total_bots = stats['total_bots']
    active_bots = stats['active_bots']
    total_users = stats['total_members']
    total_messages = stats['total_messages']
    most_active_bot = stats['most_active_bot']
    
    developers_list = db.get_all_developers()
    devs_count = len(developers_list) + 1
    
    text = f"""â€» Ù„ÙˆØ­Ø© ØªØ­ÙƒÙ… Ø§Ù„Ù…Ø·ÙˆØ±

ğŸ“Š Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª:
â Ø¹Ø¯Ø¯ Ø§Ù„Ø¨ÙˆØªØ§Øª: {total_bots}
â Ø§Ù„Ø¨ÙˆØªØ§Øª Ø§Ù„Ù†Ø´Ø·Ø©: {active_bots}
â Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†: {total_users}
â Ø¹Ø¯Ø¯ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„: {total_messages}
â Ø£ÙƒØ«Ø± Ø¨ÙˆØª Ù†Ø´Ø§Ø·: @{most_active_bot or 'Ù„Ø§ ÙŠÙˆØ¬Ø¯'}
â Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø·ÙˆØ±ÙŠÙ†: {devs_count}

Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø¨ÙˆØªØ§Øª:"""
    
    bots_list = db.get_all_bots()
    keyboard = []
    for bot_data in bots_list:
        status = "ğŸŸ¢" if bot_data.get('active', True) else "ğŸ”´"
        bot_name = bot_data.get('bot_username', 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')
        bot_type_map = {'ai': 'Ø°ÙƒØ§Ø¡', 'adhkar': 'Ø§Ø°ÙƒØ§Ø±', 'guard': 'Ø­Ù…Ø§ÙŠØ©', 'quiz': 'ÙƒÙˆÙŠØ²', 'join_request': 'Ù‚Ø¨ÙˆÙ„', 'sticker': 'Ø³ØªÙŠÙƒØ±'}
        bot_type = bot_type_map.get(bot_data.get('bot_type', ''), 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')
        token = bot_data.get('token', '')
        keyboard.append([
            InlineKeyboardButton(
                f"{status} @{bot_name} - {bot_type}",
                callback_data=f"toggle_{token[:30]}"
            )
        ])
    
    keyboard.append([
        InlineKeyboardButton("Ø­Ø¸Ø± Ù…Ø³ØªØ®Ø¯Ù… ğŸš«", callback_data="dev_ban_user"),
        InlineKeyboardButton("ÙÙƒ Ø­Ø¸Ø± âœ…", callback_data="dev_unban_user")
    ])
    keyboard.append([InlineKeyboardButton("Ø§Ø°Ø§Ø¹Ø© Ù…ØªÙ‚Ø¯Ù…Ø© ğŸ“¢", callback_data="advanced_broadcast")])
    keyboard.append([InlineKeyboardButton("Ø§Ø°Ø§Ø¹Ø© Ù„Ù„Ø¬Ù…ÙŠØ¹ ğŸ“¢", callback_data="broadcast_all")])
    keyboard.append([
        InlineKeyboardButton("Ø¥Ø¶Ø§ÙØ© Ù…Ø·ÙˆØ± â•", callback_data="dev_add_developer"),
        InlineKeyboardButton("Ø¥Ø²Ø§Ù„Ø© Ù…Ø·ÙˆØ± â–", callback_data="dev_remove_developer")
    ])
    keyboard.append([InlineKeyboardButton("Ø§Ø´ØªØ±Ø§Ùƒ ÙˆÙ‡Ù…ÙŠ ğŸ“Œ", callback_data="dev_fake_sub")])
    
    await message.reply_text(text, reply_markup=InlineKeyboardMarkup(keyboard))

async def handle_developer_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    if query is None:
        return False
    
    user = query.from_user
    if user is None:
        return False
    
    if not is_developer_user(user.id, user.username):
        return False
    
    data = query.data
    
    if data.startswith("toggle_"):
        await query.answer()
        token_prefix = data.replace("toggle_", "")
        bots_data = get_bots_data()
        
        for token, bot_data in bots_data.items():
            if token.startswith(token_prefix):
                bot_data['active'] = not bot_data.get('active', True)
                save_bots_data(bots_data)
                
                bot_name = bot_data.get('bot_username', 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')
                owner_id = bot_data.get('owner_id')
                
                if bot_data['active']:
                    if bot_data['type'] == 'ai':
                        asyncio.create_task(start_ai_bot(token, owner_id))
                    elif bot_data['type'] == 'adhkar':
                        asyncio.create_task(start_adhkar_bot(token, owner_id))
                    elif bot_data['type'] == 'guard':
                        asyncio.create_task(start_guard_bot(token, owner_id))
                    await query.answer(f"ØªÙ… ØªØ´ØºÙŠÙ„ @{bot_name} âœ…", show_alert=True)
                else:
                    if token in running_bot_apps:
                        try:
                            await running_bot_apps[token].stop()
                            del running_bot_apps[token]
                        except:
                            pass
                    await query.answer(f"ØªÙ… Ø§ÙŠÙ‚Ø§Ù @{bot_name} â¸ï¸", show_alert=True)
                
                bots_data = get_bots_data()
                total_bots = len(bots_data)
                active_bots = sum(1 for b in bots_data.values() if b.get('active', True))
                member_data = get_member_data()
                total_users = len(member_data)
                remember_data = get_remember_data()
                total_messages = sum(len(msgs) for msgs in remember_data.values())
                
                most_active_bot = None
                max_users = 0
                for t, bd in bots_data.items():
                    users_count = bd.get('users_count', 0)
                    if users_count > max_users:
                        max_users = users_count
                        most_active_bot = bd.get('bot_username', 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')
                
                text = f"""â€» Ù„ÙˆØ­Ø© ØªØ­ÙƒÙ… Ø§Ù„Ù…Ø·ÙˆØ±

ğŸ“Š Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª:
â Ø¹Ø¯Ø¯ Ø§Ù„Ø¨ÙˆØªØ§Øª: {total_bots}
â Ø§Ù„Ø¨ÙˆØªØ§Øª Ø§Ù„Ù†Ø´Ø·Ø©: {active_bots}
â Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†: {total_users}
â Ø¹Ø¯Ø¯ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„: {total_messages}
â Ø£ÙƒØ«Ø± Ø¨ÙˆØª Ù†Ø´Ø§Ø·: @{most_active_bot or 'Ù„Ø§ ÙŠÙˆØ¬Ø¯'}

Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø¨ÙˆØªØ§Øª:"""
                
                keyboard = []
                for t, bd in bots_data.items():
                    status = "ğŸŸ¢" if bd.get('active', True) else "ğŸ”´"
                    bn = bd.get('bot_username', 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')
                    bot_type_map = {'ai': 'Ø°ÙƒØ§Ø¡', 'adhkar': 'Ø§Ø°ÙƒØ§Ø±', 'guard': 'Ø­Ù…Ø§ÙŠØ©'}
                    bt = bot_type_map.get(bd['type'], 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')
                    keyboard.append([
                        InlineKeyboardButton(
                            f"{status} @{bn} - {bt}",
                            callback_data=f"toggle_{t[:30]}"
                        )
                    ])
                
                keyboard.append([
                    InlineKeyboardButton("Ø­Ø¸Ø± Ù…Ø³ØªØ®Ø¯Ù… ğŸš«", callback_data="dev_ban_user"),
                    InlineKeyboardButton("ÙÙƒ Ø­Ø¸Ø± âœ…", callback_data="dev_unban_user")
                ])
                keyboard.append([InlineKeyboardButton("Ø§Ø°Ø§Ø¹Ø© Ù„Ù„Ø¬Ù…ÙŠØ¹ ğŸ“¢", callback_data="broadcast_all")])
                
                await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
                return True
        
        await query.answer("Ø§Ù„Ø¨ÙˆØª ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯", show_alert=True)
        return True
    
    if data == "dev_ban_user":
        await query.answer()
        user_states[user.id] = {'dev_banning': True}
        keyboard = [[InlineKeyboardButton("Ø§Ù„ØºØ§Ø¡", callback_data="dev_cancel")]]
        await query.edit_message_text(
            "â€» Ø­Ø¸Ø± Ù…Ø³ØªØ®Ø¯Ù… Ù…Ù† ØµÙ†Ø¹ Ø¨ÙˆØªØ§Øª\n\nØ§Ø±Ø³Ù„ Ø§ÙŠØ¯ÙŠ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…:",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return True
    
    if data == "dev_unban_user":
        await query.answer()
        banned = get_banned_maker_users()
        if not banned:
            await query.answer("Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ù…Ø­Ø¸ÙˆØ±ÙŠÙ†", show_alert=True)
            return True
        
        user_states[user.id] = {'dev_unbanning': True}
        keyboard = [[InlineKeyboardButton("Ø§Ù„ØºØ§Ø¡", callback_data="dev_cancel")]]
        text = "â€» ÙÙƒ Ø­Ø¸Ø± Ù…Ø³ØªØ®Ø¯Ù…\n\nØ§Ù„Ù…Ø­Ø¸ÙˆØ±ÙŠÙ†:\n"
        for uid in banned:
            text += f"- {uid}\n"
        text += "\nØ§Ø±Ø³Ù„ Ø§ÙŠØ¯ÙŠ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù„ÙÙƒ Ø­Ø¸Ø±Ù‡:"
        await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
        return True
    
    if data == "dev_cancel":
        await query.answer()
        user_states.pop(user.id, None)
        
        bots_data = get_bots_data()
        total_bots = len(bots_data)
        active_bots = sum(1 for b in bots_data.values() if b.get('active', True))
        member_data = get_member_data()
        total_users = len(member_data)
        remember_data = get_remember_data()
        total_messages = sum(len(msgs) for msgs in remember_data.values())
        
        most_active_bot = None
        max_users = 0
        for t, bd in bots_data.items():
            users_count = bd.get('users_count', 0)
            if users_count > max_users:
                max_users = users_count
                most_active_bot = bd.get('bot_username', 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')
        
        text = f"""â€» Ù„ÙˆØ­Ø© ØªØ­ÙƒÙ… Ø§Ù„Ù…Ø·ÙˆØ±

ğŸ“Š Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª:
â Ø¹Ø¯Ø¯ Ø§Ù„Ø¨ÙˆØªØ§Øª: {total_bots}
â Ø§Ù„Ø¨ÙˆØªØ§Øª Ø§Ù„Ù†Ø´Ø·Ø©: {active_bots}
â Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†: {total_users}
â Ø¹Ø¯Ø¯ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„: {total_messages}
â Ø£ÙƒØ«Ø± Ø¨ÙˆØª Ù†Ø´Ø§Ø·: @{most_active_bot or 'Ù„Ø§ ÙŠÙˆØ¬Ø¯'}

Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø¨ÙˆØªØ§Øª:"""
        
        keyboard = []
        for t, bd in bots_data.items():
            status = "ğŸŸ¢" if bd.get('active', True) else "ğŸ”´"
            bn = bd.get('bot_username', 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')
            bot_type_map = {'ai': 'Ø°ÙƒØ§Ø¡', 'adhkar': 'Ø§Ø°ÙƒØ§Ø±', 'guard': 'Ø­Ù…Ø§ÙŠØ©'}
            bt = bot_type_map.get(bd['type'], 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')
            keyboard.append([
                InlineKeyboardButton(
                    f"{status} @{bn} - {bt}",
                    callback_data=f"toggle_{t[:30]}"
                )
            ])
        
        keyboard.append([
            InlineKeyboardButton("Ø­Ø¸Ø± Ù…Ø³ØªØ®Ø¯Ù… ğŸš«", callback_data="dev_ban_user"),
            InlineKeyboardButton("ÙÙƒ Ø­Ø¸Ø± âœ…", callback_data="dev_unban_user")
        ])
        keyboard.append([InlineKeyboardButton("Ø§Ø°Ø§Ø¹Ø© Ù„Ù„Ø¬Ù…ÙŠØ¹ ğŸ“¢", callback_data="broadcast_all")])
        
        await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
        return True
    
    if data == "advanced_broadcast":
        await query.answer()
        bots_data = get_bots_data()
        
        keyboard = []
        for token, bot_data in bots_data.items():
            bot_name = bot_data.get('bot_username', 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')
            bot_type_map = {'ai': 'Ø°ÙƒØ§Ø¡', 'adhkar': 'Ø§Ø°ÙƒØ§Ø±', 'guard': 'Ø­Ù…Ø§ÙŠØ©', 'quiz': 'ÙƒÙˆÙŠØ²', 'join_request': 'Ù‚Ø¨ÙˆÙ„'}
            bot_type = bot_type_map.get(bot_data.get('type', ''), 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')
            keyboard.append([InlineKeyboardButton(
                f"ğŸ“Œ @{bot_name} - {bot_type}",
                callback_data=f"select_bot_{token[:25]}"
            )])
        
        keyboard.append([InlineKeyboardButton("Ø§Ø±Ø³Ø§Ù„ Ù„Ù„Ù…Ø­Ø¯Ø¯ÙŠÙ† ğŸ“¢", callback_data="send_selected")])
        keyboard.append([InlineKeyboardButton("Ø±Ø¬ÙˆØ¹", callback_data="dev_panel")])
        
        user_states[user.id] = {'selected_bots': []}
        await query.edit_message_text(
            "â€» Ø§Ø°Ø§Ø¹Ø© Ù…ØªÙ‚Ø¯Ù…Ø©\n\nØ§Ø®ØªØ± Ø§Ù„Ø¨ÙˆØªØ§Øª Ø§Ù„ØªÙŠ ØªØ±ÙŠØ¯ Ø§Ù„Ø§Ø±Ø³Ø§Ù„ Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ‡Ø§:",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return True
    
    if data.startswith("select_bot_"):
        await query.answer()
        token_prefix = data.replace("select_bot_", "")
        
        user_state = user_states.get(user.id, {})
        selected = user_state.get('selected_bots', [])
        
        if token_prefix in selected:
            selected.remove(token_prefix)
        else:
            selected.append(token_prefix)
        
        user_states[user.id] = {'selected_bots': selected}
        
        bots_data = get_bots_data()
        keyboard = []
        for token, bot_data in bots_data.items():
            bot_name = bot_data.get('bot_username', 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')
            bot_type_map = {'ai': 'Ø°ÙƒØ§Ø¡', 'adhkar': 'Ø§Ø°ÙƒØ§Ø±', 'guard': 'Ø­Ù…Ø§ÙŠØ©', 'quiz': 'ÙƒÙˆÙŠØ²', 'join_request': 'Ù‚Ø¨ÙˆÙ„'}
            bot_type = bot_type_map.get(bot_data.get('type', ''), 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')
            is_selected = "âœ…" if token[:25] in selected else "ğŸ“Œ"
            keyboard.append([InlineKeyboardButton(
                f"{is_selected} @{bot_name} - {bot_type}",
                callback_data=f"select_bot_{token[:25]}"
            )])
        
        keyboard.append([InlineKeyboardButton("Ø§Ø±Ø³Ø§Ù„ Ù„Ù„Ù…Ø­Ø¯Ø¯ÙŠÙ† ğŸ“¢", callback_data="send_selected")])
        keyboard.append([InlineKeyboardButton("Ø±Ø¬ÙˆØ¹", callback_data="dev_panel")])
        
        await query.edit_message_text(
            f"â€» Ø§Ø°Ø§Ø¹Ø© Ù…ØªÙ‚Ø¯Ù…Ø©\n\nØ§Ù„Ù…Ø­Ø¯Ø¯ÙŠÙ†: {len(selected)} Ø¨ÙˆØª",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return True
    
    if data == "send_selected":
        await query.answer()
        user_state = user_states.get(user.id, {})
        selected = user_state.get('selected_bots', [])
        
        if not selected:
            await query.answer("Ø§Ø®ØªØ± Ø¨ÙˆØª ÙˆØ§Ø­Ø¯ Ø¹Ù„Ù‰ Ø§Ù„Ø§Ù‚Ù„", show_alert=True)
            return True
        
        user_states[user.id] = {'advanced_broadcasting': True, 'selected_bots': selected}
        keyboard = [[InlineKeyboardButton("Ø§Ù„ØºØ§Ø¡", callback_data="dev_cancel")]]
        await query.edit_message_text(
            f"â€» Ø§Ø°Ø§Ø¹Ø© Ù…ØªÙ‚Ø¯Ù…Ø©\n\nØ³ÙŠØªÙ… Ø§Ù„Ø§Ø±Ø³Ø§Ù„ Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠ {len(selected)} Ø¨ÙˆØª\n\nØ§Ø±Ø³Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø©:",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return True
    
    if data == "dev_panel":
        bots_data = get_bots_data()
        total_bots = len(bots_data)
        active_bots = sum(1 for b in bots_data.values() if b.get('active', True))
        member_data = get_member_data()
        total_users = len(member_data)
        remember_data = get_remember_data()
        total_messages = sum(len(msgs) for msgs in remember_data.values())
        
        most_active_bot = None
        max_users = 0
        for token, bot_data in bots_data.items():
            users_count = bot_data.get('users_count', 0)
            if users_count > max_users:
                max_users = users_count
                most_active_bot = bot_data.get('bot_username', 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')
        
        text = f"""â€» Ù„ÙˆØ­Ø© ØªØ­ÙƒÙ… Ø§Ù„Ù…Ø·ÙˆØ±

ğŸ“Š Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª:
â Ø¹Ø¯Ø¯ Ø§Ù„Ø¨ÙˆØªØ§Øª: {total_bots}
â Ø§Ù„Ø¨ÙˆØªØ§Øª Ø§Ù„Ù†Ø´Ø·Ø©: {active_bots}
â Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†: {total_users}
â Ø¹Ø¯Ø¯ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„: {total_messages}
â Ø£ÙƒØ«Ø± Ø¨ÙˆØª Ù†Ø´Ø§Ø·: @{most_active_bot or 'Ù„Ø§ ÙŠÙˆØ¬Ø¯'}

Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø¨ÙˆØªØ§Øª:"""
        
        keyboard = []
        for token, bot_data in bots_data.items():
            status = "ğŸŸ¢" if bot_data.get('active', True) else "ğŸ”´"
            bot_name = bot_data.get('bot_username', 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')
            bot_type_map = {'ai': 'Ø°ÙƒØ§Ø¡', 'adhkar': 'Ø§Ø°ÙƒØ§Ø±', 'guard': 'Ø­Ù…Ø§ÙŠØ©', 'quiz': 'ÙƒÙˆÙŠØ²', 'join_request': 'Ù‚Ø¨ÙˆÙ„'}
            bot_type = bot_type_map.get(bot_data.get('type', ''), 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')
            keyboard.append([InlineKeyboardButton(
                f"{status} @{bot_name} - {bot_type}",
                callback_data=f"toggle_{token[:30]}"
            )])
        
        keyboard.append([
            InlineKeyboardButton("Ø­Ø¸Ø± Ù…Ø³ØªØ®Ø¯Ù… ğŸš«", callback_data="dev_ban_user"),
            InlineKeyboardButton("ÙÙƒ Ø­Ø¸Ø± âœ…", callback_data="dev_unban_user")
        ])
        keyboard.append([InlineKeyboardButton("Ø§Ø°Ø§Ø¹Ø© Ù…ØªÙ‚Ø¯Ù…Ø© ğŸ“¢", callback_data="advanced_broadcast")])
        keyboard.append([InlineKeyboardButton("Ø§Ø°Ø§Ø¹Ø© Ù„Ù„Ø¬Ù…ÙŠØ¹ ğŸ“¢", callback_data="broadcast_all")])
        
        await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
        return True
    
    if data == "broadcast_all":
        await query.answer()
        user_states[user.id] = {'dev_broadcasting': True}
        keyboard = [[InlineKeyboardButton("Ø§Ù„ØºØ§Ø¡", callback_data="dev_cancel")]]
        await query.edit_message_text(
            "â€» Ø§Ø°Ø§Ø¹Ø© Ù„Ù„Ø¬Ù…ÙŠØ¹\n\nØ§Ø±Ø³Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„ØªÙŠ ØªØ±ÙŠØ¯ Ø§Ø±Ø³Ø§Ù„Ù‡Ø§ Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†:",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return True
    
    if data == "dev_add_developer":
        await query.answer()
        user_states[user.id] = {'adding_developer': True}
        keyboard = [[InlineKeyboardButton("Ø§Ù„ØºØ§Ø¡", callback_data="dev_panel")]]
        await query.edit_message_text(
            "â€» Ø¥Ø¶Ø§ÙØ© Ù…Ø·ÙˆØ± Ø¬Ø¯ÙŠØ¯\n\nØ§Ø±Ø³Ù„ Ø§ÙŠØ¯ÙŠ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø°ÙŠ ØªØ±ÙŠØ¯ Ø¥Ø¶Ø§ÙØªÙ‡ ÙƒÙ…Ø·ÙˆØ±:",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return True
    
    if data == "dev_remove_developer":
        await query.answer()
        developers = db.get_all_developers()
        if not developers:
            await query.answer("Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ø·ÙˆØ±ÙŠÙ† Ù…Ø¶Ø§ÙÙŠÙ†", show_alert=True)
            return True
        
        keyboard = []
        for dev in developers:
            dev_id = dev['user_id']
            dev_username = dev.get('username', 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')
            keyboard.append([InlineKeyboardButton(
                f"âŒ {dev_id} - @{dev_username}",
                callback_data=f"remove_dev_{dev_id}"
            )])
        keyboard.append([InlineKeyboardButton("Ø±Ø¬ÙˆØ¹", callback_data="dev_panel")])
        await query.edit_message_text(
            "â€» Ø¥Ø²Ø§Ù„Ø© Ù…Ø·ÙˆØ±\n\nØ§Ø®ØªØ± Ø§Ù„Ù…Ø·ÙˆØ± Ø§Ù„Ø°ÙŠ ØªØ±ÙŠØ¯ Ø¥Ø²Ø§Ù„ØªÙ‡:",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return True
    
    if data.startswith("remove_dev_"):
        await query.answer()
        dev_id = int(data.replace("remove_dev_", ""))
        if db.remove_developer(dev_id):
            await query.answer(f"âœ… ØªÙ… Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ù…Ø·ÙˆØ± {dev_id}", show_alert=True)
        else:
            await query.answer("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£", show_alert=True)
        keyboard = [[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ Ù„Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ…", callback_data="dev_panel")]]
        await query.edit_message_text("ØªÙ… Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ù…Ø·ÙˆØ±", reply_markup=InlineKeyboardMarkup(keyboard))
        return True
    
    if data == "dev_fake_sub":
        await query.answer()
        bots_list = db.get_all_bots()
        keyboard = []
        for bot_data in bots_list:
            bot_name = bot_data.get('bot_username', 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')
            token = bot_data.get('token', '')
            fake_sub = db.get_fake_sub(token)
            status = "âœ…" if fake_sub and fake_sub.get('enabled') else "âŒ"
            keyboard.append([InlineKeyboardButton(
                f"{status} @{bot_name}",
                callback_data=f"fake_sub_{token[:25]}"
            )])
        keyboard.append([InlineKeyboardButton("Ø±Ø¬ÙˆØ¹", callback_data="dev_panel")])
        await query.edit_message_text(
            "â€» Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø§Ù„ÙˆÙ‡Ù…ÙŠ\n\nØ§Ø®ØªØ± Ø§Ù„Ø¨ÙˆØª Ù„ØªÙØ¹ÙŠÙ„/ØªØ¹Ø·ÙŠÙ„ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø§Ù„ÙˆÙ‡Ù…ÙŠ:",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return True
    
    if data.startswith("fake_sub_"):
        await query.answer()
        token_prefix = data.replace("fake_sub_", "")
        bots_list = db.get_all_bots()
        selected_bot = None
        for bot in bots_list:
            if bot['token'].startswith(token_prefix):
                selected_bot = bot
                break
        
        if selected_bot:
            user_states[user.id] = {'setting_fake_sub': True, 'fake_sub_token': selected_bot['token']}
            fake_sub = db.get_fake_sub(selected_bot['token'])
            current_msg = fake_sub.get('message', 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯') if fake_sub else 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯'
            status = "Ù…ÙØ¹Ù„ âœ…" if fake_sub and fake_sub.get('enabled') else "Ù…Ø¹Ø·Ù„ âŒ"
            keyboard = [
                [InlineKeyboardButton("ØªÙØ¹ÙŠÙ„/ØªØ¹Ø·ÙŠÙ„", callback_data=f"toggle_fake_{selected_bot['token'][:25]}")],
                [InlineKeyboardButton("ØªØºÙŠÙŠØ± Ø§Ù„Ø±Ø³Ø§Ù„Ø©", callback_data=f"change_fake_msg_{selected_bot['token'][:25]}")],
                [InlineKeyboardButton("Ø±Ø¬ÙˆØ¹", callback_data="dev_fake_sub")]
            ]
            await query.edit_message_text(
                f"â€» Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø§Ù„ÙˆÙ‡Ù…ÙŠ - @{selected_bot['bot_username']}\n\nØ§Ù„Ø­Ø§Ù„Ø©: {status}\nØ§Ù„Ø±Ø³Ø§Ù„Ø©: {current_msg}",
                reply_markup=InlineKeyboardMarkup(keyboard)
            )
        return True
    
    if data.startswith("toggle_fake_"):
        await query.answer()
        token_prefix = data.replace("toggle_fake_", "")
        bots_list = db.get_all_bots()
        for bot in bots_list:
            if bot['token'].startswith(token_prefix):
                fake_sub = db.get_fake_sub(bot['token'])
                new_enabled = not (fake_sub and fake_sub.get('enabled'))
                current_msg = fake_sub.get('message', 'Ù‚Ù… Ø¨Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù… Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¨ÙˆØª') if fake_sub else 'Ù‚Ù… Ø¨Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù… Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¨ÙˆØª'
                db.set_fake_sub(bot['token'], new_enabled, current_msg)
                status = "ØªÙ… Ø§Ù„ØªÙØ¹ÙŠÙ„ âœ…" if new_enabled else "ØªÙ… Ø§Ù„ØªØ¹Ø·ÙŠÙ„ âŒ"
                await query.answer(status, show_alert=True)
                break
        return True
    
    if data.startswith("change_fake_msg_"):
        await query.answer()
        token_prefix = data.replace("change_fake_msg_", "")
        bots_list = db.get_all_bots()
        for bot in bots_list:
            if bot['token'].startswith(token_prefix):
                user_states[user.id] = {'changing_fake_msg': True, 'fake_sub_token': bot['token']}
                keyboard = [[InlineKeyboardButton("Ø§Ù„ØºØ§Ø¡", callback_data="dev_fake_sub")]]
                await query.edit_message_text(
                    "â€» ØªØºÙŠÙŠØ± Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø§Ù„ÙˆÙ‡Ù…ÙŠ\n\nØ§Ø±Ø³Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©:",
                    reply_markup=InlineKeyboardMarkup(keyboard)
                )
                break
        return True
    
    return False

async def handle_developer_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    message = update.message
    if user is None or message is None:
        return False
    
    if not is_developer_user(user.id, user.username):
        return False
    
    user_state = user_states.get(user.id, {})
    
    if user_state.get('dev_banning'):
        try:
            ban_id = int(message.text.strip())
            if not db.is_maker_banned(ban_id):
                db.ban_maker(ban_id, user.id)
                await message.reply_text(f"âœ… ØªÙ… Ø­Ø¸Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… {ban_id} Ù…Ù† ØµÙ†Ø¹ Ø¨ÙˆØªØ§Øª")
            else:
                await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø­Ø¸ÙˆØ± Ø¨Ø§Ù„ÙØ¹Ù„")
        except ValueError:
            await message.reply_text("Ø§Ø±Ø³Ù„ Ø§ÙŠØ¯ÙŠ ØµØ­ÙŠØ­")
        user_states.pop(user.id, None)
        return True
    
    if user_state.get('dev_unbanning'):
        try:
            unban_id = int(message.text.strip())
            if db.is_maker_banned(unban_id):
                db.unban_maker(unban_id)
                await message.reply_text(f"âœ… ØªÙ… ÙÙƒ Ø­Ø¸Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… {unban_id}")
            else:
                await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ØºÙŠØ± Ù…Ø­Ø¸ÙˆØ±")
        except ValueError:
            await message.reply_text("Ø§Ø±Ø³Ù„ Ø§ÙŠØ¯ÙŠ ØµØ­ÙŠØ­")
        user_states.pop(user.id, None)
        return True
    
    if user_state.get('adding_developer'):
        try:
            dev_id = int(message.text.strip())
            if db.is_developer(dev_id):
                await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø·ÙˆØ± Ø¨Ø§Ù„ÙØ¹Ù„")
            else:
                db.add_developer(dev_id, None, user.id)
                await message.reply_text(f"âœ… ØªÙ… Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø·ÙˆØ± {dev_id}")
                log_main(f"New developer added: {dev_id} by {user.id}")
        except ValueError:
            await message.reply_text("Ø§Ø±Ø³Ù„ Ø§ÙŠØ¯ÙŠ ØµØ­ÙŠØ­")
        user_states.pop(user.id, None)
        return True
    
    if user_state.get('changing_fake_msg'):
        token = user_state.get('fake_sub_token')
        if token:
            fake_sub = db.get_fake_sub(token)
            enabled = fake_sub.get('enabled', False) if fake_sub else False
            db.set_fake_sub(token, enabled, message.text)
            await message.reply_text("âœ… ØªÙ… ØªØºÙŠÙŠØ± Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø¨Ù†Ø¬Ø§Ø­")
        user_states.pop(user.id, None)
        return True
    
    if user_state.get('dev_broadcasting'):
        members = db.get_all_members()
        success = 0
        failed = 0
        for member in members:
            try:
                await context.bot.send_message(chat_id=member['user_id'], text=message.text)
                success += 1
            except:
                failed += 1
        await message.reply_text(f"âœ… ØªÙ… Ø§Ù„Ø¥Ø±Ø³Ø§Ù„\nÙ†Ø¬Ø­: {success}\nÙØ´Ù„: {failed}")
        log_broadcast("Main Bot", success, failed)
        user_states.pop(user.id, None)
        return True
    
    if user_state.get('advanced_broadcasting'):
        selected_bots = user_state.get('selected_bots', [])
        bots_list = db.get_all_bots()
        
        total_success = 0
        total_failed = 0
        for bot_data in bots_list:
            token = bot_data.get('token', '')
            if token[:25] in selected_bots:
                bot_users = db.get_bot_users(token)
                try:
                    child_bot = Bot(token=token)
                    for bot_user in bot_users:
                        if not bot_user.get('banned'):
                            try:
                                await child_bot.send_message(chat_id=bot_user['user_id'], text=message.text)
                                total_success += 1
                            except:
                                total_failed += 1
                    log_broadcast("Advanced", total_success, total_failed, bot_data.get('bot_username'))
                except Exception as e:
                    log_error("Advanced Broadcast", e, f"Token: {token[:20]}...")
        
        await message.reply_text(f"âœ… ØªÙ… Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ Ù…Ù† Ø§Ù„Ø¨ÙˆØªØ§Øª Ø§Ù„ÙØ±Ø¹ÙŠØ©\nÙ†Ø¬Ø­: {total_success}\nÙØ´Ù„: {total_failed}")
        user_states.pop(user.id, None)
        return True
    
    return False

async def start_ai_bot(token: str, owner_id: int):
    try:
        app = Application.builder().token(token).build()
        ai_user_states = {}
        
        async def ai_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
            user = update.effective_user
            message = update.message
            if user is None or message is None:
                return
            first_name = user.first_name or "ØµØ¯ÙŠÙ‚ÙŠ"
            
            bots_data = get_bots_data()
            bot_data = bots_data.get(token, {})
            owner_name = bot_data.get('owner_name', DEVELOPER_USERNAME)
            
            bots_data[token]['users_count'] = bots_data[token].get('users_count', 0) + 1
            save_bots_data(bots_data)
            
            if user.id == owner_id:
                keyboard = [
                    [
                        InlineKeyboardButton("Ø§Ù„Ø§Ø­ØµØ§Ø¦ÙŠØ§Øª ğŸ‘¥", callback_data="ai_stats"),
                        InlineKeyboardButton("Ù„ÙˆØ­Ø© Ø§Ù„Ø§Ø¯Ù…Ù† ğŸ–ï¸", callback_data="admin_panel")
                    ],
                    [
                        InlineKeyboardButton("Ø­Ø¸Ø± Ù…Ø³ØªØ®Ø¯Ù… âŒ", callback_data="ban_user"),
                        InlineKeyboardButton("ÙÙƒ Ø­Ø¸Ø± Ù…Ø³ØªØ®Ø¯Ù… âœ…", callback_data="unban_user")
                    ],
                    [InlineKeyboardButton("Ø§Ø°Ø§Ø¹Ù‡ Ù„Ù„ÙƒÙ„", callback_data="broadcast")]
                ]
                
                text = f"""â€» Ø§Ù‡Ù„Ø§ ÙˆØ³Ù‡Ù„Ø§ ÙŠØ§ {first_name}

â Ø§ÙØ¶Ù„ Ø¨ÙˆØª Ø°ÙƒØ§Ø¡ Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ù…ØªÙƒØ§Ù…Ù„ ğŸŒ
â ØªÙ‚Ø¯Ø± ØªØ³ØªØ®Ø¯Ù…Ù†ÙŠ Ø¨Ø¯ÙˆÙ† Ø­Ø¯ÙˆØ¯
â Ø³Ø±Ø¹Ù‡ Ø§Ù„Ù‚ØµÙˆÙŠ ÙˆØ§Ø¯Ø§Ø¡ Ù…Ù…ØªØ§Ø² ğŸ›¸
â Ø§Ù„Ù…Ø·ÙˆØ± @{DEVELOPER_USERNAME}"""
            else:
                keyboard = []
                
                text = f"""â€» Ø§Ù‡Ù„Ø§ ÙˆØ³Ù‡Ù„Ø§ ÙŠØ§ {first_name}

â Ø§ÙØ¶Ù„ Ø¨ÙˆØª Ø°ÙƒØ§Ø¡ Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ù…ØªÙƒØ§Ù…Ù„ ğŸª©
â ØªÙ‚Ø¯Ø± ØªØ³ØªØ®Ø¯Ù…Ù†ÙŠ Ø¨Ø¯ÙˆÙ† Ø­Ø¯ÙˆØ¯
â Ø³Ø±Ø¹Ù‡ Ø§Ù„Ù‚ØµÙˆÙŠ ÙˆØ§Ø¯Ø§Ø¡ Ù…Ù…ØªØ§Ø² ğŸ›¸
â Ø§Ù„Ù…Ø·ÙˆØ± {owner_name}
â Ø§Ù†Ø§ Ø§Ù„Ù…Ù†Ø§ÙØ³ Ø§Ù„ÙˆØ­ÙŠØ¯ Ø§Ù„Ù‚ÙˆÙŠ Ù‡Ù†Ø§ ğŸ†"""
            
            await message.reply_text(text, reply_markup=InlineKeyboardMarkup(keyboard) if keyboard else None)
        
        async def ai_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
            user = update.effective_user
            message = update.message
            if user is None or message is None or message.text is None:
                return
            user_id = str(user.id)
            message_text = message.text
            
            user_state = ai_user_states.get(user.id, {})
            
            if user_state.get('banning') and user.id == owner_id:
                try:
                    ban_id = int(message_text.strip())
                    banned_data = get_banned_users_data()
                    bot_key = f"ai_{token[:20]}"
                    if bot_key not in banned_data:
                        banned_data[bot_key] = []
                    if ban_id not in banned_data[bot_key]:
                        banned_data[bot_key].append(ban_id)
                        save_banned_users_data(banned_data)
                        await message.reply_text(f"âœ… ØªÙ… Ø­Ø¸Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… {ban_id} Ø¨Ù†Ø¬Ø§Ø­")
                    else:
                        await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø­Ø¸ÙˆØ± Ø¨Ø§Ù„ÙØ¹Ù„")
                except ValueError:
                    await message.reply_text("Ø§Ø±Ø³Ù„ Ø§ÙŠØ¯ÙŠ ØµØ­ÙŠØ­")
                ai_user_states.pop(user.id, None)
                return
            
            if user_state.get('unbanning') and user.id == owner_id:
                try:
                    unban_id = int(message_text.strip())
                    banned_data = get_banned_users_data()
                    bot_key = f"ai_{token[:20]}"
                    if bot_key in banned_data and unban_id in banned_data[bot_key]:
                        banned_data[bot_key].remove(unban_id)
                        save_banned_users_data(banned_data)
                        await message.reply_text(f"âœ… ØªÙ… ÙÙƒ Ø­Ø¸Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… {unban_id} Ø¨Ù†Ø¬Ø§Ø­")
                    else:
                        await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ØºÙŠØ± Ù…Ø­Ø¸ÙˆØ±")
                except ValueError:
                    await message.reply_text("Ø§Ø±Ø³Ù„ Ø§ÙŠØ¯ÙŠ ØµØ­ÙŠØ­")
                ai_user_states.pop(user.id, None)
                return
            
            if user_state.get('broadcasting') and user.id == owner_id:
                remember_data = get_remember_data()
                success = 0
                failed = 0
                for uid in remember_data.keys():
                    try:
                        await context.bot.send_message(chat_id=int(uid), text=message_text)
                        success += 1
                    except:
                        failed += 1
                await message.reply_text(f"âœ… ØªÙ… Ø§Ù„Ø§Ø±Ø³Ø§Ù„\nÙ†Ø¬Ø­: {success}\nÙØ´Ù„: {failed}")
                ai_user_states.pop(user.id, None)
                return
            
            if user_state.get('changing_channel') and user.id == owner_id:
                new_channel = message_text.strip()
                if new_channel.startswith('@'):
                    bots_data = get_bots_data()
                    if token in bots_data:
                        bots_data[token]['required_channel'] = new_channel
                        save_bots_data(bots_data)
                        await message.reply_text(f"âœ… ØªÙ… ØªØºÙŠÙŠØ± Ù‚Ù†Ø§Ø© Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø§Ù„Ù‰ {new_channel}")
                    else:
                        await message.reply_text("Ø­Ø¯Ø« Ø®Ø·Ø£")
                else:
                    await message.reply_text("Ø§Ø±Ø³Ù„ ÙŠÙˆØ²Ø± Ø§Ù„Ù‚Ù†Ø§Ø© Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­ Ù…Ø«Ø§Ù„: @ChannelName")
                ai_user_states.pop(user.id, None)
                return
            
            banned_data = get_banned_users_data()
            bot_key = f"ai_{token[:20]}"
            if bot_key in banned_data and user.id in banned_data[bot_key]:
                await message.reply_text("â›” Ø§Ù†Øª Ù…Ø­Ø¸ÙˆØ± Ù…Ù† Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù‡Ø°Ø§ Ø§Ù„Ø¨ÙˆØª")
                return
            
            if not GROQ_API_KEY:
                await message.reply_text("Ø¹Ø°Ø±Ø§ØŒ Ø®Ø¯Ù…Ø© Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ ØºÙŠØ± Ù…ØªØ§Ø­Ø© Ø­Ø§Ù„ÙŠØ§")
                return
            
            try:
                remember_data = get_remember_data()
                if user_id not in remember_data:
                    remember_data[user_id] = []
                
                remember_data[user_id].append({
                    "role": "user",
                    "content": message_text
                })
                
                if len(remember_data[user_id]) > 20:
                    remember_data[user_id] = remember_data[user_id][-20:]
                
                client = Groq(api_key=GROQ_API_KEY)
                
                messages = [
                    {"role": "system", "content": "Ø§Ù†Øª Ù…Ø³Ø§Ø¹Ø¯ Ø°ÙƒÙŠ ÙˆÙ…ÙÙŠØ¯. Ø§Ø¬Ø¨ Ø¨Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ø¨Ù„Ù‡Ø¬Ø© Ù…ØµØ±ÙŠØ© ÙˆØ§Ø±Ø¯Ù†ÙŠØ© Ù…Ø®ØªÙ„Ø·Ø©. ÙƒÙ† ÙˆØ¯ÙˆØ¯Ø§ ÙˆÙ…Ø³Ø§Ø¹Ø¯Ø§."}
                ]
                messages.extend(remember_data[user_id])
                
                response = client.chat.completions.create(
                    model="llama-3.3-70b-versatile",
                    messages=messages,
                    max_tokens=1024,
                    temperature=0.7
                )
                
                ai_response = response.choices[0].message.content or "Ø¹Ø°Ø±Ø§ØŒ Ù„Ù… Ø§Ø³ØªØ·Ø¹ Ø§Ù„Ø±Ø¯"
                
                remember_data[user_id].append({
                    "role": "assistant",
                    "content": ai_response
                })
                save_remember_data(remember_data)
                
                await message.reply_text(ai_response)
                
            except Exception as e:
                logger.error(f"AI Error: {e}")
                await message.reply_text("Ø­Ø¯Ø« Ø®Ø·Ø£ØŒ Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø§Ø®Ø±Ù‰")
        
        async def ai_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
            query = update.callback_query
            if query is None:
                return
            await query.answer()
            user = query.from_user
            if user is None:
                return
            data = query.data
            
            if data == "check_sub_ai":
                try:
                    is_subscribed = await check_subscription(user.id, context.bot)
                except:
                    is_subscribed = True
                
                if is_subscribed:
                    first_name = user.first_name or "ØµØ¯ÙŠÙ‚ÙŠ"
                    bots_data = get_bots_data()
                    bot_data = bots_data.get(token, {})
                    owner_name = bot_data.get('owner_name', DEVELOPER_USERNAME)
                    
                    if user.id == owner_id:
                        keyboard = [
                            [
                                InlineKeyboardButton("Ø§Ù„Ø§Ø­ØµØ§Ø¦ÙŠØ§Øª ğŸ‘¥", callback_data="ai_stats"),
                                InlineKeyboardButton("Ù„ÙˆØ­Ø© Ø§Ù„Ø§Ø¯Ù…Ù† ğŸ–ï¸", callback_data="admin_panel")
                            ],
                            [
                                InlineKeyboardButton("Ø­Ø¸Ø± Ù…Ø³ØªØ®Ø¯Ù… âŒ", callback_data="ban_user"),
                                InlineKeyboardButton("ÙÙƒ Ø­Ø¸Ø± Ù…Ø³ØªØ®Ø¯Ù… âœ…", callback_data="unban_user")
                            ],
                            [InlineKeyboardButton("Ø§Ø°Ø§Ø¹Ù‡ Ù„Ù„ÙƒÙ„", callback_data="broadcast")]
                        ]
                        
                        text = f"""â€» Ø§Ù‡Ù„Ø§ ÙˆØ³Ù‡Ù„Ø§ ÙŠØ§ {first_name}

â Ø§ÙØ¶Ù„ Ø¨ÙˆØª Ø°ÙƒØ§Ø¡ Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ù…ØªÙƒØ§Ù…Ù„ ğŸŒ
â ØªÙ‚Ø¯Ø± ØªØ³ØªØ®Ø¯Ù…Ù†ÙŠ Ø¨Ø¯ÙˆÙ† Ø­Ø¯ÙˆØ¯
â Ø³Ø±Ø¹Ù‡ Ø§Ù„Ù‚ØµÙˆÙŠ ÙˆØ§Ø¯Ø§Ø¡ Ù…Ù…ØªØ§Ø² ğŸ›¸
â Ø§Ù„Ù…Ø·ÙˆØ± @{DEVELOPER_USERNAME}"""
                    else:
                        keyboard = []
                        
                        text = f"""â€» Ø§Ù‡Ù„Ø§ ÙˆØ³Ù‡Ù„Ø§ ÙŠØ§ {first_name}

â Ø§ÙØ¶Ù„ Ø¨ÙˆØª Ø°ÙƒØ§Ø¡ Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ù…ØªÙƒØ§Ù…Ù„ ğŸª©
â ØªÙ‚Ø¯Ø± ØªØ³ØªØ®Ø¯Ù…Ù†ÙŠ Ø¨Ø¯ÙˆÙ† Ø­Ø¯ÙˆØ¯
â Ø³Ø±Ø¹Ù‡ Ø§Ù„Ù‚ØµÙˆÙŠ ÙˆØ§Ø¯Ø§Ø¡ Ù…Ù…ØªØ§Ø² ğŸ›¸
â Ø§Ù„Ù…Ø·ÙˆØ± {owner_name}
â Ø§Ù†Ø§ Ø§Ù„Ù…Ù†Ø§ÙØ³ Ø§Ù„ÙˆØ­ÙŠØ¯ Ø§Ù„Ù‚ÙˆÙŠ Ù‡Ù†Ø§ ğŸ†"""
                    
                    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard) if keyboard else None)
                else:
                    await query.answer("Ø§Ø´ØªØ±Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø© Ø§ÙˆÙ„Ø§", show_alert=True)
                return
            
            if data == "admin_panel":
                if user.id != owner_id:
                    await query.answer("Ù„ÙˆØ­Ø© Ø§Ù„Ø§Ø¯Ù…Ù† Ù„Ù„Ù…Ø§Ù„Ùƒ ÙÙ‚Ø·", show_alert=True)
                    return
                
                keyboard = [
                    [InlineKeyboardButton("Ø§Ø°Ø§Ø¹Ø© Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†", callback_data="broadcast")],
                    [InlineKeyboardButton("ØªØºÙŠÙŠØ± Ù‚Ù†Ø§Ø© Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ", callback_data="change_channel")],
                    [InlineKeyboardButton("Ø±Ø¬ÙˆØ¹", callback_data="back_ai")]
                ]
                await query.edit_message_text(
                    "â€» Ù„ÙˆØ­Ø© Ø§Ù„Ø§Ø¯Ù…Ù†\n\nØ§Ø®ØªØ± Ù…Ù† Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©",
                    reply_markup=InlineKeyboardMarkup(keyboard)
                )
                return
            
            if data == "ai_stats":
                remember_data = get_remember_data()
                total_messages = sum(len(msgs) for msgs in remember_data.values())
                total_users = len(remember_data)
                
                text = f"""â€» Ø§Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø¨ÙˆØª

Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†: {total_users}
Ø¹Ø¯Ø¯ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„: {total_messages}"""
                
                keyboard = [[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹", callback_data="back_ai")]]
                await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
                return
            
            if data == "back_ai":
                first_name = user.first_name or "ØµØ¯ÙŠÙ‚ÙŠ"
                bots_data = get_bots_data()
                bot_data = bots_data.get(token, {})
                owner_name = bot_data.get('owner_name', DEVELOPER_USERNAME)
                
                if user.id == owner_id:
                    keyboard = [
                        [
                            InlineKeyboardButton("Ø§Ù„Ø§Ø­ØµØ§Ø¦ÙŠØ§Øª ğŸ‘¥", callback_data="ai_stats"),
                            InlineKeyboardButton("Ù„ÙˆØ­Ø© Ø§Ù„Ø§Ø¯Ù…Ù† ğŸ–ï¸", callback_data="admin_panel")
                        ],
                        [
                            InlineKeyboardButton("Ø­Ø¸Ø± Ù…Ø³ØªØ®Ø¯Ù… âŒ", callback_data="ban_user"),
                            InlineKeyboardButton("ÙÙƒ Ø­Ø¸Ø± Ù…Ø³ØªØ®Ø¯Ù… âœ…", callback_data="unban_user")
                        ],
                        [InlineKeyboardButton("Ø§Ø°Ø§Ø¹Ù‡ Ù„Ù„ÙƒÙ„", callback_data="broadcast")]
                    ]
                    
                    text = f"""â€» Ø§Ù‡Ù„Ø§ ÙˆØ³Ù‡Ù„Ø§ ÙŠØ§ {first_name}

â Ø§ÙØ¶Ù„ Ø¨ÙˆØª Ø°ÙƒØ§Ø¡ Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ù…ØªÙƒØ§Ù…Ù„ ğŸŒ
â ØªÙ‚Ø¯Ø± ØªØ³ØªØ®Ø¯Ù…Ù†ÙŠ Ø¨Ø¯ÙˆÙ† Ø­Ø¯ÙˆØ¯
â Ø³Ø±Ø¹Ù‡ Ø§Ù„Ù‚ØµÙˆÙŠ ÙˆØ§Ø¯Ø§Ø¡ Ù…Ù…ØªØ§Ø² ğŸ›¸
â Ø§Ù„Ù…Ø·ÙˆØ± @{DEVELOPER_USERNAME}"""
                else:
                    keyboard = []
                    
                    text = f"""â€» Ø§Ù‡Ù„Ø§ ÙˆØ³Ù‡Ù„Ø§ ÙŠØ§ {first_name}

â Ø§ÙØ¶Ù„ Ø¨ÙˆØª Ø°ÙƒØ§Ø¡ Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ù…ØªÙƒØ§Ù…Ù„ ğŸª©
â ØªÙ‚Ø¯Ø± ØªØ³ØªØ®Ø¯Ù…Ù†ÙŠ Ø¨Ø¯ÙˆÙ† Ø­Ø¯ÙˆØ¯
â Ø³Ø±Ø¹Ù‡ Ø§Ù„Ù‚ØµÙˆÙŠ ÙˆØ§Ø¯Ø§Ø¡ Ù…Ù…ØªØ§Ø² ğŸ›¸
â Ø§Ù„Ù…Ø·ÙˆØ± {owner_name}
â Ø§Ù†Ø§ Ø§Ù„Ù…Ù†Ø§ÙØ³ Ø§Ù„ÙˆØ­ÙŠØ¯ Ø§Ù„Ù‚ÙˆÙŠ Ù‡Ù†Ø§ ğŸ†"""
                
                ai_user_states.pop(user.id, None)
                await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard) if keyboard else None)
                return
            
            if data == "ban_user":
                if user.id != owner_id:
                    await query.answer("Ù„Ù„Ù…Ø§Ù„Ùƒ ÙÙ‚Ø·", show_alert=True)
                    return
                ai_user_states[user.id] = {'banning': True}
                keyboard = [[InlineKeyboardButton("Ø§Ù„ØºØ§Ø¡", callback_data="back_ai")]]
                await query.edit_message_text(
                    "â€» Ø­Ø¸Ø± Ù…Ø³ØªØ®Ø¯Ù…\n\nØ§Ø±Ø³Ù„ Ø§ÙŠØ¯ÙŠ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø°ÙŠ ØªØ±ÙŠØ¯ Ø­Ø¸Ø±Ù‡",
                    reply_markup=InlineKeyboardMarkup(keyboard)
                )
                return
            
            if data == "unban_user":
                if user.id != owner_id:
                    await query.answer("Ù„Ù„Ù…Ø§Ù„Ùƒ ÙÙ‚Ø·", show_alert=True)
                    return
                ai_user_states[user.id] = {'unbanning': True}
                keyboard = [[InlineKeyboardButton("Ø§Ù„ØºØ§Ø¡", callback_data="back_ai")]]
                await query.edit_message_text(
                    "â€» ÙÙƒ Ø­Ø¸Ø± Ù…Ø³ØªØ®Ø¯Ù…\n\nØ§Ø±Ø³Ù„ Ø§ÙŠØ¯ÙŠ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø°ÙŠ ØªØ±ÙŠØ¯ ÙÙƒ Ø­Ø¸Ø±Ù‡",
                    reply_markup=InlineKeyboardMarkup(keyboard)
                )
                return
            
            if data == "broadcast":
                if user.id != owner_id:
                    await query.answer("Ù„Ù„Ù…Ø§Ù„Ùƒ ÙÙ‚Ø·", show_alert=True)
                    return
                ai_user_states[user.id] = {'broadcasting': True}
                keyboard = [[InlineKeyboardButton("Ø§Ù„ØºØ§Ø¡", callback_data="cancel_broadcast")]]
                await query.edit_message_text(
                    "Ø§Ø±Ø³Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù„ÙŠ Ø¹Ø§ÙŠØ² ØªØ°ÙŠØ¹Ù‡Ø§ Ù„Ù„Ø¬Ù…ÙŠØ¹",
                    reply_markup=InlineKeyboardMarkup(keyboard)
                )
                return
            
            if data == "change_channel":
                if user.id != owner_id:
                    await query.answer("Ù„Ù„Ù…Ø§Ù„Ùƒ ÙÙ‚Ø·", show_alert=True)
                    return
                ai_user_states[user.id] = {'changing_channel': True}
                keyboard = [[InlineKeyboardButton("Ø§Ù„ØºØ§Ø¡", callback_data="back_ai")]]
                await query.edit_message_text(
                    "Ø§Ø±Ø³Ù„ ÙŠÙˆØ²Ø± Ø§Ù„Ù‚Ù†Ø§Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©\nÙ…Ø«Ø§Ù„: @ChannelName",
                    reply_markup=InlineKeyboardMarkup(keyboard)
                )
                return
            
            if data == "cancel_broadcast":
                ai_user_states.pop(user.id, None)
                keyboard = [
                    [InlineKeyboardButton("Ø§Ø°Ø§Ø¹Ø© Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†", callback_data="broadcast")],
                    [InlineKeyboardButton("ØªØºÙŠÙŠØ± Ù‚Ù†Ø§Ø© Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ", callback_data="change_channel")],
                    [InlineKeyboardButton("Ø±Ø¬ÙˆØ¹", callback_data="back_ai")]
                ]
                await query.edit_message_text(
                    "â€» Ù„ÙˆØ­Ø© Ø§Ù„Ø§Ø¯Ù…Ù†\n\nØ§Ø®ØªØ± Ù…Ù† Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©",
                    reply_markup=InlineKeyboardMarkup(keyboard)
                )
                return
        
        async def ai_photo_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
            message = update.message
            if message is None:
                return
            user = message.from_user
            if user is None:
                return
            
            user_id = str(user.id)
            
            banned_data = get_banned_users_data()
            bot_key = f"ai_{token[:20]}"
            if bot_key in banned_data and user.id in banned_data[bot_key]:
                await message.reply_text("â›” Ø§Ù†Øª Ù…Ø­Ø¸ÙˆØ± Ù…Ù† Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù‡Ø°Ø§ Ø§Ù„Ø¨ÙˆØª")
                return
            
            if not GROQ_API_KEY:
                await message.reply_text("Ø¹Ø°Ø±Ø§ØŒ Ø®Ø¯Ù…Ø© Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ ØºÙŠØ± Ù…ØªØ§Ø­Ø© Ø­Ø§Ù„ÙŠØ§")
                return
            
            try:
                photo = message.photo[-1]
                file = await context.bot.get_file(photo.file_id)
                photo_bytes = await file.download_as_bytearray()
                
                photo_base64 = base64.b64encode(photo_bytes).decode('utf-8')
                
                caption = message.caption or "ÙˆØµÙ Ø§Ù„ØµÙˆØ±Ø© Ø¯ÙŠ ÙˆØ­Ù„Ù„Ù‡Ø§"
                
                client = Groq(api_key=GROQ_API_KEY)
                
                messages = [
                    {"role": "system", "content": "Ø§Ù†Øª Ù…Ø³Ø§Ø¹Ø¯ Ø°ÙƒÙŠ ÙˆÙ…ÙÙŠØ¯ Ù…ØªØ®ØµØµ ÙÙŠ ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØµÙˆØ±. Ø§Ø¬Ø¨ Ø¨Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ø¨Ù„Ù‡Ø¬Ø© Ù…ØµØ±ÙŠØ© ÙˆØ§Ø±Ø¯Ù†ÙŠØ© Ù…Ø®ØªÙ„Ø·Ø©. ÙƒÙ† ÙˆØ¯ÙˆØ¯Ø§ ÙˆÙ…Ø³Ø§Ø¹Ø¯Ø§. Ø­Ù„Ù„ Ø§Ù„ØµÙˆØ± Ø¨Ø¯Ù‚Ø© ÙˆÙˆØ¶ÙˆØ­."},
                    {
                        "role": "user",
                        "content": [
                            {
                                "type": "text",
                                "text": caption
                            },
                            {
                                "type": "image_url",
                                "image_url": {
                                    "url": f"data:image/jpeg;base64,{photo_base64}"
                                }
                            }
                        ]
                    }
                ]
                
                response = client.chat.completions.create(
                    model="meta-llama/llama-4-scout-17b-16e-instruct",
                    messages=messages,
                    max_tokens=1024,
                    temperature=0.7
                )
                
                ai_response = response.choices[0].message.content or "Ø¹Ø°Ø±Ø§ØŒ Ù„Ù… Ø§Ø³ØªØ·Ø¹ ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø©"
                
                remember_data = get_remember_data()
                if user_id not in remember_data:
                    remember_data[user_id] = []
                remember_data[user_id].append({"role": "user", "content": f"[ØµÙˆØ±Ø©] {caption}"})
                remember_data[user_id].append({"role": "assistant", "content": ai_response})
                if len(remember_data[user_id]) > 20:
                    remember_data[user_id] = remember_data[user_id][-20:]
                save_remember_data(remember_data)
                
                await message.reply_text(ai_response)
                
            except Exception as e:
                logger.error(f"AI Photo Error: {e}")
                await message.reply_text("Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø©ØŒ Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø§Ø®Ø±Ù‰")
        
        app.add_handler(CommandHandler('start', ai_start))
        app.add_handler(CallbackQueryHandler(ai_callback))
        app.add_handler(MessageHandler(filters.PHOTO, ai_photo_message))
        app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, ai_message))
        
        await app.initialize()
        await app.start()
        await app.updater.start_polling(drop_pending_updates=True)
        
        running_bot_apps[token] = app
        logger.info(f"AI Bot started successfully")
        
    except Exception as e:
        logger.error(f"Error starting AI bot: {e}")

def get_guard_data():
    try:
        with open('guard_data.json', 'r', encoding='utf-8') as f:
            return json.load(f)
    except:
        return {}

def save_guard_data(data):
    with open('guard_data.json', 'w', encoding='utf-8') as f:
        json.dump(data, f, ensure_ascii=False, indent=2)

def get_guard_admins():
    try:
        with open('guard_admins.json', 'r', encoding='utf-8') as f:
            return json.load(f)
    except:
        return {}

def save_guard_admins(data):
    with open('guard_admins.json', 'w', encoding='utf-8') as f:
        json.dump(data, f, ensure_ascii=False, indent=2)

def get_kick_counts():
    try:
        with open('kick_counts.json', 'r', encoding='utf-8') as f:
            return json.load(f)
    except:
        return {}

def save_kick_counts(data):
    with open('kick_counts.json', 'w', encoding='utf-8') as f:
        json.dump(data, f, ensure_ascii=False, indent=2)

async def start_guard_bot(token: str, owner_id: int):
    try:
        app = Application.builder().token(token).build()
        guard_user_states = {}
        
        async def guard_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
            user = update.effective_user
            message = update.message
            if user is None or message is None:
                return
            first_name = user.first_name or "ØµØ¯ÙŠÙ‚ÙŠ"
            
            bots_data = get_bots_data()
            bot_data = bots_data.get(token, {})
            bot_username = bot_data.get('bot_username', 'Bot')
            
            guard_data = get_guard_data()
            bot_key = f"guard_{token[:20]}"
            if bot_key not in guard_data:
                guard_data[bot_key] = {
                    'kick_limit': 5,
                    'channels': [],
                    'groups': [],
                    'users': []
                }
                save_guard_data(guard_data)
            
            if str(user.id) not in guard_data[bot_key].get('users', []):
                guard_data[bot_key]['users'] = guard_data[bot_key].get('users', []) + [str(user.id)]
                save_guard_data(guard_data)
            
            channels_count = len(guard_data[bot_key].get('channels', []))
            groups_count = len(guard_data[bot_key].get('groups', []))
            users_count = len(guard_data[bot_key].get('users', []))
            
            if user.id == owner_id:
                keyboard = [
                    [InlineKeyboardButton("Ù‚Ø³Ù… Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ø¨ÙˆØª", callback_data="guard_control")]
                ]
                
                text = f"""â€» Ø§Ù‡Ù„Ø§ ÙˆØ³Ù‡Ù„Ø§ ÙŠØ§ Ù…Ø·ÙˆØ± {first_name}

â Ø§Ù†Ø§ Ø§Ø¹Ù…Ù„ Ø§Ù„Ø§Ù† - im Just Work âœ…
â Ø¹Ø¯Ø¯ Ø§Ù„Ù‚Ù†ÙˆØ§Øª : {channels_count}
â Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª : {groups_count}
â Ø¹Ø¯Ø¯ Ø§Ù„Ø§Ø¹Ø¶Ø§Ø¡ : {users_count}"""
            else:
                keyboard = [
                    [InlineKeyboardButton("Ø§Ø¶Ù Ø§Ù„Ø¨ÙˆØª Ø§Ù„ÙŠ Ù…Ø¬Ù…ÙˆØ¹ØªÙƒ âœ…", url=f"https://t.me/{bot_username}?startgroup=true")]
                ]
                
                text = f"""â€» Ø§Ù‡Ù„Ø§ ÙˆØ³Ù‡Ù„Ø§ ÙŠØ§ {first_name}

â Ø¨ÙˆØª Ø­Ù…Ø§ÙŠØ© Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª ÙˆØ§Ù„Ù‚Ù†ÙˆØ§Øª Ù…Ù† Ø§Ù„Ù…Ø®Ø±Ø¨ÙŠÙ† âœ…

â ÙÙ‚Ø· Ø§Ø±ÙØ¹ Ø§Ù„Ø¨ÙˆØª Ø¨Ø¯Ø§Ø®Ù„ Ù‚Ù†Ø§ØªÙƒ Ø§Ùˆ Ù…Ø¬Ù…ÙˆØ¹ØªÙƒ ÙˆØ³ÙŠØªÙ… ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø¨ÙˆØª ØªÙ„Ù‚Ø§Ø¦ÙŠØ§

â ØªØ§ÙƒØ¯ Ø§Ø¹Ø·Ø§Ø¦ÙŠ ØµÙ„Ø§Ø­ÙŠØ§Øª Ù„Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø³Ù„ÙŠÙ…

â Ø§Ù„Ù…Ø·ÙˆØ± @{DEVELOPER_USERNAME}
â Ø§Ù„Ø¯Ø¹Ù… @TepthonHelp"""
            
            await message.reply_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
        
        async def guard_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
            query = update.callback_query
            if query is None:
                return
            await query.answer()
            user = query.from_user
            if user is None:
                return
            data = query.data
            first_name = user.first_name or "ØµØ¯ÙŠÙ‚ÙŠ"
            
            guard_data = get_guard_data()
            bot_key = f"guard_{token[:20]}"
            if bot_key not in guard_data:
                guard_data[bot_key] = {'kick_limit': 5, 'channels': [], 'groups': [], 'users': []}
            
            channels_count = len(guard_data[bot_key].get('channels', []))
            groups_count = len(guard_data[bot_key].get('groups', []))
            users_count = len(guard_data[bot_key].get('users', []))
            kick_limit = guard_data[bot_key].get('kick_limit', 5)
            
            if data == "guard_control":
                if user.id != owner_id:
                    await query.answer("Ù„Ù„Ù…Ø§Ù„Ùƒ ÙÙ‚Ø·", show_alert=True)
                    return
                
                keyboard = [
                    [
                        InlineKeyboardButton("Ø§Ù„Ø§Ø­ØµØ§Ø¦ÙŠØ§Øª ğŸ“Š", callback_data="guard_stats"),
                        InlineKeyboardButton("ØªØºÙŠÙŠØ± Ø­Ø¯ Ø§Ù„ØªØµÙÙŠØ© âš™ï¸", callback_data="change_kick_limit")
                    ],
                    [
                        InlineKeyboardButton("Ø§Ù„Ù…Ø´Ø±ÙÙŠÙ† Ø§Ù„Ù…Ø³Ø¬Ù„ÙŠÙ† ğŸ‘¥", callback_data="list_admins"),
                        InlineKeyboardButton("Ø§Ø°Ø§Ø¹Ø© Ù„Ù„ÙƒÙ„ ğŸ“¢", callback_data="guard_broadcast")
                    ],
                    [InlineKeyboardButton("Ø±Ø¬ÙˆØ¹", callback_data="guard_back")]
                ]
                
                text = f"""â€» Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ…

â Ø­Ø¯ Ø§Ù„ØªØµÙÙŠØ© Ø§Ù„Ø­Ø§Ù„ÙŠ: {kick_limit} Ø·Ø±Ø¯
â Ø¹Ø¯Ø¯ Ø§Ù„Ù‚Ù†ÙˆØ§Øª: {channels_count}
â Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª: {groups_count}
â Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†: {users_count}"""
                
                await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
                return
            
            if data == "guard_stats":
                if user.id != owner_id:
                    await query.answer("Ù„Ù„Ù…Ø§Ù„Ùƒ ÙÙ‚Ø·", show_alert=True)
                    return
                
                keyboard = [[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹", callback_data="guard_control")]]
                
                text = f"""â€» Ø§Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø¨ÙˆØª

â Ø¹Ø¯Ø¯ Ø§Ù„Ù‚Ù†ÙˆØ§Øª: {channels_count}
â Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª: {groups_count}
â Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†: {users_count}
â Ø­Ø¯ Ø§Ù„ØªØµÙÙŠØ©: {kick_limit} Ø·Ø±Ø¯"""
                
                await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
                return
            
            if data == "change_kick_limit":
                if user.id != owner_id:
                    await query.answer("Ù„Ù„Ù…Ø§Ù„Ùƒ ÙÙ‚Ø·", show_alert=True)
                    return
                
                keyboard = [
                    [
                        InlineKeyboardButton("3", callback_data="set_limit_3"),
                        InlineKeyboardButton("5", callback_data="set_limit_5"),
                        InlineKeyboardButton("10", callback_data="set_limit_10")
                    ],
                    [
                        InlineKeyboardButton("15", callback_data="set_limit_15"),
                        InlineKeyboardButton("20", callback_data="set_limit_20")
                    ],
                    [InlineKeyboardButton("Ø±Ø¬ÙˆØ¹", callback_data="guard_control")]
                ]
                
                text = f"""â€» ØªØºÙŠÙŠØ± Ø­Ø¯ Ø§Ù„ØªØµÙÙŠØ©

Ø§Ù„Ø­Ø¯ Ø§Ù„Ø­Ø§Ù„ÙŠ: {kick_limit} Ø·Ø±Ø¯

Ø§Ø®ØªØ± Ø§Ù„Ø­Ø¯ Ø§Ù„Ø¬Ø¯ÙŠØ¯:"""
                
                await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
                return
            
            if data.startswith("set_limit_"):
                if user.id != owner_id:
                    await query.answer("Ù„Ù„Ù…Ø§Ù„Ùƒ ÙÙ‚Ø·", show_alert=True)
                    return
                
                new_limit = int(data.split("_")[2])
                guard_data[bot_key]['kick_limit'] = new_limit
                save_guard_data(guard_data)
                
                await query.answer(f"ØªÙ… ØªØºÙŠÙŠØ± Ø§Ù„Ø­Ø¯ Ø§Ù„Ù‰ {new_limit}", show_alert=True)
                
                keyboard = [[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹", callback_data="guard_control")]]
                await query.edit_message_text(
                    f"âœ… ØªÙ… ØªØºÙŠÙŠØ± Ø­Ø¯ Ø§Ù„ØªØµÙÙŠØ© Ø§Ù„Ù‰ {new_limit} Ø·Ø±Ø¯",
                    reply_markup=InlineKeyboardMarkup(keyboard)
                )
                return
            
            if data == "list_admins":
                if user.id != owner_id:
                    await query.answer("Ù„Ù„Ù…Ø§Ù„Ùƒ ÙÙ‚Ø·", show_alert=True)
                    return
                
                admins_data = get_guard_admins()
                admin_key = f"admins_{token[:20]}"
                admins = admins_data.get(admin_key, {})
                
                if not admins:
                    text = "â€» Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ø´Ø±ÙÙŠÙ† Ù…Ø³Ø¬Ù„ÙŠÙ† Ø¨Ø¹Ø¯"
                else:
                    text = "â€» Ø§Ù„Ù…Ø´Ø±ÙÙŠÙ† Ø§Ù„Ù…Ø³Ø¬Ù„ÙŠÙ†:\n\n"
                    for chat_id, chat_admins in admins.items():
                        text += f"ğŸ“ {chat_id}:\n"
                        for admin_id in chat_admins:
                            text += f"  - {admin_id}\n"
                
                keyboard = [[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹", callback_data="guard_control")]]
                await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
                return
            
            if data == "guard_broadcast":
                if user.id != owner_id:
                    await query.answer("Ù„Ù„Ù…Ø§Ù„Ùƒ ÙÙ‚Ø·", show_alert=True)
                    return
                
                guard_user_states[user.id] = {'broadcasting': True}
                keyboard = [[InlineKeyboardButton("Ø§Ù„ØºØ§Ø¡", callback_data="guard_control")]]
                await query.edit_message_text(
                    "Ø§Ø±Ø³Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù„ÙŠ Ø¹Ø§ÙŠØ² ØªØ°ÙŠØ¹Ù‡Ø§ Ù„Ù„Ø¬Ù…ÙŠØ¹",
                    reply_markup=InlineKeyboardMarkup(keyboard)
                )
                return
            
            if data == "guard_back":
                bots_data = get_bots_data()
                bot_data = bots_data.get(token, {})
                bot_username = bot_data.get('bot_username', 'Bot')
                
                if user.id == owner_id:
                    keyboard = [
                        [InlineKeyboardButton("Ù‚Ø³Ù… Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ø¨ÙˆØª", callback_data="guard_control")]
                    ]
                    
                    text = f"""â€» Ø§Ù‡Ù„Ø§ ÙˆØ³Ù‡Ù„Ø§ ÙŠØ§ Ù…Ø·ÙˆØ± {first_name}

â Ø§Ù†Ø§ Ø§Ø¹Ù…Ù„ Ø§Ù„Ø§Ù† - im Just Work âœ…
â Ø¹Ø¯Ø¯ Ø§Ù„Ù‚Ù†ÙˆØ§Øª : {channels_count}
â Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª : {groups_count}
â Ø¹Ø¯Ø¯ Ø§Ù„Ø§Ø¹Ø¶Ø§Ø¡ : {users_count}"""
                else:
                    keyboard = [
                        [InlineKeyboardButton("Ø§Ø¶Ù Ø§Ù„Ø¨ÙˆØª Ø§Ù„ÙŠ Ù…Ø¬Ù…ÙˆØ¹ØªÙƒ âœ…", url=f"https://t.me/{bot_username}?startgroup=true")]
                    ]
                    
                    text = f"""â€» Ø§Ù‡Ù„Ø§ ÙˆØ³Ù‡Ù„Ø§ ÙŠØ§ {first_name}

â Ø¨ÙˆØª Ø­Ù…Ø§ÙŠØ© Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª ÙˆØ§Ù„Ù‚Ù†ÙˆØ§Øª Ù…Ù† Ø§Ù„Ù…Ø®Ø±Ø¨ÙŠÙ† âœ…

â ÙÙ‚Ø· Ø§Ø±ÙØ¹ Ø§Ù„Ø¨ÙˆØª Ø¨Ø¯Ø§Ø®Ù„ Ù‚Ù†Ø§ØªÙƒ Ø§Ùˆ Ù…Ø¬Ù…ÙˆØ¹ØªÙƒ ÙˆØ³ÙŠØªÙ… ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø¨ÙˆØª ØªÙ„Ù‚Ø§Ø¦ÙŠØ§

â ØªØ§ÙƒØ¯ Ø§Ø¹Ø·Ø§Ø¦ÙŠ ØµÙ„Ø§Ø­ÙŠØ§Øª Ù„Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø³Ù„ÙŠÙ…

â Ø§Ù„Ù…Ø·ÙˆØ± @{DEVELOPER_USERNAME}
â Ø§Ù„Ø¯Ø¹Ù… @TepthonHelp"""
                
                await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
                return
            
            if data.startswith("perm_"):
                user_state = guard_user_states.get(user.id, {})
                if not user_state.get('promoting'):
                    await query.answer("Ø§Ù†ØªÙ‡Øª ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ø¹Ù…Ù„ÙŠØ©", show_alert=True)
                    return
                
                parts = data.split("_")
                perm_type = parts[1]
                
                perm_map = {
                    'delete': 'can_delete_messages',
                    'info': 'can_change_info',
                    'promote': 'can_promote_members',
                    'voice': 'can_manage_voice_chats',
                    'stories': 'can_post_stories',
                    'pin': 'can_pin_messages',
                    'invite': 'can_invite_users',
                    'restrict': 'can_restrict_members'
                }
                
                perm_key = perm_map.get(perm_type)
                if perm_key:
                    current_value = user_state['permissions'].get(perm_key, False)
                    user_state['permissions'][perm_key] = not current_value
                    guard_user_states[user.id] = user_state
                
                perms = user_state['permissions']
                target_name = user_state.get('target_name', 'Unknown')
                chat_id = user_state.get('chat_id')
                target_id = user_state.get('target_id')
                
                keyboard = [
                    [
                        InlineKeyboardButton(f"Ø­Ø°Ù Ø±Ø³Ø§Ø¦Ù„ {'âœ…' if perms['can_delete_messages'] else 'âŒ'}", callback_data=f"perm_delete_{chat_id}_{target_id}"),
                        InlineKeyboardButton(f"ØªØ¹Ø¯ÙŠÙ„ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª {'âœ…' if perms['can_change_info'] else 'âŒ'}", callback_data=f"perm_info_{chat_id}_{target_id}")
                    ],
                    [
                        InlineKeyboardButton(f"Ø±ÙØ¹ Ù…Ø´Ø±ÙÙŠÙ† {'âœ…' if perms['can_promote_members'] else 'âŒ'}", callback_data=f"perm_promote_{chat_id}_{target_id}"),
                        InlineKeyboardButton(f"Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ù‡ Ø§Ù„ØµÙˆØªÙŠÙ‡ {'âœ…' if perms['can_manage_voice_chats'] else 'âŒ'}", callback_data=f"perm_voice_{chat_id}_{target_id}")
                    ],
                    [
                        InlineKeyboardButton(f"Ø§Ù„Ø§Ø³ØªÙˆØ±ÙŠÙ‡Ø§Øª {'âœ…' if perms['can_post_stories'] else 'âŒ'}", callback_data=f"perm_stories_{chat_id}_{target_id}"),
                        InlineKeyboardButton(f"ØªØ«Ø¨ÙŠØª Ø±Ø³Ø§Ø¦Ù„ {'âœ…' if perms['can_pin_messages'] else 'âŒ'}", callback_data=f"perm_pin_{chat_id}_{target_id}")
                    ],
                    [
                        InlineKeyboardButton(f"Ø¯Ø¹ÙˆÙ‡ Ø¹Ø¨Ø± Ø±Ø§Ø¨Ø· {'âœ…' if perms['can_invite_users'] else 'âŒ'}", callback_data=f"perm_invite_{chat_id}_{target_id}"),
                        InlineKeyboardButton(f"ØªÙ‚ÙŠÙŠØ¯ Ø§Ø¹Ø¶Ø§Ø¡ {'âœ…' if perms['can_restrict_members'] else 'âŒ'}", callback_data=f"perm_restrict_{chat_id}_{target_id}")
                    ],
                    [
                        InlineKeyboardButton("âœ… ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø±ÙØ¹", callback_data=f"confirm_promote_{chat_id}_{target_id}"),
                        InlineKeyboardButton("âŒ Ø§Ù„ØºØ§Ø¡", callback_data=f"cancel_promote_{chat_id}_{target_id}")
                    ]
                ]
                
                await query.edit_message_text(
                    f"â€» Ø±ÙØ¹ Ù…Ø´Ø±Ù: {target_name}\n\nÙŠØ±Ø¬ÙŠ Ø§Ø®ØªÙŠØ§Ø± ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ğŸ“",
                    reply_markup=InlineKeyboardMarkup(keyboard)
                )
                return
            
            if data.startswith("confirm_promote_"):
                user_state = guard_user_states.get(user.id, {})
                if not user_state.get('promoting'):
                    await query.answer("Ø§Ù†ØªÙ‡Øª ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ø¹Ù…Ù„ÙŠØ©", show_alert=True)
                    return
                
                target_id = user_state.get('target_id')
                target_name = user_state.get('target_name')
                chat_id = user_state.get('chat_id')
                perms = user_state.get('permissions', {})
                
                try:
                    from telegram import ChatPermissions
                    await context.bot.promote_chat_member(
                        chat_id=chat_id,
                        user_id=target_id,
                        can_delete_messages=perms.get('can_delete_messages', False),
                        can_change_info=perms.get('can_change_info', False),
                        can_promote_members=perms.get('can_promote_members', False),
                        can_manage_video_chats=perms.get('can_manage_voice_chats', False),
                        can_post_stories=perms.get('can_post_stories', False),
                        can_pin_messages=perms.get('can_pin_messages', False),
                        can_invite_users=perms.get('can_invite_users', False),
                        can_restrict_members=perms.get('can_restrict_members', False)
                    )
                    
                    admins_data = get_guard_admins()
                    admin_key = f"admins_{token[:20]}"
                    if admin_key not in admins_data:
                        admins_data[admin_key] = {}
                    
                    chat_key = str(chat_id)
                    if chat_key not in admins_data[admin_key]:
                        admins_data[admin_key][chat_key] = []
                    
                    if target_id not in admins_data[admin_key][chat_key]:
                        admins_data[admin_key][chat_key].append(target_id)
                        save_guard_admins(admins_data)
                    
                    await query.edit_message_text(f"âœ… ØªÙ… Ø±ÙØ¹ {target_name} ÙƒÙ…Ø´Ø±Ù Ø¨Ù†Ø¬Ø§Ø­!")
                    guard_user_states.pop(user.id, None)
                    
                except Exception as e:
                    await query.edit_message_text(f"âŒ ÙØ´Ù„ Ø±ÙØ¹ Ø§Ù„Ù…Ø´Ø±Ù\nØ§Ù„Ø³Ø¨Ø¨: {str(e)}")
                    guard_user_states.pop(user.id, None)
                return
            
            if data.startswith("cancel_promote_"):
                guard_user_states.pop(user.id, None)
                await query.edit_message_text("âŒ ØªÙ… Ø§Ù„ØºØ§Ø¡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©")
                return
        
        async def guard_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
            message = update.message
            if message is None:
                return
            user = message.from_user
            if user is None:
                return
            
            message_text = message.text or ""
            chat = message.chat
            
            user_state = guard_user_states.get(user.id, {})
            if user_state.get('broadcasting') and user.id == owner_id:
                guard_data = get_guard_data()
                bot_key = f"guard_{token[:20]}"
                users = guard_data.get(bot_key, {}).get('users', [])
                
                success = 0
                failed = 0
                for uid in users:
                    try:
                        await context.bot.send_message(chat_id=int(uid), text=message_text)
                        success += 1
                    except:
                        failed += 1
                
                await message.reply_text(f"âœ… ØªÙ… Ø§Ù„Ø§Ø±Ø³Ø§Ù„\nÙ†Ø¬Ø­: {success}\nÙØ´Ù„: {failed}")
                guard_user_states.pop(user.id, None)
                return
            
            if chat.type in ['group', 'supergroup']:
                if message_text in ["Ø§Ù„Ø£ÙˆØ§Ù…Ø±", "Ø§Ù„Ø§ÙˆØ§Ù…Ø±", "Ø§ÙˆØ§Ù…Ø±", "Ø£ÙˆØ§Ù…Ø±", "help", "Ù…Ø³Ø§Ø¹Ø¯Ø©"]:
                    help_text = """â€» Ø¨ÙˆØª Ù…Ù†Ø¹ Ø§Ù„ØªØµÙÙŠØ©

â ÙƒÙŠÙ ÙŠØ¹Ù…Ù„ Ø§Ù„Ø¨ÙˆØª:
â€¢ Ø§Ù„Ø¨ÙˆØª ÙŠØ±Ø§Ù‚Ø¨ Ø§Ù„Ù…Ø´Ø±ÙÙŠÙ† Ø§Ù„Ø°ÙŠÙ† ÙŠÙ‚ÙˆÙ…ÙˆÙ† Ø¨Ø·Ø±Ø¯ Ø§Ù„Ø£Ø¹Ø¶Ø§Ø¡
â€¢ Ø¹Ù†Ø¯ ØªØ¬Ø§ÙˆØ² Ù…Ø´Ø±Ù Ù„Ø­Ø¯ Ø§Ù„ØªØµÙÙŠØ© ÙŠØªÙ… ØªÙ†Ø²ÙŠÙ„Ù‡ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹
â€¢ ÙŠØ­Ù…ÙŠ Ù…Ø¬Ù…ÙˆØ¹ØªÙƒ Ù…Ù† Ø§Ù„Ù…Ø®Ø±Ø¨ÙŠÙ† ÙˆØ§Ù„ØªØµÙÙŠØ© Ø§Ù„Ø¬Ù…Ø§Ø¹ÙŠØ©

â Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ù…ØªØ§Ø­Ø©:

â€» Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª:
â€¢ Ø±ÙØ¹ Ù…Ø´Ø±Ù @username - Ø±ÙØ¹ Ù…Ø³ØªØ®Ø¯Ù… ÙƒÙ…Ø´Ø±Ù
â€¢ Ø±ÙØ¹ Ù…Ø´Ø±Ù [Ø§Ù„Ø±Ø¯] - Ø±ÙØ¹ Ø¨Ø§Ù„Ø±Ø¯ Ø¹Ù„Ù‰ Ø±Ø³Ø§Ù„ØªÙ‡
â€¢ Ø±ÙØ¹ Ù…Ø´Ø±Ù 123456 - Ø±ÙØ¹ Ø¨Ø§Ù„Ø§ÙŠØ¯ÙŠ
â€¢ ØªÙ†Ø²ÙŠÙ„ Ù…Ø´Ø±Ù @username - ØªÙ†Ø²ÙŠÙ„ Ù…Ø´Ø±Ù
â€¢ ØªÙ†Ø²ÙŠÙ„ Ù…Ø´Ø±Ù [Ø§Ù„Ø±Ø¯] - ØªÙ†Ø²ÙŠÙ„ Ø¨Ø§Ù„Ø±Ø¯
â€¢ ØªÙ†Ø²ÙŠÙ„ Ù…Ø´Ø±Ù 123456 - ØªÙ†Ø²ÙŠÙ„ Ø¨Ø§Ù„Ø§ÙŠØ¯ÙŠ

â€» Ù…Ù„Ø§Ø­Ø¸Ø§Øª:
â€¢ Ø­Ø¯ Ø§Ù„ØªØµÙÙŠØ© Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ: 3 Ø·Ø±Ø¯
â€¢ Ø§Ù„Ø¨ÙˆØª ÙŠØ­ØªØ§Ø¬ ØµÙ„Ø§Ø­ÙŠØ© Ø±ÙØ¹ Ù…Ø´Ø±ÙÙŠÙ†
â€¢ Ø§Ù„Ù…Ø§Ù„Ùƒ ÙŠÙ…ÙƒÙ†Ù‡ Ø§Ù„ØªØ­ÙƒÙ… Ù…Ù† Ø§Ù„Ø®Ø§Øµ

â€» Ø§Ù„Ù…Ø·ÙˆØ± @Dev_Mido
â€» Ø§Ù„Ù‚Ù†Ø§Ø© @TepthonHelp"""
                    await message.reply_text(help_text)
                    return
                
                if message_text.startswith("Ø±ÙØ¹ Ù…Ø´Ø±Ù"):
                    chat_member = await context.bot.get_chat_member(chat.id, user.id)
                    if chat_member.status not in ['creator', 'administrator']:
                        return
                    
                    target_id = None
                    target_name = None
                    
                    if message.reply_to_message:
                        target_user = message.reply_to_message.from_user
                        if target_user:
                            target_id = target_user.id
                            target_name = target_user.first_name
                    else:
                        parts = message_text.split()
                        if len(parts) >= 3:
                            target = parts[2]
                            if target.startswith('@'):
                                target_name = target
                                try:
                                    target_chat = await context.bot.get_chat(target)
                                    target_id = target_chat.id
                                except:
                                    await message.reply_text("Ù„Ù… Ø§Ø³ØªØ·Ø¹ Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù‡Ø°Ø§ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…")
                                    return
                            else:
                                try:
                                    target_id = int(target)
                                    try:
                                        target_member = await context.bot.get_chat_member(chat.id, target_id)
                                        target_name = target_member.user.first_name or str(target_id)
                                    except:
                                        target_name = str(target_id)
                                except:
                                    await message.reply_text("Ø§Ø±Ø³Ù„ Ø§ÙŠØ¯ÙŠ ØµØ­ÙŠØ­ Ø§Ùˆ Ù…Ø¹Ø±Ù Ø§Ùˆ Ø±Ø¯ Ø¹Ù„Ù‰ Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…")
                                    return
                    
                    if target_id is None:
                        await message.reply_text("Ø±Ø¯ Ø¹Ù„Ù‰ Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ùˆ Ø§Ø±Ø³Ù„ Ø§Ù„Ù…Ø¹Ø±Ù/Ø§Ù„Ø§ÙŠØ¯ÙŠ")
                        return
                    
                    guard_user_states[user.id] = {
                        'promoting': True,
                        'target_id': target_id,
                        'target_name': target_name,
                        'chat_id': chat.id,
                        'promoter_id': user.id,
                        'permissions': {
                            'can_delete_messages': False,
                            'can_change_info': False,
                            'can_promote_members': False,
                            'can_manage_voice_chats': False,
                            'can_post_stories': False,
                            'can_pin_messages': False,
                            'can_invite_users': False,
                            'can_restrict_members': False
                        }
                    }
                    
                    keyboard = [
                        [
                            InlineKeyboardButton("Ø­Ø°Ù Ø±Ø³Ø§Ø¦Ù„ âŒ", callback_data=f"perm_delete_{chat.id}_{target_id}"),
                            InlineKeyboardButton("ØªØ¹Ø¯ÙŠÙ„ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª âŒ", callback_data=f"perm_info_{chat.id}_{target_id}")
                        ],
                        [
                            InlineKeyboardButton("Ø±ÙØ¹ Ù…Ø´Ø±ÙÙŠÙ† âŒ", callback_data=f"perm_promote_{chat.id}_{target_id}"),
                            InlineKeyboardButton("Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ù‡ Ø§Ù„ØµÙˆØªÙŠÙ‡ âŒ", callback_data=f"perm_voice_{chat.id}_{target_id}")
                        ],
                        [
                            InlineKeyboardButton("Ø§Ù„Ø§Ø³ØªÙˆØ±ÙŠÙ‡Ø§Øª âŒ", callback_data=f"perm_stories_{chat.id}_{target_id}"),
                            InlineKeyboardButton("ØªØ«Ø¨ÙŠØª Ø±Ø³Ø§Ø¦Ù„ âŒ", callback_data=f"perm_pin_{chat.id}_{target_id}")
                        ],
                        [
                            InlineKeyboardButton("Ø¯Ø¹ÙˆÙ‡ Ø¹Ø¨Ø± Ø±Ø§Ø¨Ø· âŒ", callback_data=f"perm_invite_{chat.id}_{target_id}"),
                            InlineKeyboardButton("ØªÙ‚ÙŠÙŠØ¯ Ø§Ø¹Ø¶Ø§Ø¡ âŒ", callback_data=f"perm_restrict_{chat.id}_{target_id}")
                        ],
                        [
                            InlineKeyboardButton("âœ… ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø±ÙØ¹", callback_data=f"confirm_promote_{chat.id}_{target_id}"),
                            InlineKeyboardButton("âŒ Ø§Ù„ØºØ§Ø¡", callback_data=f"cancel_promote_{chat.id}_{target_id}")
                        ]
                    ]
                    
                    await message.reply_text(
                        f"â€» Ø±ÙØ¹ Ù…Ø´Ø±Ù: {target_name}\n\nÙŠØ±Ø¬ÙŠ Ø§Ø®ØªÙŠØ§Ø± ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ğŸ“",
                        reply_markup=InlineKeyboardMarkup(keyboard)
                    )
                    return
                
                if message_text.startswith("ØªÙ†Ø²ÙŠÙ„ Ù…Ø´Ø±Ù"):
                    chat_member = await context.bot.get_chat_member(chat.id, user.id)
                    if chat_member.status not in ['creator', 'administrator']:
                        return
                    
                    target_id = None
                    target_name = None
                    
                    if message.reply_to_message:
                        target_user = message.reply_to_message.from_user
                        if target_user:
                            target_id = target_user.id
                            target_name = target_user.first_name
                    else:
                        parts = message_text.split()
                        if len(parts) >= 3:
                            target = parts[2]
                            if target.startswith('@'):
                                target_name = target
                                try:
                                    target_chat = await context.bot.get_chat(target)
                                    target_id = target_chat.id
                                except:
                                    await message.reply_text("Ù„Ù… Ø§Ø³ØªØ·Ø¹ Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù‡Ø°Ø§ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…")
                                    return
                            else:
                                try:
                                    target_id = int(target)
                                    try:
                                        target_member = await context.bot.get_chat_member(chat.id, target_id)
                                        target_name = target_member.user.first_name or str(target_id)
                                    except:
                                        target_name = str(target_id)
                                except:
                                    await message.reply_text("Ø§Ø±Ø³Ù„ Ø§ÙŠØ¯ÙŠ ØµØ­ÙŠØ­ Ø§Ùˆ Ù…Ø¹Ø±Ù Ø§Ùˆ Ø±Ø¯ Ø¹Ù„Ù‰ Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…")
                                    return
                    
                    if target_id is None:
                        await message.reply_text("Ø±Ø¯ Ø¹Ù„Ù‰ Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ùˆ Ø§Ø±Ø³Ù„ Ø§Ù„Ù…Ø¹Ø±Ù/Ø§Ù„Ø§ÙŠØ¯ÙŠ")
                        return
                    
                    admins_data = get_guard_admins()
                    admin_key = f"admins_{token[:20]}"
                    chat_key = str(chat.id)
                    
                    if admin_key in admins_data and chat_key in admins_data[admin_key]:
                        if target_id in admins_data[admin_key][chat_key]:
                            admins_data[admin_key][chat_key].remove(target_id)
                            save_guard_admins(admins_data)
                            
                            kick_data = get_kick_counts()
                            kick_key = f"{token[:20]}_{chat.id}_{target_id}"
                            if kick_key in kick_data:
                                del kick_data[kick_key]
                                save_kick_counts(kick_data)
                            
                            await message.reply_text(f"âœ… ØªÙ… ØªÙ†Ø²ÙŠÙ„ {target_name} Ù…Ù† Ø§Ù„Ù…Ø´Ø±ÙÙŠÙ† Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨ÙŠÙ†")
                        else:
                            await message.reply_text("Ù‡Ø°Ø§ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù„ÙŠØ³ Ù…Ø´Ø±Ù Ù…Ø±Ø§Ù‚Ø¨")
                    else:
                        await message.reply_text("Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ø´Ø±ÙÙŠÙ† Ù…Ø³Ø¬Ù„ÙŠÙ†")
                    return
        
        async def handle_chat_member(update: Update, context: ContextTypes.DEFAULT_TYPE):
            chat_member_update = update.chat_member
            if chat_member_update is None:
                return
            
            chat = chat_member_update.chat
            old_status = chat_member_update.old_chat_member.status
            new_status = chat_member_update.new_chat_member.status
            kicked_by = chat_member_update.from_user
            kicked_user = chat_member_update.new_chat_member.user
            
            if new_status in ['kicked', 'left'] and old_status in ['member', 'administrator', 'creator']:
                if kicked_by and kicked_by.id != kicked_user.id:
                    admins_data = get_guard_admins()
                    admin_key = f"admins_{token[:20]}"
                    chat_key = str(chat.id)
                    
                    if admin_key in admins_data and chat_key in admins_data[admin_key]:
                        if kicked_by.id in admins_data[admin_key][chat_key]:
                            guard_data = get_guard_data()
                            bot_key = f"guard_{token[:20]}"
                            kick_limit = guard_data.get(bot_key, {}).get('kick_limit', 5)
                            
                            kick_data = get_kick_counts()
                            kick_key = f"{token[:20]}_{chat.id}_{kicked_by.id}"
                            
                            current_kicks = kick_data.get(kick_key, 0) + 1
                            kick_data[kick_key] = current_kicks
                            save_kick_counts(kick_data)
                            
                            if current_kicks >= kick_limit:
                                is_bot = kicked_by.is_bot if hasattr(kicked_by, 'is_bot') else False
                                action_success = False
                                error_reason = ""
                                
                                try:
                                    if is_bot:
                                        await context.bot.ban_chat_member(
                                            chat_id=chat.id,
                                            user_id=kicked_by.id
                                        )
                                        await context.bot.unban_chat_member(
                                            chat_id=chat.id,
                                            user_id=kicked_by.id
                                        )
                                        action_success = True
                                    else:
                                        await context.bot.promote_chat_member(
                                            chat_id=chat.id,
                                            user_id=kicked_by.id,
                                            can_manage_chat=False,
                                            can_delete_messages=False,
                                            can_restrict_members=False,
                                            can_promote_members=False,
                                            can_change_info=False,
                                            can_invite_users=False,
                                            can_pin_messages=False
                                        )
                                        action_success = True
                                except Exception as e:
                                    error_str = str(e).lower()
                                    if "not enough rights" in error_str:
                                        error_reason = "Ø§Ù„Ø¨ÙˆØª Ù„ÙŠØ³ Ù„Ø¯ÙŠÙ‡ ØµÙ„Ø§Ø­ÙŠØ© ÙƒØ§ÙÙŠØ©"
                                    elif "user is an administrator" in error_str:
                                        error_reason = "Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø´Ø±Ù Ø¨Ø±ØªØ¨Ø© Ø£Ø¹Ù„Ù‰"
                                    elif "can't remove" in error_str or "can't demote" in error_str:
                                        error_reason = "Ù„Ø§ ÙŠÙ…ÙƒÙ† ØªÙ†Ø²ÙŠÙ„ Ù‡Ø°Ø§ Ø§Ù„Ù…Ø´Ø±Ù"
                                    else:
                                        error_reason = "Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹"
                                    logger.error(f"Error demoting admin: {e}")
                                
                                if action_success:
                                    if kicked_by.id in admins_data[admin_key][chat_key]:
                                        admins_data[admin_key][chat_key].remove(kicked_by.id)
                                        save_guard_admins(admins_data)
                                    
                                    kick_data[kick_key] = 0
                                    save_kick_counts(kick_data)
                                    
                                    action_text = "Ø·Ø±Ø¯" if is_bot else "ØªÙ†Ø²ÙŠÙ„"
                                    await context.bot.send_message(
                                        chat_id=chat.id,
                                        text=f"âš ï¸ ØªÙ… {action_text} {kicked_by.first_name} Ù…Ù† Ø§Ù„Ø§Ø´Ø±Ø§Ù\nØ§Ù„Ø³Ø¨Ø¨: ØªØ¬Ø§ÙˆØ² Ø­Ø¯ Ø§Ù„ØªØµÙÙŠØ© ({kick_limit} Ø·Ø±Ø¯)"
                                    )
                                    
                                    try:
                                        await context.bot.send_message(
                                            chat_id=owner_id,
                                            text=f"âš ï¸ ØªÙ†Ø¨ÙŠÙ‡!\n\nØªÙ… {action_text} {kicked_by.first_name} (ID: {kicked_by.id})\nÙ…Ù† Ù…Ø¬Ù…ÙˆØ¹Ø©: {chat.title}\nØ§Ù„Ø³Ø¨Ø¨: ØªØ¬Ø§ÙˆØ² Ø­Ø¯ Ø§Ù„ØªØµÙÙŠØ© ({kick_limit})"
                                        )
                                    except:
                                        pass
                                else:
                                    await context.bot.send_message(
                                        chat_id=chat.id,
                                        text=f"âš ï¸ {kicked_by.first_name} ØªØ¬Ø§ÙˆØ² Ø­Ø¯ Ø§Ù„ØªØµÙÙŠØ© ({current_kicks}/{kick_limit})\nÙ„ÙƒÙ† Ù„Ø§ Ø§Ø³ØªØ·ÙŠØ¹ ØªÙ†Ø²ÙŠÙ„Ù‡\nØ§Ù„Ø³Ø¨Ø¨: {error_reason}\n\nğŸ’¡ Ø§Ø·Ù„Ø¨ Ù…Ù† Ù…Ø§Ù„Ùƒ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© ØªÙ†Ø²ÙŠÙ„Ù‡ ÙŠØ¯ÙˆÙŠØ§Ù‹"
                                    )
                            else:
                                remaining = kick_limit - current_kicks
                                await context.bot.send_message(
                                    chat_id=chat.id,
                                    text=f"âš ï¸ ØªØ­Ø°ÙŠØ±: {kicked_by.first_name} Ù‚Ø§Ù… Ø¨Ø·Ø±Ø¯ Ø¹Ø¶Ùˆ\nØ¹Ø¯Ø¯ Ø§Ù„Ø·Ø±Ø¯: {current_kicks}/{kick_limit}\nÙ…ØªØ¨Ù‚ÙŠ: {remaining}"
                                )
        
        async def handle_my_chat_member(update: Update, context: ContextTypes.DEFAULT_TYPE):
            my_chat_member = update.my_chat_member
            if my_chat_member is None:
                return
            
            chat = my_chat_member.chat
            old_status = my_chat_member.old_chat_member.status
            new_status = my_chat_member.new_chat_member.status
            
            guard_data = get_guard_data()
            bot_key = f"guard_{token[:20]}"
            if bot_key not in guard_data:
                guard_data[bot_key] = {'kick_limit': 3, 'channels': [], 'groups': [], 'users': []}
            
            if new_status == 'administrator' and old_status != 'administrator':
                if chat.type in ['group', 'supergroup']:
                    if str(chat.id) not in guard_data[bot_key].get('groups', []):
                        guard_data[bot_key]['groups'] = guard_data[bot_key].get('groups', []) + [str(chat.id)]
                    save_guard_data(guard_data)
                    
                    keyboard = [[InlineKeyboardButton("Ù‚Ù†Ø§Ù‡ Ø§Ù„Ø³ÙˆØ±Ø³", url="https://t.me/Tepthon")]]
                    welcome_text = """â€» ØªÙ… ØªÙØ¹ÙŠÙ„ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ù‡ Ø¨Ù†Ø¬Ø§Ø­ Ø³ÙˆÙ Ø§Ø­Ù…ÙŠ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ù‡ Ù…Ù† Ø§Ù„Ù…Ø®Ø±Ø¨ÙŠÙ† ğŸª©

Ø§Ù„Ù‚Ù†Ø§Ù‡ @Tepthon"""
                    try:
                        await context.bot.send_message(
                            chat_id=chat.id,
                            text=welcome_text,
                            reply_markup=InlineKeyboardMarkup(keyboard)
                        )
                    except:
                        pass
                elif chat.type == 'channel':
                    if str(chat.id) not in guard_data[bot_key].get('channels', []):
                        guard_data[bot_key]['channels'] = guard_data[bot_key].get('channels', []) + [str(chat.id)]
                    save_guard_data(guard_data)
            elif new_status in ['member']:
                if chat.type == 'channel':
                    if str(chat.id) not in guard_data[bot_key].get('channels', []):
                        guard_data[bot_key]['channels'] = guard_data[bot_key].get('channels', []) + [str(chat.id)]
                elif chat.type in ['group', 'supergroup']:
                    if str(chat.id) not in guard_data[bot_key].get('groups', []):
                        guard_data[bot_key]['groups'] = guard_data[bot_key].get('groups', []) + [str(chat.id)]
                save_guard_data(guard_data)
            elif new_status in ['left', 'kicked']:
                if str(chat.id) in guard_data[bot_key].get('channels', []):
                    guard_data[bot_key]['channels'].remove(str(chat.id))
                if str(chat.id) in guard_data[bot_key].get('groups', []):
                    guard_data[bot_key]['groups'].remove(str(chat.id))
                save_guard_data(guard_data)
        
        from telegram.ext import ChatMemberHandler
        
        app.add_handler(CommandHandler('start', guard_start))
        app.add_handler(CallbackQueryHandler(guard_callback))
        app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, guard_message))
        app.add_handler(ChatMemberHandler(handle_chat_member, ChatMemberHandler.CHAT_MEMBER))
        app.add_handler(ChatMemberHandler(handle_my_chat_member, ChatMemberHandler.MY_CHAT_MEMBER))
        
        await app.initialize()
        await app.start()
        await app.updater.start_polling(drop_pending_updates=True, allowed_updates=Update.ALL_TYPES)
        
        running_bot_apps[token] = app
        logger.info(f"Guard Bot started successfully")
        
    except Exception as e:
        logger.error(f"Error starting Guard bot: {e}")

async def send_adhkar_to_chat(bot_token: str, chat_id: int):
    try:
        bot = Bot(token=bot_token)
        dhikr = random.choice(ADHKAR_LIST)
        await bot.send_message(chat_id=chat_id, text=dhikr)
        logger.info(f"Sent adhkar to chat {chat_id}")
    except Exception as e:
        logger.error(f"Error sending adhkar to {chat_id}: {e}")

def sync_send_adhkar(bot_token: str, chat_id: int):
    try:
        loop = asyncio.get_event_loop()
        if loop.is_running():
            asyncio.ensure_future(send_adhkar_to_chat(bot_token, chat_id))
        else:
            loop.run_until_complete(send_adhkar_to_chat(bot_token, chat_id))
    except RuntimeError:
        new_loop = asyncio.new_event_loop()
        asyncio.set_event_loop(new_loop)
        new_loop.run_until_complete(send_adhkar_to_chat(bot_token, chat_id))

def register_adhkar_job(bot_token: str, chat_id: int, interval: int, end_date: datetime = None):
    job_id = f"adhkar_{bot_token[:10]}_{chat_id}"
    
    try:
        main_scheduler.remove_job(job_id)
    except JobLookupError:
        pass
    
    if end_date is None:
        main_scheduler.add_job(
            sync_send_adhkar,
            'interval',
            minutes=interval,
            id=job_id,
            args=[bot_token, chat_id]
        )
    else:
        main_scheduler.add_job(
            sync_send_adhkar,
            'interval',
            minutes=interval,
            id=job_id,
            args=[bot_token, chat_id],
            end_date=end_date
        )
    
    logger.info(f"Registered adhkar job for chat {chat_id} every {interval} minutes")
    return job_id

def schedule_adhkar(bot_token: str, chat_id: int, interval: int, duration: int = 0):
    if duration == 0:
        end_date = None
        end_date_str = None
    else:
        end_date = datetime.now() + timedelta(days=duration)
        end_date_str = end_date.isoformat()
    
    job_id = register_adhkar_job(bot_token, chat_id, interval, end_date)
    
    schedules_data = get_schedules_data()
    schedules_data[job_id] = {
        "bot_token": bot_token,
        "chat_id": chat_id,
        "interval": interval,
        "created": datetime.now().isoformat(),
        "end_date": end_date_str
    }
    save_schedules_data(schedules_data)
    
    logger.info(f"Scheduled adhkar for chat {chat_id} every {interval} minutes")

def restore_schedules():
    schedules_data = get_schedules_data()
    now = datetime.now()
    expired_jobs = []
    
    for job_id, schedule in schedules_data.items():
        end_date_str = schedule.get('end_date')
        end_date = None
        
        if end_date_str:
            end_date = datetime.fromisoformat(end_date_str)
            if end_date < now:
                expired_jobs.append(job_id)
                logger.info(f"Schedule {job_id} expired, removing")
                continue
        
        try:
            bot_token = schedule['bot_token']
            chat_id = schedule['chat_id']
            interval = schedule['interval']
            
            register_adhkar_job(bot_token, chat_id, interval, end_date)
            logger.info(f"Restored schedule for chat {chat_id}")
        except Exception as e:
            logger.error(f"Error restoring schedule {job_id}: {e}")
    
    if expired_jobs:
        for job_id in expired_jobs:
            del schedules_data[job_id]
        save_schedules_data(schedules_data)

async def start_adhkar_bot(token: str, owner_id: int):
    try:
        app = Application.builder().token(token).build()
        adhkar_user_states = {}
        
        async def adhkar_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
            user = update.effective_user
            message = update.message
            if user is None or message is None:
                return
            first_name = user.first_name or "ØµØ¯ÙŠÙ‚ÙŠ"
            
            bots_data = get_bots_data()
            bot_data = bots_data.get(token, {})
            owner_name = bot_data.get('owner_name', first_name)
            
            keyboard = [
                [
                    InlineKeyboardButton("Ø§Ø¹Ø¯Ø§Ø¯Ø§Øª Ù‚Ù†Ø§ØªÙƒ", callback_data="channel_settings"),
                    InlineKeyboardButton("Ø§Ø¹Ø¯Ø§Ø¯Ø§Øª Ù…Ø¬Ù…ÙˆØ¹ØªÙƒ", callback_data="group_settings")
                ],
                [InlineKeyboardButton("Ù…ÙˆØ§Ø¹ÙŠØ¯ Ø§Ù„ØµÙ„Ø§Ø© ğŸ•Œ", callback_data="prayer_settings")],
                [InlineKeyboardButton("Ø§Ø¶Ù Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ù‰ Ù…Ø¬Ù…ÙˆØ¹ØªÙƒ ğŸ–ï¸", callback_data="add_info")]
            ]
            
            if user.id == owner_id:
                keyboard.append([
                    InlineKeyboardButton("Ù„ÙˆØ­Ø© Ø§Ù„Ø§Ø¯Ù…Ù† ğŸ–ï¸", callback_data="adhkar_admin")
                ])
            
            text = f"""â€» ÙŠØ§Ù‡Ù„Ø§ ÙˆØ³Ù‡Ù„Ø§ ÙŠØ§ {first_name} ÙÙŠ Ø¨ÙˆØª Ø£Ø°ÙƒØ§Ø±ÙŠ ğŸ“¿

â Ø¨ÙˆØª Ù…Ø®ØµØµ Ù„Ù†Ø´Ø± :
â€¢  Ø§Ù„Ø£Ø°ÙƒØ§Ø± ÙˆØ§Ù„Ø£Ø¯Ø¹ÙŠØ©
â€¢ Ø§Ù„Ø£Ø­Ø§Ø¯ÙŠØ« Ø§Ù„Ù†Ø¨ÙˆÙŠØ©
â€¢ Ø§Ù„Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ø¯ÙŠÙ†ÙŠØ© ÙˆØ§Ù„Ù‚Ø±Ø§Ù†ÙŠØ© ğŸ“¿ 
â€¢ Ø¢ÙŠØ§Øª Ù…Ù† Ø§Ù„Ù‚Ø±Ø¢Ù† Ø§Ù„ÙƒØ±ÙŠÙ… ğŸ“– 

â ÙŠØ¹Ù…Ù„ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§ Ø¯Ø§Ø®Ù„ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª ÙˆØ§Ù„Ù‚Ù†ÙˆØ§ØªØŒ ÙˆÙŠÙØ±Ø³Ù„ Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ø¨Ø´ÙƒÙ„ Ù…Ù†Ø¸Ù… Ø¹Ù„ÙŠ Ø­Ø³Ø¨ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª .

â€» Ø§Ù„Ù…Ø·ÙˆØ±: {owner_name}"""
            
            await message.reply_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
        
        async def adhkar_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
            query = update.callback_query
            if query is None:
                return
            await query.answer()
            user = query.from_user
            if user is None:
                return
            data = query.data
            
            if data == "add_info":
                text = """â€» Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø§Ø¶Ø§ÙØ©

1- Ø§Ø¶Ù Ø§Ù„Ø¨ÙˆØª Ù„Ù„Ù‚Ù†Ø§Ø© Ø§Ùˆ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© ÙƒÙ…Ø´Ø±Ù
2- Ø§Ø¹Ø·Ù‡ ØµÙ„Ø§Ø­ÙŠØ© Ø§Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„
3- Ø§Ø±Ø¬Ø¹ Ù‡Ù†Ø§ ÙˆØ§Ø®ØªØ± Ø§Ø¹Ø¯Ø§Ø¯Ø§Øª Ù‚Ù†Ø§ØªÙƒ Ø§Ùˆ Ù…Ø¬Ù…ÙˆØ¹ØªÙƒ"""
                keyboard = [[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹", callback_data="back_adhkar")]]
                await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
                return
            
            if data in ["channel_settings", "group_settings"]:
                setting_type = 'channel' if data == "channel_settings" else 'group'
                chat_type = "Ù‚Ù†Ø§ØªÙƒ" if data == "channel_settings" else "Ù…Ø¬Ù…ÙˆØ¹ØªÙƒ"
                adhkar_user_states[user.id] = {'setting_type': setting_type}
                
                user_chats = get_user_chats(token, user.id, setting_type)
                
                keyboard = []
                if user_chats:
                    for chat in user_chats:
                        keyboard.append([InlineKeyboardButton(
                            f"ğŸ“Œ {chat['title']}", 
                            callback_data=f"manage_{chat['chat_id']}"
                        )])
                
                keyboard.append([InlineKeyboardButton("â• Ø§Ø¶Ø§ÙØ© Ø¬Ø¯ÙŠØ¯Ø©", callback_data=f"add_new_{setting_type}")])
                keyboard.append([InlineKeyboardButton("Ø±Ø¬ÙˆØ¹", callback_data="back_adhkar")])
                
                if user_chats:
                    text = f"""â€» Ø§Ø¹Ø¯Ø§Ø¯Ø§Øª {chat_type}

Ø§Ø®ØªØ± Ù…Ù† Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ùˆ Ø§Ø¶Ù Ø¬Ø¯ÙŠØ¯Ø©"""
                else:
                    text = f"""â€» Ø§Ø¹Ø¯Ø§Ø¯Ø§Øª {chat_type}

Ù„Ø§ ØªÙˆØ¬Ø¯ Ù„Ø¯ÙŠÙƒ {chat_type} Ù…Ø¶Ø§ÙØ©
Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ø¶Ø§ÙØ© Ø¬Ø¯ÙŠØ¯Ø© Ù„Ø§Ø¶Ø§ÙØ© ÙˆØ§Ø­Ø¯Ø©"""
                
                await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
                return
            
            if data.startswith("add_new_"):
                setting_type = data.replace("add_new_", "")
                chat_type = "Ù‚Ù†Ø§ØªÙƒ" if setting_type == "channel" else "Ù…Ø¬Ù…ÙˆØ¹ØªÙƒ"
                adhkar_user_states[user.id] = {'setting_type': setting_type, 'adding_new': True}
                
                text = f"""â€» Ø§Ø¶Ø§ÙØ© {chat_type}

Ø§Ø±Ø³Ù„ Ø§ÙŠØ¯ÙŠ {chat_type} Ø§Ùˆ ÙÙˆØ±ÙˆØ±Ø¯ Ø±Ø³Ø§Ù„Ø© Ù…Ù†Ù‡Ø§
Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø§ÙŠØ¯ÙŠ Ø§Ø³ØªØ®Ø¯Ù… @username_to_id_bot"""
                keyboard = [[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹", callback_data="back_adhkar")]]
                await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
                return
            
            if data.startswith("manage_"):
                chat_id = int(data.replace("manage_", ""))
                try:
                    chat = await context.bot.get_chat(chat_id)
                    chat_title = chat.title or "ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ"
                except:
                    await query.answer("ØªØ¹Ø°Ø± Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ù„Ù…Ø­Ø§Ø¯Ø«Ø©", show_alert=True)
                    return
                
                keyboard = [
                    [
                        InlineKeyboardButton("5 Ø¯Ù‚Ø§ÙŠÙ‚", callback_data=f"interval_{chat_id}_5"),
                        InlineKeyboardButton("Ø±Ø¨Ø¹ Ø³Ø§Ø¹Ø©", callback_data=f"interval_{chat_id}_15")
                    ],
                    [
                        InlineKeyboardButton("Ø³Ø§Ø¹Ø©", callback_data=f"interval_{chat_id}_60"),
                        InlineKeyboardButton("Ø³Ø§Ø¹ØªÙŠÙ†", callback_data=f"interval_{chat_id}_120")
                    ],
                    [
                        InlineKeyboardButton("3 Ø³Ø§Ø¹Ø§Øª", callback_data=f"interval_{chat_id}_180"),
                        InlineKeyboardButton("4 Ø³Ø§Ø¹Ø§Øª", callback_data=f"interval_{chat_id}_240")
                    ],
                    [InlineKeyboardButton("Ø±Ø¬ÙˆØ¹", callback_data="back_adhkar")]
                ]
                
                text = f"""â€» Ø§Ø¹Ø¯Ø§Ø¯Ø§Øª: {chat_title}

Ø§Ø®ØªØ± ÙƒÙ„ Ù‚Ø¯ Ø§ÙŠÙ‡ ØªÙ†Ø´Ø± Ø§Ù„Ø§Ø°ÙƒØ§Ø±"""
                
                await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
                return
            
            if data == "adhkar_admin":
                if user.id != owner_id:
                    await query.answer("Ù„Ù„Ù…Ø§Ù„Ùƒ ÙÙ‚Ø·", show_alert=True)
                    return
                
                schedules_data = get_schedules_data()
                active_schedules = sum(1 for k in schedules_data.keys() if k.startswith(f"adhkar_{token[:10]}"))
                
                text = f"""â€» Ù„ÙˆØ­Ø© ØªØ­ÙƒÙ… Ø§Ù„Ø§Ø¯Ù…Ù†

â Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ø§Ù„Ù†Ø´Ø·Ø©: {active_schedules}

Ø§Ø®ØªØ± Ù…Ù† Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©:"""
                
                keyboard = [
                    [
                        InlineKeyboardButton("Ø§Ù„Ø§Ø­ØµØ§Ø¦ÙŠØ§Øª ğŸ“Š", callback_data="adhkar_stats"),
                        InlineKeyboardButton("Ø§Ø°Ø§Ø¹Ø© ğŸ“¢", callback_data="adhkar_broadcast")
                    ],
                    [
                        InlineKeyboardButton("Ø­Ø¸Ø± Ù…Ø³ØªØ®Ø¯Ù… âŒ", callback_data="adhkar_ban"),
                        InlineKeyboardButton("ÙÙƒ Ø­Ø¸Ø± âœ…", callback_data="adhkar_unban")
                    ],
                    [InlineKeyboardButton("Ø±Ø¬ÙˆØ¹", callback_data="back_adhkar")]
                ]
                await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
                return
            
            if data == "adhkar_stats":
                if user.id != owner_id:
                    await query.answer("Ù„Ù„Ù…Ø§Ù„Ùƒ ÙÙ‚Ø·", show_alert=True)
                    return
                
                schedules_data = get_schedules_data()
                active_schedules = [(k, v) for k, v in schedules_data.items() if k.startswith(f"adhkar_{token[:10]}")]
                
                text = f"""â€» Ø§Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø¨ÙˆØª

â Ø¹Ø¯Ø¯ Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ø§Ù„Ù†Ø´Ø·Ø©: {len(active_schedules)}"""
                
                for job_id, schedule in active_schedules[:5]:
                    interval = schedule.get('interval', 0)
                    chat_id = schedule.get('chat_id', 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')
                    text += f"\nâ€¢ Ù…Ø­Ø§Ø¯Ø«Ø© {chat_id}: ÙƒÙ„ {interval} Ø¯Ù‚ÙŠÙ‚Ø©"
                
                keyboard = [[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹", callback_data="adhkar_admin")]]
                await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
                return
            
            if data == "adhkar_broadcast":
                if user.id != owner_id:
                    await query.answer("Ù„Ù„Ù…Ø§Ù„Ùƒ ÙÙ‚Ø·", show_alert=True)
                    return
                adhkar_user_states[user.id] = {'broadcasting': True}
                keyboard = [[InlineKeyboardButton("Ø§Ù„ØºØ§Ø¡", callback_data="adhkar_admin")]]
                await query.edit_message_text(
                    "â€» Ø§Ø°Ø§Ø¹Ø©\n\nØ§Ø±Ø³Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„ØªÙŠ ØªØ±ÙŠØ¯ Ø§Ø±Ø³Ø§Ù„Ù‡Ø§ Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù‚Ù†ÙˆØ§Øª ÙˆØ§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª:",
                    reply_markup=InlineKeyboardMarkup(keyboard)
                )
                return
            
            if data == "adhkar_ban":
                if user.id != owner_id:
                    await query.answer("Ù„Ù„Ù…Ø§Ù„Ùƒ ÙÙ‚Ø·", show_alert=True)
                    return
                adhkar_user_states[user.id] = {'banning': True}
                keyboard = [[InlineKeyboardButton("Ø§Ù„ØºØ§Ø¡", callback_data="adhkar_admin")]]
                await query.edit_message_text(
                    "â€» Ø­Ø¸Ø± Ù…Ø³ØªØ®Ø¯Ù…\n\nØ§Ø±Ø³Ù„ Ø§ÙŠØ¯ÙŠ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø°ÙŠ ØªØ±ÙŠØ¯ Ø­Ø¸Ø±Ù‡:",
                    reply_markup=InlineKeyboardMarkup(keyboard)
                )
                return
            
            if data == "adhkar_unban":
                if user.id != owner_id:
                    await query.answer("Ù„Ù„Ù…Ø§Ù„Ùƒ ÙÙ‚Ø·", show_alert=True)
                    return
                adhkar_user_states[user.id] = {'unbanning': True}
                keyboard = [[InlineKeyboardButton("Ø§Ù„ØºØ§Ø¡", callback_data="adhkar_admin")]]
                await query.edit_message_text(
                    "â€» ÙÙƒ Ø­Ø¸Ø±\n\nØ§Ø±Ø³Ù„ Ø§ÙŠØ¯ÙŠ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø°ÙŠ ØªØ±ÙŠØ¯ ÙÙƒ Ø­Ø¸Ø±Ù‡:",
                    reply_markup=InlineKeyboardMarkup(keyboard)
                )
                return
            
            if data == "prayer_settings":
                text = """â€» Ù…ÙˆØ§Ø¹ÙŠØ¯ Ø§Ù„ØµÙ„Ø§Ø© ğŸ•Œ

Ø§Ø®ØªØ± Ø§Ù„Ù…Ø­Ø§ÙØ¸Ø© Ù„ØªÙØ¹ÙŠÙ„ ØªÙ†Ø¨ÙŠÙ‡Ø§Øª Ø§Ù„ØµÙ„Ø§Ø©:"""
                
                keyboard = [
                    [
                        InlineKeyboardButton("Ø§Ù„Ù‚Ø§Ù‡Ø±Ù‡", callback_data="prayer_cairo"),
                        InlineKeyboardButton("Ø¨ÙˆØ±Ø³Ø¹ÙŠØ¯", callback_data="prayer_portsaid")
                    ],
                    [
                        InlineKeyboardButton("Ø§Ø³ÙƒÙ†Ø¯Ø±ÙŠÙ‡", callback_data="prayer_alex"),
                        InlineKeyboardButton("Ø¯Ù…ÙŠØ§Ø·", callback_data="prayer_damietta")
                    ],
                    [
                        InlineKeyboardButton("Ø§Ù„Ø¬ÙŠØ²Ù‡", callback_data="prayer_giza"),
                        InlineKeyboardButton("Ø§Ù„Ø´Ø±Ù‚ÙŠÙ‡", callback_data="prayer_sharqia")
                    ],
                    [InlineKeyboardButton("Ø±Ø¬ÙˆØ¹", callback_data="back_adhkar")]
                ]
                await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
                return
            
            if data.startswith("prayer_"):
                city = data.replace("prayer_", "")
                city_names = {
                    'cairo': 'Ø§Ù„Ù‚Ø§Ù‡Ø±Ù‡',
                    'portsaid': 'Ø¨ÙˆØ±Ø³Ø¹ÙŠØ¯',
                    'alex': 'Ø§Ù„Ø§Ø³ÙƒÙ†Ø¯Ø±ÙŠÙ‡',
                    'damietta': 'Ø¯Ù…ÙŠØ§Ø·',
                    'giza': 'Ø§Ù„Ø¬ÙŠØ²Ù‡',
                    'sharqia': 'Ø§Ù„Ø´Ø±Ù‚ÙŠÙ‡'
                }
                city_name = city_names.get(city, 'Ø§Ù„Ù‚Ø§Ù‡Ø±Ù‡')
                
                adhkar_user_states[user.id] = {'setting_prayer': True, 'city': city, 'city_name': city_name}
                
                text = f"""â€» ØªÙØ¹ÙŠÙ„ Ù…ÙˆØ§Ø¹ÙŠØ¯ Ø§Ù„ØµÙ„Ø§Ø©

Ø§Ù„Ù…Ø­Ø§ÙØ¸Ø©: {city_name}

Ø§Ø±Ø³Ù„ Ø§ÙŠØ¯ÙŠ Ø§Ù„Ù‚Ù†Ø§Ø© Ø§Ùˆ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© Ù„ØªÙØ¹ÙŠÙ„ Ø§Ù„ØªÙ†Ø¨ÙŠÙ‡Ø§Øª ÙÙŠÙ‡Ø§"""
                
                keyboard = [[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹", callback_data="prayer_settings")]]
                await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
                return
            
            if data == "back_adhkar":
                adhkar_user_states.pop(user.id, None)
                first_name = user.first_name or "ØµØ¯ÙŠÙ‚ÙŠ"
                
                bots_data = get_bots_data()
                bot_data = bots_data.get(token, {})
                owner_name = bot_data.get('owner_name', first_name)
                
                keyboard = [
                    [
                        InlineKeyboardButton("Ø§Ø¹Ø¯Ø§Ø¯Ø§Øª Ù‚Ù†Ø§ØªÙƒ", callback_data="channel_settings"),
                        InlineKeyboardButton("Ø§Ø¹Ø¯Ø§Ø¯Ø§Øª Ù…Ø¬Ù…ÙˆØ¹ØªÙƒ", callback_data="group_settings")
                    ],
                    [InlineKeyboardButton("Ù…ÙˆØ§Ø¹ÙŠØ¯ Ø§Ù„ØµÙ„Ø§Ø© ğŸ•Œ", callback_data="prayer_settings")],
                    [InlineKeyboardButton("Ø§Ø¶Ù Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ù‰ Ù…Ø¬Ù…ÙˆØ¹ØªÙƒ ğŸ–ï¸", callback_data="add_info")]
                ]
                
                if user.id == owner_id:
                    keyboard.append([
                        InlineKeyboardButton("Ù„ÙˆØ­Ø© Ø§Ù„Ø§Ø¯Ù…Ù† ğŸ–ï¸", callback_data="adhkar_admin")
                    ])
                
                text = f"""â€» ÙŠØ§Ù‡Ù„Ø§ ÙˆØ³Ù‡Ù„Ø§ ÙŠØ§ {first_name} ÙÙŠ Ø¨ÙˆØª Ø£Ø°ÙƒØ§Ø±ÙŠ ğŸ“¿

â Ø¨ÙˆØª Ù…Ø®ØµØµ Ù„Ù†Ø´Ø± :
â€¢  Ø§Ù„Ø£Ø°ÙƒØ§Ø± ÙˆØ§Ù„Ø£Ø¯Ø¹ÙŠØ©
â€¢ Ø§Ù„Ø£Ø­Ø§Ø¯ÙŠØ« Ø§Ù„Ù†Ø¨ÙˆÙŠØ©
â€¢ Ø§Ù„Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ø¯ÙŠÙ†ÙŠØ© ÙˆØ§Ù„Ù‚Ø±Ø§Ù†ÙŠØ© ğŸ“¿ 
â€¢ Ø¢ÙŠØ§Øª Ù…Ù† Ø§Ù„Ù‚Ø±Ø¢Ù† Ø§Ù„ÙƒØ±ÙŠÙ… ğŸ“– 

â ÙŠØ¹Ù…Ù„ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§ Ø¯Ø§Ø®Ù„ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª ÙˆØ§Ù„Ù‚Ù†ÙˆØ§ØªØŒ ÙˆÙŠÙØ±Ø³Ù„ Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ø¨Ø´ÙƒÙ„ Ù…Ù†Ø¸Ù… Ø¹Ù„ÙŠ Ø­Ø³Ø¨ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª .

â€» Ø§Ù„Ù…Ø·ÙˆØ±: {owner_name}"""
                await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
                return
            
            if data.startswith("interval_"):
                parts = data.split("_")
                chat_id = parts[1]
                interval = int(parts[2])
                
                duration_text = {
                    5: "5 Ø¯Ù‚Ø§ÙŠÙ‚",
                    15: "Ø±Ø¨Ø¹ Ø³Ø§Ø¹Ø©",
                    60: "Ø³Ø§Ø¹Ø©",
                    120: "Ø³Ø§Ø¹ØªÙŠÙ†",
                    180: "3 Ø³Ø§Ø¹Ø§Øª",
                    240: "4 Ø³Ø§Ø¹Ø§Øª"
                }.get(interval, f"{interval} Ø¯Ù‚ÙŠÙ‚Ø©")
                
                adhkar_user_states[user.id] = {
                    'pending_schedule': {
                        'chat_id': int(chat_id),
                        'interval': interval
                    }
                }
                
                keyboard = [
                    [
                        InlineKeyboardButton("ÙŠÙˆÙ…", callback_data=f"duration_{chat_id}_{interval}_1"),
                        InlineKeyboardButton("Ø§Ø³Ø¨ÙˆØ¹", callback_data=f"duration_{chat_id}_{interval}_7")
                    ],
                    [InlineKeyboardButton("Ø¯Ø§Ø¦Ù…", callback_data=f"duration_{chat_id}_{interval}_0")],
                    [InlineKeyboardButton("Ø±Ø¬ÙˆØ¹", callback_data="back_adhkar")]
                ]
                
                text = f"""â€» Ø§Ø®ØªØ± Ù…Ø¯Ø© Ø§Ù„Ù†Ø´Ø±

Ø§Ù„ÙØªØ±Ø©: ÙƒÙ„ {duration_text}

Ø§Ø®ØªØ± ÙƒÙ… ÙŠÙˆÙ… ØªØ±ÙŠØ¯ Ø§Ù„Ù†Ø´Ø±"""
                await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
                return
            
            if data.startswith("duration_"):
                parts = data.split("_")
                chat_id = int(parts[1])
                interval = int(parts[2])
                duration = int(parts[3])
                
                schedule_adhkar(token, chat_id, interval, duration)
                
                interval_text = {
                    5: "5 Ø¯Ù‚Ø§ÙŠÙ‚",
                    15: "Ø±Ø¨Ø¹ Ø³Ø§Ø¹Ø©",
                    60: "Ø³Ø§Ø¹Ø©",
                    120: "Ø³Ø§Ø¹ØªÙŠÙ†",
                    180: "3 Ø³Ø§Ø¹Ø§Øª",
                    240: "4 Ø³Ø§Ø¹Ø§Øª"
                }.get(interval, f"{interval} Ø¯Ù‚ÙŠÙ‚Ø©")
                
                duration_text = "Ø¯Ø§Ø¦Ù…" if duration == 0 else (f"{duration} ÙŠÙˆÙ…" if duration == 1 else f"{duration} Ø§ÙŠØ§Ù…")
                
                text = f"""â€» ØªÙ… ØªÙØ¹ÙŠÙ„ Ø§Ù„Ù†Ø´Ø± Ø¨Ù†Ø¬Ø§Ø­

Ø§Ù„ÙØªØ±Ø©: ÙƒÙ„ {interval_text}
Ø§Ù„Ù…Ø¯Ø©: {duration_text}

Ø³ÙŠØªÙ… Ù†Ø´Ø± Ø§Ù„Ø§Ø°ÙƒØ§Ø± ØªÙ„Ù‚Ø§Ø¦ÙŠØ§"""
                
                keyboard = [[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø©", callback_data="back_adhkar")]]
                await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
                adhkar_user_states.pop(user.id, None)
                return
        
        async def adhkar_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
            user = update.effective_user
            message = update.message
            if user is None or message is None:
                return
            
            user_state = adhkar_user_states.get(user.id, {})
            message_text = message.text or ""
            
            if user_state.get('broadcasting') and user.id == owner_id:
                schedules_data = get_schedules_data()
                chats = [v['chat_id'] for k, v in schedules_data.items() if k.startswith(f"adhkar_{token[:10]}")]
                
                success = 0
                failed = 0
                for chat_id in set(chats):
                    try:
                        await context.bot.send_message(chat_id=chat_id, text=message_text)
                        success += 1
                    except:
                        failed += 1
                
                await message.reply_text(f"âœ… ØªÙ… Ø§Ù„Ø§Ø±Ø³Ø§Ù„\nÙ†Ø¬Ø­: {success}\nÙØ´Ù„: {failed}")
                adhkar_user_states.pop(user.id, None)
                return
            
            if user_state.get('banning') and user.id == owner_id:
                try:
                    ban_id = int(message_text.strip())
                    bots_data = get_bots_data()
                    if token in bots_data:
                        if 'banned_users' not in bots_data[token]:
                            bots_data[token]['banned_users'] = []
                        if ban_id not in bots_data[token]['banned_users']:
                            bots_data[token]['banned_users'].append(ban_id)
                            save_bots_data(bots_data)
                            await message.reply_text(f"âœ… ØªÙ… Ø­Ø¸Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… {ban_id}")
                        else:
                            await message.reply_text("Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø­Ø¸ÙˆØ± Ø¨Ø§Ù„ÙØ¹Ù„")
                except:
                    await message.reply_text("Ø§Ø±Ø³Ù„ Ø§ÙŠØ¯ÙŠ ØµØ­ÙŠØ­")
                adhkar_user_states.pop(user.id, None)
                return
            
            if user_state.get('unbanning') and user.id == owner_id:
                try:
                    unban_id = int(message_text.strip())
                    bots_data = get_bots_data()
                    if token in bots_data and 'banned_users' in bots_data[token]:
                        if unban_id in bots_data[token]['banned_users']:
                            bots_data[token]['banned_users'].remove(unban_id)
                            save_bots_data(bots_data)
                            await message.reply_text(f"âœ… ØªÙ… ÙÙƒ Ø­Ø¸Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… {unban_id}")
                        else:
                            await message.reply_text("Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ØºÙŠØ± Ù…Ø­Ø¸ÙˆØ±")
                    else:
                        await message.reply_text("Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ù…Ø­Ø¸ÙˆØ±ÙŠÙ†")
                except:
                    await message.reply_text("Ø§Ø±Ø³Ù„ Ø§ÙŠØ¯ÙŠ ØµØ­ÙŠØ­")
                adhkar_user_states.pop(user.id, None)
                return
            
            if user_state.get('setting_prayer'):
                try:
                    prayer_chat_id = int(message_text.strip())
                    city = user_state.get('city', 'cairo')
                    city_name = user_state.get('city_name', 'Ø§Ù„Ù‚Ø§Ù‡Ø±Ù‡')
                    
                    try:
                        chat = await context.bot.get_chat(prayer_chat_id)
                        chat_title = chat.title or "ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ"
                    except:
                        await message.reply_text("ØªØ£ÙƒØ¯ Ø§Ù† Ø§Ù„Ø¨ÙˆØª Ù…Ø¶Ø§Ù Ù„Ù„Ù‚Ù†Ø§Ø©/Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© ÙƒÙ…Ø´Ø±Ù")
                        return
                    
                    bots_data = get_bots_data()
                    if token in bots_data:
                        if 'prayer_chats' not in bots_data[token]:
                            bots_data[token]['prayer_chats'] = {}
                        bots_data[token]['prayer_chats'][str(prayer_chat_id)] = {
                            'city': city,
                            'city_name': city_name,
                            'title': chat_title
                        }
                        save_bots_data(bots_data)
                    
                    await message.reply_text(f"""âœ… ØªÙ… ØªÙØ¹ÙŠÙ„ Ù…ÙˆØ§Ø¹ÙŠØ¯ Ø§Ù„ØµÙ„Ø§Ø©

Ø§Ù„Ù…Ø­Ø§ÙØ¸Ø©: {city_name}
Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø©: {chat_title}

Ø³ÙŠØªÙ… Ø§Ø±Ø³Ø§Ù„ ØªÙ†Ø¨ÙŠÙ‡Ø§Øª Ø§Ù„ØµÙ„Ø§Ø© ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹""")
                    adhkar_user_states.pop(user.id, None)
                    return
                except:
                    await message.reply_text("Ø§Ø±Ø³Ù„ Ø§ÙŠØ¯ÙŠ ØµØ­ÙŠØ­")
                    return
            
            if not user_state.get('setting_type'):
                return
            
            chat_id = None
            
            if message.forward_origin:
                try:
                    if hasattr(message.forward_origin, 'chat'):
                        chat_id = message.forward_origin.chat.id
                except:
                    pass
            
            if chat_id is None and message.text:
                try:
                    chat_id = int(message.text.strip())
                except:
                    await message.reply_text("Ø§Ø±Ø³Ù„ Ø§ÙŠØ¯ÙŠ ØµØ­ÙŠØ­ Ø§Ùˆ ÙÙˆØ±ÙˆØ±Ø¯ Ø±Ø³Ø§Ù„Ø© Ù…Ù† Ø§Ù„Ù‚Ù†Ø§Ø©/Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©")
                    return
            
            if chat_id is None:
                await message.reply_text("Ø§Ø±Ø³Ù„ Ø§ÙŠØ¯ÙŠ ØµØ­ÙŠØ­ Ø§Ùˆ ÙÙˆØ±ÙˆØ±Ø¯ Ø±Ø³Ø§Ù„Ø© Ù…Ù† Ø§Ù„Ù‚Ù†Ø§Ø©/Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©")
                return
            
            try:
                chat = await context.bot.get_chat(chat_id)
                chat_title = chat.title or "ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ"
            except:
                await message.reply_text("ØªØ£ÙƒØ¯ Ø§Ù† Ø§Ù„Ø¨ÙˆØª Ù…Ø¶Ø§Ù Ù„Ù„Ù‚Ù†Ø§Ø©/Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© ÙƒÙ…Ø´Ø±Ù")
                return
            
            setting_type = user_state.get('setting_type')
            add_user_chat(token, user.id, chat_id, chat_title, setting_type)
            
            keyboard = [
                [
                    InlineKeyboardButton("5 Ø¯Ù‚Ø§ÙŠÙ‚", callback_data=f"interval_{chat_id}_5"),
                    InlineKeyboardButton("Ø±Ø¨Ø¹ Ø³Ø§Ø¹Ø©", callback_data=f"interval_{chat_id}_15")
                ],
                [
                    InlineKeyboardButton("Ø³Ø§Ø¹Ø©", callback_data=f"interval_{chat_id}_60"),
                    InlineKeyboardButton("Ø³Ø§Ø¹ØªÙŠÙ†", callback_data=f"interval_{chat_id}_120")
                ],
                [
                    InlineKeyboardButton("3 Ø³Ø§Ø¹Ø§Øª", callback_data=f"interval_{chat_id}_180"),
                    InlineKeyboardButton("4 Ø³Ø§Ø¹Ø§Øª", callback_data=f"interval_{chat_id}_240")
                ],
                [InlineKeyboardButton("Ø±Ø¬ÙˆØ¹", callback_data="back_adhkar")]
            ]
            
            text = f"""â€» ØªÙ… Ø§Ù„ØªØ¹Ø±Ù Ø¹Ù„Ù‰: {chat_title}

Ø§Ø®ØªØ± ÙƒÙ„ Ù‚Ø¯ Ø§ÙŠÙ‡ ØªÙ†Ø´Ø± Ø§Ù„Ø§Ø°ÙƒØ§Ø±"""
            
            await message.reply_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
            adhkar_user_states.pop(user.id, None)
        
        app.add_handler(CommandHandler('start', adhkar_start))
        app.add_handler(CallbackQueryHandler(adhkar_callback))
        app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, adhkar_message))
        
        await app.initialize()
        await app.start()
        await app.updater.start_polling(drop_pending_updates=True)
        
        running_bot_apps[token] = app
        logger.info(f"Adhkar Bot started successfully")
        
    except Exception as e:
        logger.error(f"Error starting Adhkar bot: {e}")

def get_quiz_data():
    try:
        with open('quiz_data.json', 'r', encoding='utf-8') as f:
            return json.load(f)
    except:
        return {}

def save_quiz_data(data):
    with open('quiz_data.json', 'w', encoding='utf-8') as f:
        json.dump(data, f, ensure_ascii=False, indent=2)

async def start_quiz_bot(token: str, owner_id: int):
    try:
        app = Application.builder().token(token).build()
        quiz_user_states = {}
        
        def get_bot_users():
            quiz_data = get_quiz_data()
            bot_key = f"quiz_{token[:20]}"
            if bot_key not in quiz_data:
                quiz_data[bot_key] = {'users': {}, 'banned': [], 'total_answers': 0}
                save_quiz_data(quiz_data)
            return quiz_data.get(bot_key, {}).get('users', {})
        
        def save_user_score(user_id, first_name, points=0, correct=0, wrong=0):
            quiz_data = get_quiz_data()
            bot_key = f"quiz_{token[:20]}"
            if bot_key not in quiz_data:
                quiz_data[bot_key] = {'users': {}, 'banned': [], 'total_answers': 0}
            
            user_key = str(user_id)
            if user_key not in quiz_data[bot_key]['users']:
                quiz_data[bot_key]['users'][user_key] = {
                    'first_name': first_name,
                    'points': 0,
                    'correct': 0,
                    'wrong': 0,
                    'joined': datetime.now().isoformat()
                }
            
            quiz_data[bot_key]['users'][user_key]['points'] += points
            quiz_data[bot_key]['users'][user_key]['correct'] += correct
            quiz_data[bot_key]['users'][user_key]['wrong'] += wrong
            quiz_data[bot_key]['users'][user_key]['first_name'] = first_name
            quiz_data[bot_key]['total_answers'] += (correct + wrong)
            save_quiz_data(quiz_data)
            
            bots_data = get_bots_data()
            if token in bots_data:
                bots_data[token]['users_count'] = len(quiz_data[bot_key]['users'])
                save_bots_data(bots_data)
        
        def get_user_score(user_id):
            quiz_data = get_quiz_data()
            bot_key = f"quiz_{token[:20]}"
            return quiz_data.get(bot_key, {}).get('users', {}).get(str(user_id), {'points': 0, 'correct': 0, 'wrong': 0})
        
        def is_banned(user_id):
            quiz_data = get_quiz_data()
            bot_key = f"quiz_{token[:20]}"
            return user_id in quiz_data.get(bot_key, {}).get('banned', [])
        
        def get_leaderboard():
            users = get_bot_users()
            sorted_users = sorted(users.items(), key=lambda x: x[1].get('points', 0), reverse=True)
            return sorted_users[:10]
        
        def get_required_channel():
            bots_data = get_bots_data()
            return bots_data.get(token, {}).get('required_channel', REQUIRED_CHANNEL)
        
        async def check_quiz_subscription(user_id, bot):
            channel = get_required_channel()
            try:
                member = await bot.get_chat_member(chat_id=channel, user_id=user_id)
                return member.status in [ChatMemberStatus.MEMBER, ChatMemberStatus.ADMINISTRATOR, ChatMemberStatus.OWNER]
            except:
                return True
        
        def get_random_question():
            return random.choice(QUIZ_QUESTIONS)
        
        async def quiz_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
            user = update.effective_user
            if user is None:
                return
            
            if is_banned(user.id):
                await update.message.reply_text("Ø§Ù†Øª Ù…Ø­Ø¸ÙˆØ± Ù…Ù† Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¨ÙˆØª")
                return
            
            is_subscribed = await check_quiz_subscription(user.id, context.bot)
            if not is_subscribed:
                channel = get_required_channel()
                keyboard = [
                    [InlineKeyboardButton("Ø§Ø´ØªØ±Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø©", url=f"https://t.me/{channel[1:]}")],
                    [InlineKeyboardButton("ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ", callback_data="check_sub")]
                ]
                await update.message.reply_text(
                    "ÙŠØ¬Ø¨ Ø¹Ù„ÙŠÙƒ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø© Ø§ÙˆÙ„Ø§",
                    reply_markup=InlineKeyboardMarkup(keyboard)
                )
                return
            
            save_user_score(user.id, user.first_name)
            user_score = get_user_score(user.id)
            
            text = f"""â€» Ù…Ø±Ø­Ø¨Ø§Ù‹ {user.first_name} ÙÙŠ Ø¨ÙˆØª Ø§Ù„ÙƒÙˆÙŠØ²

â Ù†Ù‚Ø§Ø·Ùƒ: {user_score.get('points', 0)}
â Ø¥Ø¬Ø§Ø¨Ø§Øª ØµØ­ÙŠØ­Ø©: {user_score.get('correct', 0)}
â Ø¥Ø¬Ø§Ø¨Ø§Øª Ø®Ø§Ø·Ø¦Ø©: {user_score.get('wrong', 0)}

Ø§Ø®ØªØ± Ù…Ù† Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©:"""
            
            keyboard = [
                [
                    InlineKeyboardButton("Ø³Ø¤Ø§Ù„ Ø¹Ø´ÙˆØ§Ø¦ÙŠ", callback_data="random_q"),
                    InlineKeyboardButton("Ø§Ø®ØªØ± ØªØµÙ†ÙŠÙ", callback_data="choose_cat")
                ],
                [
                    InlineKeyboardButton("Ù†Ù‚Ø§Ø·ÙŠ", callback_data="my_score"),
                    InlineKeyboardButton("Ø§Ù„Ù…ØªØµØ¯Ø±ÙŠÙ†", callback_data="leaderboard")
                ]
            ]
            
            if user.id == owner_id:
                keyboard.append([InlineKeyboardButton("Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ…", callback_data="admin_panel")])
            
            await update.message.reply_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
        
        async def quiz_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
            query = update.callback_query
            if query is None:
                return
            await query.answer()
            
            user = query.from_user
            if user is None:
                return
            
            data = query.data
            
            if data == "check_sub":
                is_subscribed = await check_quiz_subscription(user.id, context.bot)
                if is_subscribed:
                    await query.message.delete()
                    save_user_score(user.id, user.first_name)
                    user_score = get_user_score(user.id)
                    
                    text = f"""â€» Ù…Ø±Ø­Ø¨Ø§Ù‹ {user.first_name} ÙÙŠ Ø¨ÙˆØª Ø§Ù„ÙƒÙˆÙŠØ²

â Ù†Ù‚Ø§Ø·Ùƒ: {user_score.get('points', 0)}
â Ø¥Ø¬Ø§Ø¨Ø§Øª ØµØ­ÙŠØ­Ø©: {user_score.get('correct', 0)}
â Ø¥Ø¬Ø§Ø¨Ø§Øª Ø®Ø§Ø·Ø¦Ø©: {user_score.get('wrong', 0)}

Ø§Ø®ØªØ± Ù…Ù† Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©:"""
                    
                    keyboard = [
                        [
                            InlineKeyboardButton("Ø³Ø¤Ø§Ù„ Ø¹Ø´ÙˆØ§Ø¦ÙŠ", callback_data="random_q"),
                            InlineKeyboardButton("Ø§Ø®ØªØ± ØªØµÙ†ÙŠÙ", callback_data="choose_cat")
                        ],
                        [
                            InlineKeyboardButton("Ù†Ù‚Ø§Ø·ÙŠ", callback_data="my_score"),
                            InlineKeyboardButton("Ø§Ù„Ù…ØªØµØ¯Ø±ÙŠÙ†", callback_data="leaderboard")
                        ]
                    ]
                    
                    if user.id == owner_id:
                        keyboard.append([InlineKeyboardButton("Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ…", callback_data="admin_panel")])
                    
                    await context.bot.send_message(chat_id=user.id, text=text, reply_markup=InlineKeyboardMarkup(keyboard))
                else:
                    await query.answer("Ù„Ù… ØªØ´ØªØ±Ùƒ Ø¨Ø¹Ø¯!", show_alert=True)
                return
            
            if data == "random_q" or data.startswith("cat_"):
                if data.startswith("cat_"):
                    category = data.replace("cat_", "")
                    questions = [q for q in QUIZ_QUESTIONS if q['category'] == category]
                    if not questions:
                        await query.answer("Ù„Ø§ ØªÙˆØ¬Ø¯ Ø§Ø³Ø¦Ù„Ø© ÙÙŠ Ù‡Ø°Ø§ Ø§Ù„ØªØµÙ†ÙŠÙ", show_alert=True)
                        return
                    question = random.choice(questions)
                else:
                    question = get_random_question()
                
                q_index = QUIZ_QUESTIONS.index(question)
                options = question['options']
                
                text = f"""â€» Ø³Ø¤Ø§Ù„ | Ø§Ù„ØªØµÙ†ÙŠÙ: {question['category']}

{question['question']}"""
                
                keyboard = [
                    [
                        InlineKeyboardButton(f"ğŸ…°ï¸ {options[0]}", callback_data=f"ans_{q_index}_0"),
                        InlineKeyboardButton(f"ğŸ…±ï¸ {options[1]}", callback_data=f"ans_{q_index}_1")
                    ],
                    [
                        InlineKeyboardButton(f"Â©ï¸ {options[2]}", callback_data=f"ans_{q_index}_2"),
                        InlineKeyboardButton(f"ğŸ…³ï¸ {options[3]}", callback_data=f"ans_{q_index}_3")
                    ]
                ]
                
                await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
                return
            
            if data.startswith("ans_"):
                parts = data.split("_")
                q_index = int(parts[1])
                selected = int(parts[2])
                
                question = QUIZ_QUESTIONS[q_index]
                correct_answer = question['answer']
                
                if selected == correct_answer:
                    save_user_score(user.id, user.first_name, points=10, correct=1)
                    user_score = get_user_score(user.id)
                    text = f"""âœ… Ø¥Ø¬Ø§Ø¨Ø© ØµØ­ÙŠØ­Ø©!

Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø©: {question['options'][correct_answer]}

+10 Ù†Ù‚Ø§Ø·
Ù…Ø¬Ù…ÙˆØ¹ Ù†Ù‚Ø§Ø·Ùƒ: {user_score.get('points', 0)}"""
                else:
                    save_user_score(user.id, user.first_name, points=0, wrong=1)
                    text = f"""âŒ Ø¥Ø¬Ø§Ø¨Ø© Ø®Ø§Ø·Ø¦Ø©!

Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„ØµØ­ÙŠØ­Ø©: {question['options'][correct_answer]}
Ø§Ø®ØªÙŠØ§Ø±Ùƒ: {question['options'][selected]}"""
                
                keyboard = [
                    [InlineKeyboardButton("Ø³Ø¤Ø§Ù„ Ø¬Ø¯ÙŠØ¯", callback_data="random_q")],
                    [InlineKeyboardButton("Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©", callback_data="back_main")]
                ]
                
                await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
                return
            
            if data == "choose_cat":
                categories = list(set(q['category'] for q in QUIZ_QUESTIONS))
                keyboard = []
                row = []
                for cat in categories:
                    row.append(InlineKeyboardButton(cat, callback_data=f"cat_{cat}"))
                    if len(row) == 2:
                        keyboard.append(row)
                        row = []
                if row:
                    keyboard.append(row)
                keyboard.append([InlineKeyboardButton("Ø±Ø¬ÙˆØ¹", callback_data="back_main")])
                
                await query.edit_message_text("â€» Ø§Ø®ØªØ± Ø§Ù„ØªØµÙ†ÙŠÙ:", reply_markup=InlineKeyboardMarkup(keyboard))
                return
            
            if data == "my_score":
                user_score = get_user_score(user.id)
                total = user_score.get('correct', 0) + user_score.get('wrong', 0)
                accuracy = (user_score.get('correct', 0) / total * 100) if total > 0 else 0
                
                text = f"""â€» Ø¥Ø­ØµØ§Ø¦ÙŠØ§ØªÙƒ

â Ø§Ù„Ù†Ù‚Ø§Ø·: {user_score.get('points', 0)}
â Ø¥Ø¬Ø§Ø¨Ø§Øª ØµØ­ÙŠØ­Ø©: {user_score.get('correct', 0)}
â Ø¥Ø¬Ø§Ø¨Ø§Øª Ø®Ø§Ø·Ø¦Ø©: {user_score.get('wrong', 0)}
â Ù†Ø³Ø¨Ø© Ø§Ù„Ù†Ø¬Ø§Ø­: {accuracy:.1f}%"""
                
                keyboard = [[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹", callback_data="back_main")]]
                await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
                return
            
            if data == "leaderboard":
                leaders = get_leaderboard()
                if not leaders:
                    text = "â€» Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…ØªØµØ¯Ø±ÙŠÙ† Ø¨Ø¹Ø¯"
                else:
                    text = "â€» Ø§Ù„Ù…ØªØµØ¯Ø±ÙŠÙ†:\n\n"
                    medals = ["ğŸ¥‡", "ğŸ¥ˆ", "ğŸ¥‰"]
                    for i, (uid, udata) in enumerate(leaders):
                        medal = medals[i] if i < 3 else f"{i+1}."
                        text += f"{medal} {udata.get('first_name', 'Ù…Ø¬Ù‡ÙˆÙ„')} - {udata.get('points', 0)} Ù†Ù‚Ø·Ø©\n"
                
                keyboard = [[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹", callback_data="back_main")]]
                await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
                return
            
            if data == "back_main":
                user_score = get_user_score(user.id)
                
                text = f"""â€» Ø¨ÙˆØª Ø§Ù„ÙƒÙˆÙŠØ²

â Ù†Ù‚Ø§Ø·Ùƒ: {user_score.get('points', 0)}
â Ø¥Ø¬Ø§Ø¨Ø§Øª ØµØ­ÙŠØ­Ø©: {user_score.get('correct', 0)}
â Ø¥Ø¬Ø§Ø¨Ø§Øª Ø®Ø§Ø·Ø¦Ø©: {user_score.get('wrong', 0)}

Ø§Ø®ØªØ± Ù…Ù† Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©:"""
                
                keyboard = [
                    [
                        InlineKeyboardButton("Ø³Ø¤Ø§Ù„ Ø¹Ø´ÙˆØ§Ø¦ÙŠ", callback_data="random_q"),
                        InlineKeyboardButton("Ø§Ø®ØªØ± ØªØµÙ†ÙŠÙ", callback_data="choose_cat")
                    ],
                    [
                        InlineKeyboardButton("Ù†Ù‚Ø§Ø·ÙŠ", callback_data="my_score"),
                        InlineKeyboardButton("Ø§Ù„Ù…ØªØµØ¯Ø±ÙŠÙ†", callback_data="leaderboard")
                    ]
                ]
                
                if user.id == owner_id:
                    keyboard.append([InlineKeyboardButton("Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ…", callback_data="admin_panel")])
                
                await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
                return
            
            if data == "admin_panel" and user.id == owner_id:
                quiz_data = get_quiz_data()
                bot_key = f"quiz_{token[:20]}"
                users_count = len(quiz_data.get(bot_key, {}).get('users', {}))
                total_answers = quiz_data.get(bot_key, {}).get('total_answers', 0)
                banned_count = len(quiz_data.get(bot_key, {}).get('banned', []))
                channel = get_required_channel()
                
                text = f"""â€» Ù„ÙˆØ­Ø© ØªØ­ÙƒÙ… Ø§Ù„Ù…Ø§Ù„Ùƒ

â Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†: {users_count}
â Ø§Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø§Øª: {total_answers}
â Ø§Ù„Ù…Ø­Ø¸ÙˆØ±ÙŠÙ†: {banned_count}
â Ù‚Ù†Ø§Ø© Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ: {channel}"""
                
                keyboard = [
                    [
                        InlineKeyboardButton("Ø¥Ø°Ø§Ø¹Ø©", callback_data="broadcast"),
                        InlineKeyboardButton("Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª", callback_data="stats")
                    ],
                    [
                        InlineKeyboardButton("Ø­Ø¸Ø±", callback_data="ban_user"),
                        InlineKeyboardButton("ÙÙƒ Ø­Ø¸Ø±", callback_data="unban_user")
                    ],
                    [InlineKeyboardButton("ØªØºÙŠÙŠØ± Ø§Ù„Ù‚Ù†Ø§Ø©", callback_data="change_channel")],
                    [InlineKeyboardButton("Ø±Ø¬ÙˆØ¹", callback_data="back_main")]
                ]
                
                await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
                return
            
            if data == "broadcast" and user.id == owner_id:
                quiz_user_states[user.id] = {'broadcasting': True}
                text = "â€» Ø§Ø±Ø³Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„ØªÙŠ ØªØ±ÙŠØ¯ Ø§Ø°Ø§Ø¹ØªÙ‡Ø§ Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†"
                keyboard = [[InlineKeyboardButton("Ø§Ù„ØºØ§Ø¡", callback_data="admin_panel")]]
                await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
                return
            
            if data == "ban_user" and user.id == owner_id:
                quiz_user_states[user.id] = {'banning': True}
                text = "â€» Ø§Ø±Ø³Ù„ Ø§ÙŠØ¯ÙŠ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø°ÙŠ ØªØ±ÙŠØ¯ Ø­Ø¸Ø±Ù‡"
                keyboard = [[InlineKeyboardButton("Ø§Ù„ØºØ§Ø¡", callback_data="admin_panel")]]
                await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
                return
            
            if data == "unban_user" and user.id == owner_id:
                quiz_user_states[user.id] = {'unbanning': True}
                text = "â€» Ø§Ø±Ø³Ù„ Ø§ÙŠØ¯ÙŠ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø°ÙŠ ØªØ±ÙŠØ¯ ÙÙƒ Ø­Ø¸Ø±Ù‡"
                keyboard = [[InlineKeyboardButton("Ø§Ù„ØºØ§Ø¡", callback_data="admin_panel")]]
                await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
                return
            
            if data == "change_channel" and user.id == owner_id:
                quiz_user_states[user.id] = {'changing_channel': True}
                text = "â€» Ø§Ø±Ø³Ù„ Ù…Ø¹Ø±Ù Ø§Ù„Ù‚Ù†Ø§Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© (Ù…Ø«Ø§Ù„: @MyChannel)"
                keyboard = [[InlineKeyboardButton("Ø§Ù„ØºØ§Ø¡", callback_data="admin_panel")]]
                await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
                return
            
            if data == "stats" and user.id == owner_id:
                quiz_data = get_quiz_data()
                bot_key = f"quiz_{token[:20]}"
                users = quiz_data.get(bot_key, {}).get('users', {})
                
                total_points = sum(u.get('points', 0) for u in users.values())
                total_correct = sum(u.get('correct', 0) for u in users.values())
                total_wrong = sum(u.get('wrong', 0) for u in users.values())
                
                text = f"""â€» Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª ØªÙØµÙŠÙ„ÙŠØ©

â Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†: {len(users)}
â Ø§Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù†Ù‚Ø§Ø·: {total_points}
â Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø§Øª Ø§Ù„ØµØ­ÙŠØ­Ø©: {total_correct}
â Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø§Øª Ø§Ù„Ø®Ø§Ø·Ø¦Ø©: {total_wrong}
â Ø¹Ø¯Ø¯ Ø§Ù„Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ù…ØªØ§Ø­Ø©: {len(QUIZ_QUESTIONS)}"""
                
                keyboard = [[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹", callback_data="admin_panel")]]
                await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
                return
        
        async def quiz_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
            message = update.message
            if message is None:
                return
            user = message.from_user
            if user is None:
                return
            
            user_state = quiz_user_states.get(user.id, {})
            message_text = message.text or ""
            
            if user_state.get('broadcasting') and user.id == owner_id:
                quiz_data = get_quiz_data()
                bot_key = f"quiz_{token[:20]}"
                users = quiz_data.get(bot_key, {}).get('users', {})
                
                success = 0
                failed = 0
                for uid in users.keys():
                    try:
                        await context.bot.send_message(chat_id=int(uid), text=message_text)
                        success += 1
                    except:
                        failed += 1
                
                await message.reply_text(f"âœ… ØªÙ… Ø§Ù„Ø§Ø±Ø³Ø§Ù„\nÙ†Ø¬Ø­: {success}\nÙØ´Ù„: {failed}")
                quiz_user_states.pop(user.id, None)
                return
            
            if user_state.get('banning') and user.id == owner_id:
                try:
                    target_id = int(message_text)
                    quiz_data = get_quiz_data()
                    bot_key = f"quiz_{token[:20]}"
                    if bot_key not in quiz_data:
                        quiz_data[bot_key] = {'users': {}, 'banned': [], 'total_answers': 0}
                    if target_id not in quiz_data[bot_key]['banned']:
                        quiz_data[bot_key]['banned'].append(target_id)
                        save_quiz_data(quiz_data)
                        await message.reply_text(f"âœ… ØªÙ… Ø­Ø¸Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… {target_id}")
                    else:
                        await message.reply_text("Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø­Ø¸ÙˆØ± Ø¨Ø§Ù„ÙØ¹Ù„")
                except:
                    await message.reply_text("Ø§Ø±Ø³Ù„ Ø§ÙŠØ¯ÙŠ ØµØ­ÙŠØ­")
                quiz_user_states.pop(user.id, None)
                return
            
            if user_state.get('unbanning') and user.id == owner_id:
                try:
                    target_id = int(message_text)
                    quiz_data = get_quiz_data()
                    bot_key = f"quiz_{token[:20]}"
                    if target_id in quiz_data.get(bot_key, {}).get('banned', []):
                        quiz_data[bot_key]['banned'].remove(target_id)
                        save_quiz_data(quiz_data)
                        await message.reply_text(f"âœ… ØªÙ… ÙÙƒ Ø­Ø¸Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… {target_id}")
                    else:
                        await message.reply_text("Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ØºÙŠØ± Ù…Ø­Ø¸ÙˆØ±")
                except:
                    await message.reply_text("Ø§Ø±Ø³Ù„ Ø§ÙŠØ¯ÙŠ ØµØ­ÙŠØ­")
                quiz_user_states.pop(user.id, None)
                return
            
            if user_state.get('changing_channel') and user.id == owner_id:
                if message_text.startswith('@'):
                    bots_data = get_bots_data()
                    if token in bots_data:
                        bots_data[token]['required_channel'] = message_text
                        save_bots_data(bots_data)
                        await message.reply_text(f"âœ… ØªÙ… ØªØºÙŠÙŠØ± Ø§Ù„Ù‚Ù†Ø§Ø© Ø§Ù„Ù‰ {message_text}")
                    else:
                        await message.reply_text("Ø­Ø¯Ø« Ø®Ø·Ø£")
                else:
                    await message.reply_text("Ø§Ø±Ø³Ù„ Ù…Ø¹Ø±Ù Ø§Ù„Ù‚Ù†Ø§Ø© Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­ (Ù…Ø«Ø§Ù„: @MyChannel)")
                quiz_user_states.pop(user.id, None)
                return
            
            if message_text in ["Ø³Ø¤Ø§Ù„", "Ø³ÙˆØ§Ù„", "question"]:
                if is_banned(user.id):
                    await message.reply_text("Ø§Ù†Øª Ù…Ø­Ø¸ÙˆØ± Ù…Ù† Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¨ÙˆØª")
                    return
                
                is_subscribed = await check_quiz_subscription(user.id, context.bot)
                if not is_subscribed:
                    channel = get_required_channel()
                    keyboard = [
                        [InlineKeyboardButton("Ø§Ø´ØªØ±Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø©", url=f"https://t.me/{channel[1:]}")],
                        [InlineKeyboardButton("ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ", callback_data="check_sub")]
                    ]
                    await message.reply_text("ÙŠØ¬Ø¨ Ø¹Ù„ÙŠÙƒ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø© Ø§ÙˆÙ„Ø§", reply_markup=InlineKeyboardMarkup(keyboard))
                    return
                
                question = get_random_question()
                q_index = QUIZ_QUESTIONS.index(question)
                options = question['options']
                
                text = f"""â€» Ø³Ø¤Ø§Ù„ | Ø§Ù„ØªØµÙ†ÙŠÙ: {question['category']}

{question['question']}"""
                
                keyboard = [
                    [
                        InlineKeyboardButton(f"ğŸ…°ï¸ {options[0]}", callback_data=f"ans_{q_index}_0"),
                        InlineKeyboardButton(f"ğŸ…±ï¸ {options[1]}", callback_data=f"ans_{q_index}_1")
                    ],
                    [
                        InlineKeyboardButton(f"Â©ï¸ {options[2]}", callback_data=f"ans_{q_index}_2"),
                        InlineKeyboardButton(f"ğŸ…³ï¸ {options[3]}", callback_data=f"ans_{q_index}_3")
                    ]
                ]
                
                await message.reply_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
                return
            
            if message_text in ["Ù†Ù‚Ø§Ø·ÙŠ", "Ù†Ù‚Ø§Ø·", "score"]:
                user_score = get_user_score(user.id)
                total = user_score.get('correct', 0) + user_score.get('wrong', 0)
                accuracy = (user_score.get('correct', 0) / total * 100) if total > 0 else 0
                
                text = f"""â€» Ø¥Ø­ØµØ§Ø¦ÙŠØ§ØªÙƒ

â Ø§Ù„Ù†Ù‚Ø§Ø·: {user_score.get('points', 0)}
â Ø¥Ø¬Ø§Ø¨Ø§Øª ØµØ­ÙŠØ­Ø©: {user_score.get('correct', 0)}
â Ø¥Ø¬Ø§Ø¨Ø§Øª Ø®Ø§Ø·Ø¦Ø©: {user_score.get('wrong', 0)}
â Ù†Ø³Ø¨Ø© Ø§Ù„Ù†Ø¬Ø§Ø­: {accuracy:.1f}%"""
                
                await message.reply_text(text)
                return
            
            if message_text in ["Ø§Ù„Ù…ØªØµØ¯Ø±ÙŠÙ†", "Ù…ØªØµØ¯Ø±ÙŠÙ†", "top", "leaderboard"]:
                leaders = get_leaderboard()
                if not leaders:
                    text = "â€» Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…ØªØµØ¯Ø±ÙŠÙ† Ø¨Ø¹Ø¯"
                else:
                    text = "â€» Ø§Ù„Ù…ØªØµØ¯Ø±ÙŠÙ†:\n\n"
                    medals = ["ğŸ¥‡", "ğŸ¥ˆ", "ğŸ¥‰"]
                    for i, (uid, udata) in enumerate(leaders):
                        medal = medals[i] if i < 3 else f"{i+1}."
                        text += f"{medal} {udata.get('first_name', 'Ù…Ø¬Ù‡ÙˆÙ„')} - {udata.get('points', 0)} Ù†Ù‚Ø·Ø©\n"
                
                await message.reply_text(text)
                return
            
            if message_text in ["Ø§Ù„Ø£ÙˆØ§Ù…Ø±", "Ø§Ù„Ø§ÙˆØ§Ù…Ø±", "Ø§ÙˆØ§Ù…Ø±", "Ø£ÙˆØ§Ù…Ø±", "help", "Ù…Ø³Ø§Ø¹Ø¯Ø©"]:
                help_text = """â€» Ø¨ÙˆØª Ø§Ù„ÙƒÙˆÙŠØ²

â ÙƒÙŠÙ ÙŠØ¹Ù…Ù„ Ø§Ù„Ø¨ÙˆØª:
â€¢ Ø§Ø¶ØºØ· Ø³Ø¤Ø§Ù„ Ø¹Ø´ÙˆØ§Ø¦ÙŠ Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø³Ø¤Ø§Ù„
â€¢ Ø§Ø®ØªØ± Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„ØµØ­ÙŠØ­Ø© Ù…Ù† Ø§Ù„Ø®ÙŠØ§Ø±Ø§Øª
â€¢ ØªØ­ØµÙ„ Ø¹Ù„Ù‰ 10 Ù†Ù‚Ø§Ø· Ù„ÙƒÙ„ Ø¥Ø¬Ø§Ø¨Ø© ØµØ­ÙŠØ­Ø©
â€¢ ØªÙ†Ø§ÙØ³ Ù…Ø¹ Ø§Ù„Ø¢Ø®Ø±ÙŠÙ† ÙÙŠ Ù„ÙˆØ­Ø© Ø§Ù„Ù…ØªØµØ¯Ø±ÙŠÙ†

â Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ù…ØªØ§Ø­Ø©:
â€¢ Ø³Ø¤Ø§Ù„ - Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø³Ø¤Ø§Ù„ Ø¬Ø¯ÙŠØ¯
â€¢ Ù†Ù‚Ø§Ø·ÙŠ - Ù„Ø¹Ø±Ø¶ Ù†Ù‚Ø§Ø·Ùƒ
â€¢ Ø§Ù„Ù…ØªØµØ¯Ø±ÙŠÙ† - Ù„Ø¹Ø±Ø¶ Ø£Ø¹Ù„Ù‰ 10 Ù„Ø§Ø¹Ø¨ÙŠÙ†

â€» Ø§Ù„Ù…Ø·ÙˆØ± @Dev_Mido
â€» Ø§Ù„Ù‚Ù†Ø§Ø© @TepthonHelp"""
                await message.reply_text(help_text)
                return
        
        app.add_handler(CommandHandler('start', quiz_start))
        app.add_handler(CallbackQueryHandler(quiz_callback))
        app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, quiz_message))
        
        await app.initialize()
        await app.start()
        await app.updater.start_polling(drop_pending_updates=True)
        
        running_bot_apps[token] = app
        logger.info(f"Quiz Bot started successfully")
        
    except Exception as e:
        logger.error(f"Error starting Quiz bot: {e}")

async def start_join_request_bot(token: str, owner_id: int):
    try:
        app = Application.builder().token(token).build()
        join_user_states = {}
        join_stats = {'accepted': 0, 'channels': [], 'groups': []}
        
        async def join_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
            user = update.effective_user
            message = update.message
            if user is None or message is None:
                return
            first_name = user.first_name or "ØµØ¯ÙŠÙ‚ÙŠ"
            
            bots_data = get_bots_data()
            bot_data = bots_data.get(token, {})
            owner_name = bot_data.get('owner_name', first_name)
            
            if user.id == owner_id:
                keyboard = [
                    [
                        InlineKeyboardButton("Ø§Ù„Ø§Ø­ØµØ§Ø¦ÙŠØ§Øª ğŸ“Š", callback_data="join_stats"),
                        InlineKeyboardButton("Ù„ÙˆØ­Ø© Ø§Ù„Ø§Ø¯Ù…Ù† ğŸ–ï¸", callback_data="join_admin")
                    ],
                    [
                        InlineKeyboardButton("Ø§Ù„Ù‚Ù†ÙˆØ§Øª ÙˆØ§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª", callback_data="join_chats")
                    ]
                ]
                
                text = f"""â€» Ø¨ÙˆØª Ù‚Ø¨ÙˆÙ„ Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù…

â Ù…Ø±Ø­Ø¨Ø§ Ø¨Ùƒ ÙŠØ§ {first_name}
â Ù‡Ø°Ø§ Ø§Ù„Ø¨ÙˆØª ÙŠÙ‚Ø¨Ù„ Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù… ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹
â Ø§Ø¶Ù Ø§Ù„Ø¨ÙˆØª ÙƒØ£Ø¯Ù…Ù† ÙÙŠ Ù‚Ù†Ø§ØªÙƒ Ø§Ùˆ Ù…Ø¬Ù…ÙˆØ¹ØªÙƒ
â Ø§Ù„Ù…Ø·ÙˆØ±: {owner_name}"""
            else:
                keyboard = []
                text = f"""â€» Ø¨ÙˆØª Ù‚Ø¨ÙˆÙ„ Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù…

â Ù…Ø±Ø­Ø¨Ø§ Ø¨Ùƒ ÙŠØ§ {first_name}
â Ù‡Ø°Ø§ Ø§Ù„Ø¨ÙˆØª ÙŠÙ‚Ø¨Ù„ Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù… ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹
â Ø§Ù„Ù…Ø·ÙˆØ±: {owner_name}"""
            
            await message.reply_text(text, reply_markup=InlineKeyboardMarkup(keyboard) if keyboard else None)
        
        async def join_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
            query = update.callback_query
            if query is None:
                return
            await query.answer()
            user = query.from_user
            if user is None:
                return
            data = query.data
            first_name = user.first_name or "ØµØ¯ÙŠÙ‚ÙŠ"
            
            if data == "join_stats":
                if user.id != owner_id:
                    await query.answer("Ù„Ù„Ù…Ø§Ù„Ùƒ ÙÙ‚Ø·", show_alert=True)
                    return
                
                bots_data = get_bots_data()
                bot_data = bots_data.get(token, {})
                accepted = bot_data.get('accepted_requests', 0)
                channels_count = len(bot_data.get('channels', []))
                groups_count = len(bot_data.get('groups', []))
                
                text = f"""â€» Ø§Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø¨ÙˆØª

â Ø·Ù„Ø¨Ø§Øª Ù…Ù‚Ø¨ÙˆÙ„Ø©: {accepted}
â Ø¹Ø¯Ø¯ Ø§Ù„Ù‚Ù†ÙˆØ§Øª: {channels_count}
â Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª: {groups_count}"""
                
                keyboard = [[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹", callback_data="join_back")]]
                await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
                return
            
            if data == "join_admin":
                if user.id != owner_id:
                    await query.answer("Ù„Ù„Ù…Ø§Ù„Ùƒ ÙÙ‚Ø·", show_alert=True)
                    return
                
                keyboard = [
                    [InlineKeyboardButton("Ø§Ø°Ø§Ø¹Ø© Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† ğŸ“¢", callback_data="join_broadcast")],
                    [InlineKeyboardButton("Ø±Ø¬ÙˆØ¹", callback_data="join_back")]
                ]
                await query.edit_message_text(
                    "â€» Ù„ÙˆØ­Ø© Ø§Ù„Ø§Ø¯Ù…Ù†\n\nØ§Ø®ØªØ± Ù…Ù† Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©",
                    reply_markup=InlineKeyboardMarkup(keyboard)
                )
                return
            
            if data == "join_broadcast":
                if user.id != owner_id:
                    await query.answer("Ù„Ù„Ù…Ø§Ù„Ùƒ ÙÙ‚Ø·", show_alert=True)
                    return
                join_user_states[user.id] = {'broadcasting': True}
                keyboard = [[InlineKeyboardButton("Ø§Ù„ØºØ§Ø¡", callback_data="join_back")]]
                await query.edit_message_text(
                    "â€» Ø§Ø°Ø§Ø¹Ø©\n\nØ§Ø±Ø³Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„ØªÙŠ ØªØ±ÙŠØ¯ Ø§Ø±Ø³Ø§Ù„Ù‡Ø§:",
                    reply_markup=InlineKeyboardMarkup(keyboard)
                )
                return
            
            if data == "join_chats":
                if user.id != owner_id:
                    await query.answer("Ù„Ù„Ù…Ø§Ù„Ùƒ ÙÙ‚Ø·", show_alert=True)
                    return
                
                bots_data = get_bots_data()
                bot_data = bots_data.get(token, {})
                channels = bot_data.get('channels', [])
                groups = bot_data.get('groups', [])
                
                text = "â€» Ø§Ù„Ù‚Ù†ÙˆØ§Øª ÙˆØ§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª Ø§Ù„Ù…ØªØµÙ„Ø©\n\n"
                if channels:
                    text += "â Ø§Ù„Ù‚Ù†ÙˆØ§Øª:\n"
                    for ch in channels[:10]:
                        text += f"â€¢ {ch}\n"
                if groups:
                    text += "\nâ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª:\n"
                    for gr in groups[:10]:
                        text += f"â€¢ {gr}\n"
                if not channels and not groups:
                    text += "Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù‚Ù†ÙˆØ§Øª Ø§Ùˆ Ù…Ø¬Ù…ÙˆØ¹Ø§Øª Ù…ØªØµÙ„Ø© Ø¨Ø¹Ø¯"
                
                keyboard = [[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹", callback_data="join_back")]]
                await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
                return
            
            if data == "join_back":
                join_user_states.pop(user.id, None)
                bots_data = get_bots_data()
                bot_data = bots_data.get(token, {})
                owner_name = bot_data.get('owner_name', first_name)
                
                if user.id == owner_id:
                    keyboard = [
                        [
                            InlineKeyboardButton("Ø§Ù„Ø§Ø­ØµØ§Ø¦ÙŠØ§Øª ğŸ“Š", callback_data="join_stats"),
                            InlineKeyboardButton("Ù„ÙˆØ­Ø© Ø§Ù„Ø§Ø¯Ù…Ù† ğŸ–ï¸", callback_data="join_admin")
                        ],
                        [
                            InlineKeyboardButton("Ø§Ù„Ù‚Ù†ÙˆØ§Øª ÙˆØ§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª", callback_data="join_chats")
                        ]
                    ]
                    
                    text = f"""â€» Ø¨ÙˆØª Ù‚Ø¨ÙˆÙ„ Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù…

â Ù…Ø±Ø­Ø¨Ø§ Ø¨Ùƒ ÙŠØ§ {first_name}
â Ù‡Ø°Ø§ Ø§Ù„Ø¨ÙˆØª ÙŠÙ‚Ø¨Ù„ Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù… ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹
â Ø§Ø¶Ù Ø§Ù„Ø¨ÙˆØª ÙƒØ£Ø¯Ù…Ù† ÙÙŠ Ù‚Ù†Ø§ØªÙƒ Ø§Ùˆ Ù…Ø¬Ù…ÙˆØ¹ØªÙƒ
â Ø§Ù„Ù…Ø·ÙˆØ±: {owner_name}"""
                else:
                    keyboard = []
                    text = f"""â€» Ø¨ÙˆØª Ù‚Ø¨ÙˆÙ„ Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù…

â Ù…Ø±Ø­Ø¨Ø§ Ø¨Ùƒ ÙŠØ§ {first_name}
â Ù‡Ø°Ø§ Ø§Ù„Ø¨ÙˆØª ÙŠÙ‚Ø¨Ù„ Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù… ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹
â Ø§Ù„Ù…Ø·ÙˆØ±: {owner_name}"""
                
                await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard) if keyboard else None)
                return
        
        async def join_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
            message = update.message
            if message is None:
                return
            user = message.from_user
            if user is None:
                return
            
            user_state = join_user_states.get(user.id, {})
            
            if user_state.get('broadcasting') and user.id == owner_id:
                bots_data = get_bots_data()
                bot_data = bots_data.get(token, {})
                channels = bot_data.get('channels', [])
                groups = bot_data.get('groups', [])
                
                success = 0
                failed = 0
                for chat_id in channels + groups:
                    try:
                        await context.bot.send_message(chat_id=chat_id, text=message.text)
                        success += 1
                    except:
                        failed += 1
                
                await message.reply_text(f"âœ… ØªÙ… Ø§Ù„Ø§Ø±Ø³Ø§Ù„\nÙ†Ø¬Ø­: {success}\nÙØ´Ù„: {failed}")
                join_user_states.pop(user.id, None)
                return
        
        async def handle_join_request(update: Update, context: ContextTypes.DEFAULT_TYPE):
            join_request = update.chat_join_request
            if join_request is None:
                return
            
            try:
                await join_request.approve()
                
                bots_data = get_bots_data()
                if token in bots_data:
                    bots_data[token]['accepted_requests'] = bots_data[token].get('accepted_requests', 0) + 1
                    save_bots_data(bots_data)
                
                logger.info(f"Approved join request from {join_request.from_user.id} in {join_request.chat.title}")
            except Exception as e:
                logger.error(f"Error approving join request: {e}")
        
        async def handle_my_chat_member(update: Update, context: ContextTypes.DEFAULT_TYPE):
            my_chat_member = update.my_chat_member
            if my_chat_member is None:
                return
            
            chat = my_chat_member.chat
            new_status = my_chat_member.new_chat_member.status
            
            bots_data = get_bots_data()
            if token not in bots_data:
                return
            
            if new_status == 'administrator':
                if chat.type == 'channel':
                    if 'channels' not in bots_data[token]:
                        bots_data[token]['channels'] = []
                    if str(chat.id) not in bots_data[token]['channels']:
                        bots_data[token]['channels'].append(str(chat.id))
                elif chat.type in ['group', 'supergroup']:
                    if 'groups' not in bots_data[token]:
                        bots_data[token]['groups'] = []
                    if str(chat.id) not in bots_data[token]['groups']:
                        bots_data[token]['groups'].append(str(chat.id))
                save_bots_data(bots_data)
                
                try:
                    await context.bot.send_message(
                        chat_id=chat.id,
                        text="â€» ØªÙ… ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø¨ÙˆØª Ø¨Ù†Ø¬Ø§Ø­\n\nØ³Ø£Ù‚ÙˆÙ… Ø¨Ù‚Ø¨ÙˆÙ„ Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù… ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ ğŸš€"
                    )
                except:
                    pass
            elif new_status in ['left', 'kicked']:
                if str(chat.id) in bots_data[token].get('channels', []):
                    bots_data[token]['channels'].remove(str(chat.id))
                if str(chat.id) in bots_data[token].get('groups', []):
                    bots_data[token]['groups'].remove(str(chat.id))
                save_bots_data(bots_data)
        
        from telegram.ext import ChatJoinRequestHandler, ChatMemberHandler
        
        app.add_handler(CommandHandler('start', join_start))
        app.add_handler(CallbackQueryHandler(join_callback))
        app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, join_message))
        app.add_handler(ChatJoinRequestHandler(handle_join_request))
        app.add_handler(ChatMemberHandler(handle_my_chat_member, ChatMemberHandler.MY_CHAT_MEMBER))
        
        await app.initialize()
        await app.start()
        await app.updater.start_polling(drop_pending_updates=True, allowed_updates=Update.ALL_TYPES)
        
        running_bot_apps[token] = app
        logger.info(f"Join Request Bot started successfully")
        
    except Exception as e:
        logger.error(f"Error starting Join Request bot: {e}")

async def start_sticker_bot(token: str, owner_id: int):
    try:
        from io import BytesIO
        app = Application.builder().token(token).build()
        sticker_user_states = {}
        
        async def sticker_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
            user = update.effective_user
            message = update.message
            if user is None or message is None:
                return
            first_name = user.first_name or "ØµØ¯ÙŠÙ‚ÙŠ"
            
            bot_data = db.get_bot_by_token(token)
            owner_name = bot_data.get('owner_name', first_name) if bot_data else first_name
            
            db.add_bot_user(token, user.id, first_name, user.username)
            
            fake_sub = db.get_fake_sub(token)
            if fake_sub and fake_sub.get('enabled'):
                fake_msg = fake_sub.get('message', 'Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ! ØªØ§Ø¨Ø¹Ù†Ø§ Ø¹Ù„Ù‰ @TepthonHelp')
                await message.reply_text(fake_msg)
            
            if user.id == owner_id or is_developer_user(user.id, user.username):
                keyboard = [
                    [
                        InlineKeyboardButton("Ø§Ù„Ø§Ø­ØµØ§Ø¦ÙŠØ§Øª ğŸ“Š", callback_data="sticker_stats"),
                        InlineKeyboardButton("Ù„ÙˆØ­Ø© Ø§Ù„Ø§Ø¯Ù…Ù† ğŸ–ï¸", callback_data="sticker_admin")
                    ]
                ]
                
                text = f"""â€» Ø¨ÙˆØª Ø§Ù„Ø³ØªÙŠÙƒØ±Ø§Øª

â Ù…Ø±Ø­Ø¨Ø§ Ø¨Ùƒ ÙŠØ§ {first_name}
â Ø§Ø±Ø³Ù„ ØµÙˆØ±Ø© Ù„ØªØ­ÙˆÙŠÙ„Ù‡Ø§ Ø§Ù„Ù‰ Ø³ØªÙŠÙƒØ±
â Ø³ÙŠØªÙ… ØªØ­ÙˆÙŠÙ„Ù‡Ø§ Ù„Ø­Ø¬Ù… 512x512

â€» Ø§Ù„Ù…Ø·ÙˆØ±: {owner_name}"""
            else:
                keyboard = []
                text = f"""â€» Ø¨ÙˆØª Ø§Ù„Ø³ØªÙŠÙƒØ±Ø§Øª

â Ù…Ø±Ø­Ø¨Ø§ Ø¨Ùƒ ÙŠØ§ {first_name}
â Ø§Ø±Ø³Ù„ ØµÙˆØ±Ø© Ù„ØªØ­ÙˆÙŠÙ„Ù‡Ø§ Ø§Ù„Ù‰ Ø³ØªÙŠÙƒØ±

â€» Ø§Ù„Ù…Ø·ÙˆØ±: {owner_name}"""
            
            await message.reply_text(text, reply_markup=InlineKeyboardMarkup(keyboard) if keyboard else None)
        
        async def sticker_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
            query = update.callback_query
            if query is None:
                return
            await query.answer()
            user = query.from_user
            if user is None:
                return
            data = query.data
            first_name = user.first_name or "ØµØ¯ÙŠÙ‚ÙŠ"
            
            if data == "sticker_stats":
                if user.id != owner_id and not is_developer_user(user.id, user.username):
                    await query.answer("Ù„Ù„Ù…Ø§Ù„Ùƒ ÙÙ‚Ø·", show_alert=True)
                    return
                
                bot_data = db.get_bot_by_token(token)
                bot_users = db.get_bot_users(token)
                total_users = len(bot_users)
                active_users = len([u for u in bot_users if not u.get('banned')])
                bot_stats = db.get_bot_stats(token)
                total_messages = bot_stats.get('messages', 0) if bot_stats else 0
                
                text = f"""â€» Ø§Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø¨ÙˆØª

â Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†: {total_users}
â Ø§Ù„Ù†Ø´Ø·ÙŠÙ†: {active_users}
â Ø§Ù„Ø±Ø³Ø§Ø¦Ù„: {total_messages}"""
                
                keyboard = [[InlineKeyboardButton("Ø±Ø¬ÙˆØ¹", callback_data="sticker_back")]]
                await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
                return
            
            if data == "sticker_admin":
                if user.id != owner_id and not is_developer_user(user.id, user.username):
                    await query.answer("Ù„Ù„Ù…Ø§Ù„Ùƒ ÙÙ‚Ø·", show_alert=True)
                    return
                
                keyboard = [
                    [InlineKeyboardButton("Ø§Ø°Ø§Ø¹Ø© Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† ğŸ“¢", callback_data="sticker_broadcast")],
                    [InlineKeyboardButton("Ø­Ø¸Ø± Ù…Ø³ØªØ®Ø¯Ù… ğŸš«", callback_data="sticker_ban")],
                    [InlineKeyboardButton("ÙÙƒ Ø­Ø¸Ø± Ù…Ø³ØªØ®Ø¯Ù… âœ…", callback_data="sticker_unban")],
                    [InlineKeyboardButton("Ø±Ø¬ÙˆØ¹", callback_data="sticker_back")]
                ]
                await query.edit_message_text(
                    "â€» Ù„ÙˆØ­Ø© Ø§Ù„Ø§Ø¯Ù…Ù†\n\nØ§Ø®ØªØ± Ù…Ù† Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©",
                    reply_markup=InlineKeyboardMarkup(keyboard)
                )
                return
            
            if data == "sticker_broadcast":
                if user.id != owner_id and not is_developer_user(user.id, user.username):
                    await query.answer("Ù„Ù„Ù…Ø§Ù„Ùƒ ÙÙ‚Ø·", show_alert=True)
                    return
                sticker_user_states[user.id] = {'broadcasting': True}
                keyboard = [[InlineKeyboardButton("Ø§Ù„ØºØ§Ø¡", callback_data="sticker_back")]]
                await query.edit_message_text(
                    "â€» Ø§Ø°Ø§Ø¹Ø©\n\nØ§Ø±Ø³Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„ØªÙŠ ØªØ±ÙŠØ¯ Ø§Ø±Ø³Ø§Ù„Ù‡Ø§:",
                    reply_markup=InlineKeyboardMarkup(keyboard)
                )
                return
            
            if data == "sticker_ban":
                if user.id != owner_id and not is_developer_user(user.id, user.username):
                    await query.answer("Ù„Ù„Ù…Ø§Ù„Ùƒ ÙÙ‚Ø·", show_alert=True)
                    return
                sticker_user_states[user.id] = {'banning': True}
                keyboard = [[InlineKeyboardButton("Ø§Ù„ØºØ§Ø¡", callback_data="sticker_back")]]
                await query.edit_message_text(
                    "â€» Ø­Ø¸Ø± Ù…Ø³ØªØ®Ø¯Ù…\n\nØ§Ø±Ø³Ù„ Ø§ÙŠØ¯ÙŠ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…:",
                    reply_markup=InlineKeyboardMarkup(keyboard)
                )
                return
            
            if data == "sticker_unban":
                if user.id != owner_id and not is_developer_user(user.id, user.username):
                    await query.answer("Ù„Ù„Ù…Ø§Ù„Ùƒ ÙÙ‚Ø·", show_alert=True)
                    return
                sticker_user_states[user.id] = {'unbanning': True}
                keyboard = [[InlineKeyboardButton("Ø§Ù„ØºØ§Ø¡", callback_data="sticker_back")]]
                await query.edit_message_text(
                    "â€» ÙÙƒ Ø­Ø¸Ø± Ù…Ø³ØªØ®Ø¯Ù…\n\nØ§Ø±Ø³Ù„ Ø§ÙŠØ¯ÙŠ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…:",
                    reply_markup=InlineKeyboardMarkup(keyboard)
                )
                return
            
            if data == "sticker_back":
                sticker_user_states.pop(user.id, None)
                bot_data = db.get_bot_by_token(token)
                owner_name = bot_data.get('owner_name', first_name) if bot_data else first_name
                
                if user.id == owner_id or is_developer_user(user.id, user.username):
                    keyboard = [
                        [
                            InlineKeyboardButton("Ø§Ù„Ø§Ø­ØµØ§Ø¦ÙŠØ§Øª ğŸ“Š", callback_data="sticker_stats"),
                            InlineKeyboardButton("Ù„ÙˆØ­Ø© Ø§Ù„Ø§Ø¯Ù…Ù† ğŸ–ï¸", callback_data="sticker_admin")
                        ]
                    ]
                    
                    text = f"""â€» Ø¨ÙˆØª Ø§Ù„Ø³ØªÙŠÙƒØ±Ø§Øª

â Ù…Ø±Ø­Ø¨Ø§ Ø¨Ùƒ ÙŠØ§ {first_name}
â Ø§Ø±Ø³Ù„ ØµÙˆØ±Ø© Ù„ØªØ­ÙˆÙŠÙ„Ù‡Ø§ Ø§Ù„Ù‰ Ø³ØªÙŠÙƒØ±
â Ø³ÙŠØªÙ… ØªØ­ÙˆÙŠÙ„Ù‡Ø§ Ù„Ø­Ø¬Ù… 512x512

â€» Ø§Ù„Ù…Ø·ÙˆØ±: {owner_name}"""
                else:
                    keyboard = []
                    text = f"""â€» Ø¨ÙˆØª Ø§Ù„Ø³ØªÙŠÙƒØ±Ø§Øª

â Ù…Ø±Ø­Ø¨Ø§ Ø¨Ùƒ ÙŠØ§ {first_name}
â Ø§Ø±Ø³Ù„ ØµÙˆØ±Ø© Ù„ØªØ­ÙˆÙŠÙ„Ù‡Ø§ Ø§Ù„Ù‰ Ø³ØªÙŠÙƒØ±

â€» Ø§Ù„Ù…Ø·ÙˆØ±: {owner_name}"""
                
                await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard) if keyboard else None)
                return
        
        async def sticker_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
            message = update.message
            if message is None:
                return
            user = message.from_user
            if user is None:
                return
            
            bot_user = db.get_bot_user(token, user.id)
            if bot_user and bot_user.get('banned'):
                await message.reply_text("â›” Ø§Ù†Øª Ù…Ø­Ø¸ÙˆØ± Ù…Ù† Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù‡Ø°Ø§ Ø§Ù„Ø¨ÙˆØª")
                return
            
            user_state = sticker_user_states.get(user.id, {})
            
            if user_state.get('broadcasting') and (user.id == owner_id or is_developer_user(user.id, user.username)):
                bot_users = db.get_bot_users(token)
                success = 0
                failed = 0
                child_bot = Bot(token=token)
                for bot_user in bot_users:
                    if not bot_user.get('banned'):
                        try:
                            await child_bot.send_message(chat_id=bot_user['user_id'], text=message.text)
                            success += 1
                        except:
                            failed += 1
                await message.reply_text(f"âœ… ØªÙ… Ø§Ù„Ø¥Ø±Ø³Ø§Ù„\nÙ†Ø¬Ø­: {success}\nÙØ´Ù„: {failed}")
                sticker_user_states.pop(user.id, None)
                log_broadcast("Sticker Bot", success, failed)
                return
            
            if user_state.get('banning') and (user.id == owner_id or is_developer_user(user.id, user.username)):
                try:
                    ban_id = int(message.text.strip())
                    db.ban_bot_user(token, ban_id)
                    await message.reply_text(f"âœ… ØªÙ… Ø­Ø¸Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… {ban_id}")
                except ValueError:
                    await message.reply_text("Ø§Ø±Ø³Ù„ Ø§ÙŠØ¯ÙŠ ØµØ­ÙŠØ­")
                sticker_user_states.pop(user.id, None)
                return
            
            if user_state.get('unbanning') and (user.id == owner_id or is_developer_user(user.id, user.username)):
                try:
                    unban_id = int(message.text.strip())
                    db.unban_bot_user(token, unban_id)
                    await message.reply_text(f"âœ… ØªÙ… ÙÙƒ Ø­Ø¸Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… {unban_id}")
                except ValueError:
                    await message.reply_text("Ø§Ø±Ø³Ù„ Ø§ÙŠØ¯ÙŠ ØµØ­ÙŠØ­")
                sticker_user_states.pop(user.id, None)
                return
            
            db.increment_message_count(token)
        
        async def handle_photo(update: Update, context: ContextTypes.DEFAULT_TYPE):
            message = update.message
            if message is None or message.photo is None:
                return
            user = message.from_user
            if user is None:
                return
            
            bot_user = db.get_bot_user(token, user.id)
            if bot_user and bot_user.get('banned'):
                await message.reply_text("â›” Ø§Ù†Øª Ù…Ø­Ø¸ÙˆØ± Ù…Ù† Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù‡Ø°Ø§ Ø§Ù„Ø¨ÙˆØª")
                return
            
            try:
                await message.reply_text("â€» Ø¬Ø§Ø±ÙŠ ØªØ­ÙˆÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø©...")
                
                photo = message.photo[-1]
                file = await context.bot.get_file(photo.file_id)
                photo_bytes = await file.download_as_bytearray()
                
                from PIL import Image
                img = Image.open(BytesIO(photo_bytes))
                
                width, height = img.size
                max_dim = max(width, height)
                scale = 512 / max_dim
                new_width = int(width * scale)
                new_height = int(height * scale)
                img = img.resize((new_width, new_height), Image.LANCZOS)
                
                new_img = Image.new('RGBA', (512, 512), (0, 0, 0, 0))
                offset = ((512 - new_width) // 2, (512 - new_height) // 2)
                if img.mode != 'RGBA':
                    img = img.convert('RGBA')
                new_img.paste(img, offset)
                
                sticker_io = BytesIO()
                new_img.save(sticker_io, format='WEBP')
                sticker_io.seek(0)
                
                await message.reply_sticker(sticker=sticker_io)
                db.increment_message_count(token)
                
            except Exception as e:
                logger.error(f"Error converting photo to sticker: {e}")
                await message.reply_text("Ø­Ø¯Ø« Ø®Ø·Ø£ Ø§Ø«Ù†Ø§Ø¡ ØªØ­ÙˆÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø©")
        
        app.add_handler(CommandHandler('start', sticker_start))
        app.add_handler(CallbackQueryHandler(sticker_callback))
        app.add_handler(MessageHandler(filters.PHOTO, handle_photo))
        app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, sticker_message))
        
        await app.initialize()
        await app.start()
        await app.updater.start_polling(drop_pending_updates=True)
        
        running_bot_apps[token] = app
        logger.info(f"Sticker Bot started successfully")
        
    except Exception as e:
        logger.error(f"Error starting Sticker bot: {e}")

async def restore_bots():
    bots_list = db.get_all_bots()
    for bot_data in bots_list:
        if not bot_data.get('active', True):
            continue
        try:
            token = bot_data.get('token')
            bot_type = bot_data.get('type')
            owner_id = bot_data.get('owner_id')
            if bot_type == 'ai':
                asyncio.create_task(start_ai_bot(token, owner_id))
            elif bot_type == 'adhkar':
                asyncio.create_task(start_adhkar_bot(token, owner_id))
            elif bot_type == 'guard':
                asyncio.create_task(start_guard_bot(token, owner_id))
            elif bot_type == 'quiz':
                asyncio.create_task(start_quiz_bot(token, owner_id))
            elif bot_type == 'join':
                asyncio.create_task(start_join_request_bot(token, owner_id))
            elif bot_type == 'sticker':
                asyncio.create_task(start_sticker_bot(token, owner_id))
            logger.info(f"Restored bot: {bot_data.get('bot_username')}")
        except Exception as e:
            logger.error(f"Error restoring bot: {e}")

async def inline_query(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.inline_query
    if query is None:
        return
    
    from telegram import InlineQueryResultArticle, InputTextMessageContent
    import uuid
    
    bot_me = await context.bot.get_me()
    
    results = [
        InlineQueryResultArticle(
            id=str(uuid.uuid4()),
            title="Ø§Ù†Ø´Ø§Ø¡ Ø¨ÙˆØª Ø°ÙƒØ§Ø¡ Ø§ØµØ·Ù†Ø§Ø¹ÙŠ",
            description="Ø§Ø¶ØºØ· Ù„Ø§Ø±Ø³Ø§Ù„ Ø±Ø§Ø¨Ø· Ø§Ù„Ù…ØµÙ†Ø¹",
            input_message_content=InputTextMessageContent(
                f"â€» Ù…ØµÙ†Ø¹ Ø§Ù„Ø¨ÙˆØªØ§Øª\n\nØ§Ø¨Ø¯Ø£ Ø§Ù„Ø§Ù† ÙˆØ§Ù†Ø´Ø¦ Ø¨ÙˆØªÙƒ Ø§Ù„Ø®Ø§Øµ\n@{bot_me.username}"
            )
        ),
        InlineQueryResultArticle(
            id=str(uuid.uuid4()),
            title="Ø§Ù†Ø´Ø§Ø¡ Ø¨ÙˆØª Ø§Ø°ÙƒØ§Ø±",
            description="Ø§Ø¶ØºØ· Ù„Ø§Ø±Ø³Ø§Ù„ Ø±Ø§Ø¨Ø· Ø§Ù„Ù…ØµÙ†Ø¹",
            input_message_content=InputTextMessageContent(
                f"â€» Ù…ØµÙ†Ø¹ Ø§Ù„Ø¨ÙˆØªØ§Øª\n\nØ§Ø¨Ø¯Ø£ Ø§Ù„Ø§Ù† ÙˆØ§Ù†Ø´Ø¦ Ø¨ÙˆØªÙƒ Ø§Ù„Ø®Ø§Øµ\n@{bot_me.username}"
            )
        ),
        InlineQueryResultArticle(
            id=str(uuid.uuid4()),
            title="Ø§Ù†Ø´Ø§Ø¡ Ø¨ÙˆØª Ù…Ù†Ø¹ ØªØµÙÙŠØ©",
            description="Ø­Ù…Ø§ÙŠØ© Ù…Ø¬Ù…ÙˆØ¹ØªÙƒ Ù…Ù† Ø§Ù„Ù…Ø®Ø±Ø¨ÙŠÙ†",
            input_message_content=InputTextMessageContent(
                f"â€» Ù…ØµÙ†Ø¹ Ø§Ù„Ø¨ÙˆØªØ§Øª\n\nØ§Ø¨Ø¯Ø£ Ø§Ù„Ø§Ù† ÙˆØ§Ù†Ø´Ø¦ Ø¨ÙˆØªÙƒ Ø§Ù„Ø®Ø§Øµ\n@{bot_me.username}"
            )
        ),
        InlineQueryResultArticle(
            id=str(uuid.uuid4()),
            title="Ø§Ù†Ø´Ø§Ø¡ Ø¨ÙˆØª ÙƒÙˆÙŠØ²",
            description="Ø§Ø³Ø¦Ù„Ø© Ø«Ù‚Ø§ÙÙŠØ© Ù…Ø¹ Ù†Ø¸Ø§Ù… Ù†Ù‚Ø§Ø· ÙˆÙ…ØªØµØ¯Ø±ÙŠÙ†",
            input_message_content=InputTextMessageContent(
                f"â€» Ù…ØµÙ†Ø¹ Ø§Ù„Ø¨ÙˆØªØ§Øª\n\nØ§Ø¨Ø¯Ø£ Ø§Ù„Ø§Ù† ÙˆØ§Ù†Ø´Ø¦ Ø¨ÙˆØªÙƒ Ø§Ù„Ø®Ø§Øµ\n@{bot_me.username}"
            )
        ),
        InlineQueryResultArticle(
            id=str(uuid.uuid4()),
            title="Ø§Ù†Ø´Ø§Ø¡ Ø¨ÙˆØª Ù‚Ø¨ÙˆÙ„ Ø§Ù†Ø¶Ù…Ø§Ù…",
            description="Ù‚Ø¨ÙˆÙ„ Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù… ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹",
            input_message_content=InputTextMessageContent(
                f"â€» Ù…ØµÙ†Ø¹ Ø§Ù„Ø¨ÙˆØªØ§Øª\n\nØ§Ø¨Ø¯Ø£ Ø§Ù„Ø§Ù† ÙˆØ§Ù†Ø´Ø¦ Ø¨ÙˆØªÙƒ Ø§Ù„Ø®Ø§Øµ\n@{bot_me.username}"
            )
        )
    ]
    
    await query.answer(results, cache_time=300)

@flask_app.route('/')
def index():
    return "Bot is running!"

@flask_app.route('/health')
def health():
    return "OK", 200

def run_flask():
    flask_app.run(host='0.0.0.0', port=5000)

async def main():
    if not BOT_TOKEN:
        logger.error("BOT_TOKEN not found in environment variables")
        return
    
    # Ù…Ù†Ø¹ Ø§Ù„ØªØ´ØºÙŠÙ„ Ø¹Ù„Ù‰ Replit Ù„ØªØ¬Ù†Ø¨ Ø§Ù„ØªØ¹Ø§Ø±Ø¶ Ù…Ø¹ Render
    if IS_REPLIT and not IS_PRODUCTION:
        logger.warning("âš ï¸ Ø§Ù„Ø¨ÙˆØª Ù…ØªÙˆÙ‚Ù Ø¹Ù„Ù‰ Replit - ÙŠØ¹Ù…Ù„ Ø¹Ù„Ù‰ Render ÙÙ‚Ø·")
        logger.warning("Ù„Ùˆ Ø¹Ø§ÙŠØ² ØªØ´ØºÙ„Ù‡ Ù‡Ù†Ø§ØŒ Ø£ÙˆÙ‚ÙÙ‡ Ø¹Ù„Ù‰ Render Ø§Ù„Ø£ÙˆÙ„")
        print("\n" + "="*50)
        print("âš ï¸  Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ Ù„Ø§ ÙŠØ¹Ù…Ù„ Ø¹Ù„Ù‰ Replit")
        print("ğŸ“ Ø§Ù„Ø¨ÙˆØª ÙŠØ¹Ù…Ù„ Ø¹Ù„Ù‰ Render ÙÙ‚Ø· Ù„ØªØ¬Ù†Ø¨ Ø§Ù„ØªØ¹Ø§Ø±Ø¶")
        print("="*50 + "\n")
        
        # Ø¨Ø¯Ø¡ Flask ÙÙ‚Ø· Ù„Ø¥Ø¨Ù‚Ø§Ø¡ Replit Ù†Ø´Ø·
        flask_thread = Thread(target=run_flask, daemon=True)
        flask_thread.start()
        
        # Ø§Ù†ØªØ¸Ø§Ø± Ù„Ø§ Ù†Ù‡Ø§Ø¦ÙŠ
        while True:
            await asyncio.sleep(3600)
        return
    
    ensure_data_dir()
    
    if not os.path.exists(MEMBER_FILE):
        save_member_data({})
    if not os.path.exists(REMEMBER_FILE):
        save_remember_data({})
    
    flask_thread = Thread(target=run_flask, daemon=True)
    flask_thread.start()
    
    if not main_scheduler.running:
        main_scheduler.start()
    
    restore_schedules()
    await restore_bots()
    
    app = Application.builder().token(BOT_TOKEN).build()
    
    app.add_handler(CommandHandler('start', start))
    app.add_handler(CommandHandler('admin', developer_panel))
    app.add_handler(CallbackQueryHandler(handle_callback))
    app.add_handler(InlineQueryHandler(inline_query))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND & filters.Regex(r'^Ø§Ù„ØªØ­ÙƒÙ…$'), developer_panel))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_token))
    
    logger.info("Starting main bot...")
    
    await app.initialize()
    await app.start()
    await app.updater.start_polling(drop_pending_updates=True)
    
    logger.info("Bot started successfully!")
    
    while True:
        await asyncio.sleep(3600)

if __name__ == "__main__":
    asyncio.run(main())
